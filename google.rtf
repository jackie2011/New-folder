{\rtf1\ansi\ansicpg1252\deff0\nouicompat{\fonttbl{\f0\fnil\fcharset0 Calibri;}{\f1\fnil Calibri;}}
{\colortbl ;\red0\green0\blue255;}
{\*\generator Riched20 6.3.9600}\viewkind4\uc1 
\pard\sa200\sl276\slmult1\f0\fs22\lang9 <!DOCTYPE html>\par
<html i18n-values="\par
    dir:textdirection;\par
    hasattribution:hasattribution;\par
    customlogo:customlogo;\par
    themegravity:themegravity;" class="" dir="ltr" hasattribution="false" customlogo="false" themegravity="" os="windows" toolkit="views"><head>\par
<meta charset="utf-8">\par
<title i18n-content="title">New Tab</title>\par
<!-- Don't scale the viewport in either portrait or landscape mode.\par
     Note that this means apps will be reflowed when rotated (like iPad).\par
     If we wanted to maintain position we could remove 'maximum-scale' so\par
     that we'd zoom out in portrait mode, but then there would be a bunch\par
     of unusable space at the bottom.\par
-->\par
<meta name="viewport" content="user-scalable=no, width=device-width, maximum-scale=1.0">\par
\par
<!-- It's important that this be the first script loaded. -->\par
<script>// Copyright (c) 2011 The Chromium Authors. All rights reserved.\par
// Use of this source code is governed by a BSD-style license that can be\par
// found in the LICENSE file.\par
\par
/**\par
 * @fileOverview\par
 * Logging info for benchmarking purposes. Should be the first js file included.\par
 */\par
\par
/* Stack of events that has been logged. */\par
var eventLog = [];\par
\par
/**\par
 * Logs an event.\par
 * @param \{String\} name The name of the event (can be any string).\par
 * @param \{boolean\} shouldLogTime If true, the event is used for benchmarking\par
 *     and the time is logged. Otherwise, just push the event on the event\par
 *     stack.\par
 */\par
function logEvent(name, shouldLogTime) \{\par
  if (shouldLogTime)\par
    chrome.send('metricsHandler:logEventTime', [name]);\par
  eventLog.push([name, Date.now()]);\par
\}\par
\par
logEvent('Tab.NewTabScriptStart', true);\par
window.addEventListener('load', function(e) \{\par
  logEvent('Tab.NewTabOnload', true);\par
\});\par
document.addEventListener('DOMContentLoaded', function(e) \{\par
  logEvent('Tab.NewTabDOMContentLoaded', true);\par
\});\par
</script>\par
\par
<style>/* Copyright (c) 2012 The Chromium Authors. All rights reserved.\par
 * Use of this source code is governed by a BSD-style license that can be\par
 * found in the LICENSE file.\par
 */\par
\par
button:not(.custom-appearance),\par
input[type='button']:not(.custom-appearance),\par
input[type='submit']:not(.custom-appearance) \{\par
  -webkit-border-radius: 3px;\par
  -webkit-box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);\par
  -webkit-user-select: none;\par
  background: -webkit-linear-gradient(#fafafa, #f4f4f4 40%, #e5e5e5);\par
  border: 1px solid #aaa;\par
  color: #444;\par
  font-size: inherit;\par
  margin-bottom: 0;\par
  min-width: 4em;\par
  padding: 3px 12px;\par
\}\par
\par
button:not(.custom-appearance):hover,\par
input[type='button']:not(.custom-appearance):hover,\par
input[type='submit']:not(.custom-appearance):hover \{\par
  -webkit-box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2);\par
  background: #ebebeb -webkit-linear-gradient(#fefefe, #f8f8f8 40%, #e9e9e9);\par
  border-color: #999;\par
  color: #222;\par
\}\par
\par
button:not(.custom-appearance):active,\par
input[type='button']:not(.custom-appearance):active,\par
input[type='submit']:not(.custom-appearance):active \{\par
  -webkit-box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.2);\par
  background: #ebebeb -webkit-linear-gradient(#f4f4f4, #efefef 40%, #dcdcdc);\par
  color: #333;\par
\}\par
\par
button[disabled]:not(.custom-appearance),\par
input[type='button'][disabled]:not(.custom-appearance),\par
input[type='submit'][disabled]:not(.custom-appearance),\par
button[disabled]:not(.custom-appearance):hover,\par
input[type='button'][disabled]:not(.custom-appearance):hover,\par
input[type='submit'][disabled]:not(.custom-appearance):hover \{\par
  -webkit-box-shadow: none;\par
  background: -webkit-linear-gradient(#fafafa, #f4f4f4 40%, #e5e5e5);\par
  border-color: #aaa;\par
  color: #888;\par
\}\par
\par
button:not(.custom-appearance):focus,\par
input[type='submit']:not(.custom-appearance):focus,\par
input[type='text']:not(.custom-appearance):focus,\par
select:not(.custom-appearance):focus \{\par
  -webkit-box-shadow: inset 0 1px 2px white,\par
      0 1px 2px rgba(0, 0, 0, .2),\par
      0 0 1px #c0c0c0,\par
      0 0 1px #c0c0c0,\par
      0 0 1px #c0c0c0;\par
  -webkit-transition: border-color 200ms;\par
  /* We use border color because it follows the border radius (unlike outline).\par
   * This is particularly noticeable on mac. */\par
  border-color: rgb(64, 128, 250);\par
  outline: none;\par
\}\par
\par
/* Search boxes use an outline because it follows the contours of the box. */\par
input[type='search']:not(.custom-appearance):focus \{\par
  outline-color: rgb(64, 128, 250);\par
\}\par
\par
/* TODO(jhawkins): Refactor button styling and remove !important here. This is\par
 * currently necessary because individual page button element selectors have\par
 * higher specificity.\par
 */\par
.link-button,\par
.link-button:focus \{\par
  -webkit-box-shadow: none !important;\par
  background: transparent none !important;\par
  border: none !important;\par
  color: rgb(17, 85, 204) !important;\par
  cursor: pointer;\par
  /* Input elements have -webkit-small-control which overrides the body font.\par
   * Resolve this by using 'inherit'. */\par
  font-family: inherit;\par
  margin: 0;\par
  padding: 0 4px !important;\par
\}\par
\par
.link-button:hover \{\par
  text-decoration: underline;\par
\}\par
\par
.link-button:active \{\par
  color: rgb(5, 37, 119) !important;\par
  text-decoration: underline;\par
\}\par
</style>\par
<style>/* Copyright (c) 2012 The Chromium Authors. All rights reserved.\par
 * Use of this source code is governed by a BSD-style license that can be\par
 * found in the LICENSE file.\par
 */\par
\par
.bubble \{\par
  position: absolute;\par
  /* Height is dynamic, width fixed. */\par
  width: 300px;\par
  z-index: 9999;\par
\}\par
\par
.bubble-contents \{\par
  color: black;\par
  left: 1px;\par
  line-height: 150%;\par
  padding: 8px 11px 12px;\par
  position: relative;\par
  right: 1px;\par
  top: 1px;\par
  width: 298px;\par
  z-index: 3;\par
\}\par
\par
.bubble-close \{\par
  background-image: no-repeat 50% 50%;  \par
  height: 16px;\par
  position: absolute;\par
  right: 6px;\par
  top: 6px;\par
  width: 16px;\par
  z-index: 4;\par
\}\par
\par
html[dir='rtl'] .bubble-close \{\par
  left: 6px;\par
  right: auto;\par
\}\par
\par
.bubble-close \{\par
  background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAQAAAC1+jfqAAAAiElEQVR42r2RsQrDMAxEBRdl8SDcX8lQPGg1GBI6lvz/h7QyRRXV0qUULwfvwZ1tenw5PxToRPWMC52eA9+WDnlh3HFQ/xBQl86NFYJqeGflkiogrOvVlIFhqURFVho3x1moGAa3deMs+LS30CAhBN5nNxeT5hbJ1zwmji2k+aF6NENIPf/hs54f0sZFUVAMigAAAABJRU5ErkJggg==");\par
\}\par
\par
.bubble-close:hover \{\par
  background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAQAAAC1+jfqAAAAqklEQVR4XqWRMQ6DMAxF/1Fyilyj2SmIBUG5QcTCyJA5Z8jGhlBPgRi4TmoDraVmKFJlWYrlp/g5QfwRlwEVNWVa4WzfH9jK6kCkEkBjwxOhLghheMWMELUAqqwQ4OCbnE4LJnhr5IYdqQt4DJQjhe9u4vBBmnxHHNzRFkDGjHDo0VuTAqy2vAG4NkvXXDHxbGsIGlj3e835VFNtdugma/Jk0eXq0lP//5svi4PtO01oFfYAAAAASUVORK5CYII=");\par
\}\par
\par
.bubble-close:active \{\par
  background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAQAAAC1+jfqAAAARElEQVQoz2P4z4AfMlBLAYMdwxkghgEwD1XBGTC0g0sDIaYJECVwFqoChBK4WegKkJWArSJZAQErCDqSKG/iCyhaRhYA9LDIbULDzlIAAAAASUVORK5CYII=");\par
\}\par
\par
.bubble-shadow \{\par
  bottom: -2px;\par
  left: 0;\par
  position: absolute;\par
  right: 0;\par
  top: 0;\par
  z-index: 1;\par
\}\par
\par
.bubble-arrow \{\par
  /* The tip of the arrow.  */\par
  border-bottom-right-radius: 1px;\par
  /* No border on the right or top (inner sides of the rotated square) because\par
   * it would overlap/darken the content shadow. */\par
  border-right: none;\par
  border-top: none;\par
  bottom: -9px;\par
  height: 15px;\par
  left: 22px;\par
  position: absolute;\par
  right: 22px;\par
  width: 15px;\par
  z-index: 2;\par
  -webkit-transform: rotate(45deg);\par
\}\par
\par
.bubble-contents,\par
.bubble-arrow \{\par
  background: white;\par
\}\par
\par
.bubble-arrow[is-right='true'] \{\par
  left: auto;\par
\}\par
\par
.bubble-arrow[is-right='false'] \{\par
  right: auto;\par
\}\par
\par
.bubble-arrow[is-top='true'] \{\par
  bottom: auto;\par
  top: -8px;\par
\}\par
\par
.bubble-shadow,\par
.bubble-arrow \{\par
  border: 1px solid rgba(0, 0, 0, 0.3);\par
  -webkit-box-shadow: 0 2px 6px rgba(0, 0, 0, 0.15);\par
\}\par
\par
.bubble-shadow,\par
.bubble-contents \{\par
  border-radius: 6px;\par
  box-sizing: border-box;\par
\}\par
</style>\par
<style>/* Copyright (c) 2012 The Chromium Authors. All rights reserved.\par
 * Use of this source code is governed by a BSD-style license that can be\par
 * found in the LICENSE file.\par
 */\par
\par
.expandable-bubble \{\par
  -webkit-border-image: url('chrome://theme/IDR_APP_NOTIFICATION_SMALL_BUBBLE')\par
                        5 5 7 6 stretch;\par
  -webkit-box-sizing: border-box;\par
  -webkit-user-select: none;\par
  border-width: 5px 5px 7px 6px;\par
  color: #444;\par
  cursor: pointer;\par
  display: inline-block;\par
  font-size: 12px;\par
  position: absolute;\par
  z-index: 1;\par
\}\par
\par
.expandable-bubble::after \{\par
  bottom: -1px;\par
  content: url('chrome://theme/IDR_APP_NOTIFICATION_NUB');\par
  display: block;\par
  height: 7px;\par
  position: absolute;\par
  right: 5px;  /* TODO(finnur): Need to handle RTL properly. */\par
  width: 9px;\par
\}\par
\par
.expandable-bubble > .expandable-bubble-contents > .expandable-bubble-title \{\par
  display: inline-block;\par
  margin-left: 1px;\par
  margin-top : -3px;\par
  overflow: hidden;\par
  white-space: nowrap;\par
\}\par
\par
.expandable-bubble[masked] > .expandable-bubble-contents >\par
    .expandable-bubble-title::after \{\par
  content: url('chrome://theme/IDR_APP_NOTIFICATION_NUB_MASK');\par
  display: block;\par
  height: 15px;\par
  overflow: hidden;\par
  position: absolute;\par
  right: 0;\par
  top: 0;\par
  width: 12px;\par
\}\par
\par
.expandable-bubble[expanded] > .expandable-bubble-contents >\par
    .expandable-bubble-title \{\par
  font-size: 13px;\par
  margin-left: 0;\par
  margin-bottom: 3px;\par
\}\par
\par
.expandable-bubble-close \{\par
  background-image: no-repeat 50% 50%;\par
  height: 16px;\par
  position: absolute;\par
  right: 0;\par
  top: 0;\par
  width: 16px;\par
  z-index: 2;\par
\}\par
\par
.expandable-bubble[expanded] \{\par
  padding: 3px;\par
  z-index: 3;  /* One higher then the close button on an unexpanded bubble. */\par
\}\par
\par
.expandable-bubble[expanded] > .expandable-bubble-close \{\par
  z-index: 4;\par
\}\par
\par
.expandable-bubble-close \{\par
  background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAQAAAC1+jfqAAAAiElEQVR42r2RsQrDMAxEBRdl8SDcX8lQPGg1GBI6lvz/h7QyRRXV0qUULwfvwZ1tenw5PxToRPWMC52eA9+WDnlh3HFQ/xBQl86NFYJqeGflkiogrOvVlIFhqURFVho3x1moGAa3deMs+LS30CAhBN5nNxeT5hbJ1zwmji2k+aF6NENIPf/hs54f0sZFUVAMigAAAABJRU5ErkJggg==");\par
\}\par
\par
.expandable-bubble-close:hover \{\par
  background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAQAAAC1+jfqAAAAqklEQVR4XqWRMQ6DMAxF/1Fyilyj2SmIBUG5QcTCyJA5Z8jGhlBPgRi4TmoDraVmKFJlWYrlp/g5QfwRlwEVNWVa4WzfH9jK6kCkEkBjwxOhLghheMWMELUAqqwQ4OCbnE4LJnhr5IYdqQt4DJQjhe9u4vBBmnxHHNzRFkDGjHDo0VuTAqy2vAG4NkvXXDHxbGsIGlj3e835VFNtdugma/Jk0eXq0lP//5svi4PtO01oFfYAAAAASUVORK5CYII=");\par
\}\par
\par
.expandable-bubble-close:active \{\par
  background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAQAAAC1+jfqAAAARElEQVQoz2P4z4AfMlBLAYMdwxkghgEwD1XBGTC0g0sDIaYJECVwFqoChBK4WegKkJWArSJZAQErCDqSKG/iCyhaRhYA9LDIbULDzlIAAAAASUVORK5CYII=");\par
\}\par
</style>\par
<style>/* Copyright (c) 2012 The Chromium Authors. All rights reserved.\par
 * Use of this source code is governed by a BSD-style license that can be\par
 * found in the LICENSE file.\par
 */\par
\par
menu \{\par
  -webkit-box-shadow: 0 2px 4px rgba(0, 0, 0, .50);\par
  background: white;\par
  color: black;\par
  cursor: default;\par
  display: none;\par
  left: 0;\par
  margin: 0;\par
  outline: 1px solid rgba(0, 0, 0, 0.2);\par
  padding: 8px 0;\par
  position: fixed;\par
  white-space: nowrap;\par
  z-index: 3;\par
\}\par
\par
menu > * \{\par
  box-sizing: border-box;\par
  display: block;\par
  margin: 0;\par
  width: 100%;\par
  text-align: start;\par
\}\par
\par
menu > :not(hr) \{\par
  -webkit-appearance: none;\par
  background: transparent;\par
  border: 0;\par
  font: inherit;\par
  line-height: 18px;\par
  overflow: hidden;\par
  padding: 0 19px;\par
  text-overflow: ellipsis;\par
\}\par
\par
menu > hr \{\par
  background: -webkit-linear-gradient(left,\par
                                      rgba(0, 0, 0, .10),\par
                                      rgba(0, 0, 0, .02) 96%);\par
  border: 0;\par
  height: 1px;\par
  margin: 8px 0;\par
\}\par
\par
menu > [disabled] \{\par
  color: rgba(0, 0, 0, .3);\par
\}\par
\par
/* Text alpha doesn't work on Linux/GTK and ChromeOs/views.\par
 * TODO(estade): {{\field{\*\fldinst{HYPERLINK http://crbug.com/88688 }}{\fldrslt{http://crbug.com/88688\ul0\cf0}}}}\f0\fs22 . */\par
html[toolkit=gtk] menu > [disabled],\par
html[os=chromeos] menu > [disabled] \{\par
  color: #969696;\par
\}\par
\par
menu > [hidden] \{\par
  display: none;\par
\}\par
\par
menu > :not(hr)[selected] \{\par
  background-color: #dce5fa;\par
\}\par
\par
menu > :not(hr)[selected]:active \{\par
  background-color: #426dc9;\par
  color: #fff;\par
\}\par
\par
menu > [checked]:before \{\par
  content: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAkAAAAJCAYAAADgkQYQAAAARklEQVQYlWNgwA+MgViQkIJ3QKzEAFVpjEPBf5giJaiAMRYF72DWKSEJlKMpgNsgiCTxH5sCbG7AqgBZ4V2sCv7//08QAwAUfjKKBs+BFgAAAABJRU5ErkJggg==");\par
  display: inline-block;\par
  height: 9px;\par
  margin: 0 5px;\par
  vertical-align: 50%;\par
  width: 9px;\par
\}\par
\par
menu > [checked] \{\par
  -webkit-padding-start: 0;\par
\}\par
\par
menu > [selected][checked]:active:before \{\par
  content: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAkAAAAJCAYAAADgkQYQAAAATElEQVR42oXNyw0AIAgDUFdwBVZgOKd1BVeokNhgiJ9DL+WRFgCvqKX+wLBIcenFBYBIVqEHMDgnW9ECxCPneEAGRDGRQEaEnSCjbyYFHgnBSWvSHgAAAABJRU5ErkJggg==");\par
\}\par
</style>\par
<style>/* Copyright (c) 2012 The Chromium Authors. All rights reserved.\par
 * Use of this source code is governed by a BSD-style license that can be\par
 * found in the LICENSE file.\par
 */\par
\par
.trash \{\par
  cursor: pointer;\par
  display: inline-block;\par
  outline: none;\par
  position: relative;\par
  width: 30px;\par
\}\par
\par
.trash > span \{\par
  display: inline-block;\par
\}\par
\par
.trash > .can,\par
.trash > .lid \{\par
  background: url('chrome://resources/images/trash.png') 0 0 no-repeat;\par
  left: 8px;\par
  position: absolute;\par
  right: 8px;\par
  top: 2px;\par
\}\par
\par
.trash > .lid \{\par
  -webkit-transition: -webkit-transform 150ms;\par
  -webkit-transform-origin: -7% 100%;\par
  height: 6px;\par
  width: 14px;\par
\}\par
\par
html[dir='rtl'] .trash > .lid \{\par
  -webkit-transform-origin: 107% 100%;\par
\}\par
\par
.trash:focus > .lid,\par
.trash:hover > .lid \{\par
  -webkit-transition: -webkit-transform 250ms;\par
  -webkit-transform: rotate(-45deg);\par
\}\par
\par
html[dir='rtl'] .trash:focus > .lid,\par
html[dir='rtl'] .trash:hover > .lid \{\par
  -webkit-transform: rotate(45deg);\par
\}\par
\par
.trash > .can \{\par
  background-position: -1px -4px;\par
  height: 12px;\par
  /* The margins match the background position offsets. */\par
  margin-left: 1px;\par
  /* The right margin is one greater due to a shadow on the trash image. */\par
  margin-right: 2px;\par
  margin-top: 4px;\par
  width: 11px;\par
\}\par
</style>\par
<style>/* Copyright (c) 2012 The Chromium Authors. All rights reserved.\par
 * Use of this source code is governed by a BSD-style license that can be\par
 * found in the LICENSE file. */\par
\par
.app \{\par
  outline: none;\par
  position: absolute;\par
  text-align: center;\par
\}\par
\par
.app-contents \{\par
  -webkit-transition: -webkit-transform 100ms;\par
\}\par
\par
.app-contents:active:not(.suppress-active),\par
.app:not(.click-focus):focus .app-contents:not(.suppress-active),\par
.drag-representation:not(.placing) .app-contents \{\par
  -webkit-transform: scale(1.1);\par
\}\par
\par
/* Don't animate the initial scaling.  */\par
.app-contents:active:not(.suppress-active),\par
/* Active gets applied right before .suppress-active, so to avoid flicker\par
 * we need to make the scale go back to normal without an animation. */\par
.app-contents.suppress-active \{\par
  -webkit-transition-duration: 0;\par
\}\par
\par
.app-contents > span \{\par
  display: block;\par
  overflow: hidden;\par
  text-decoration: none;\par
  text-overflow: ellipsis;\par
  white-space: nowrap;\par
\}\par
\par
.app-img-container \{\par
  margin-left: auto;\par
  margin-right: auto;\par
  /* -webkit-mask-image set by JavaScript to the image source */\par
  -webkit-mask-size: 100% 100%;\par
\}\par
\par
.app-img-container > * \{\par
  height: 100%;\par
  width: 100%;\par
\}\par
\par
.app-icon-div \{\par
  background-color: white;\par
  border: 1px solid #d5d5d5;\par
  border-radius: 5px;\par
  display: -webkit-box;\par
  margin-left: auto;\par
  margin-right: auto;\par
  position: relative;\par
  vertical-align: middle;\par
  z-index: 0;\par
  -webkit-box-align: center;\par
  -webkit-box-pack: center;\par
\}\par
\par
.app-icon-div .app-img-container \{\par
  bottom: 10px;\par
  left: 10px;\par
  position: absolute;\par
\}\par
\par
.app-icon-div .color-stripe \{\par
  border-bottom-left-radius: 5px 5px;\par
  border-bottom-right-radius: 5px 5px;\par
  bottom: 0;\par
  height: 3px;\par
  opacity: 1.0;\par
  position: absolute;\par
  width: 100%;\par
  z-index: 100;\par
\}\par
\par
.app-context-menu > button:first-child \{\par
  font-weight: bold;\par
\}\par
\par
.app-context-menu \{\par
  z-index: 1000;\par
\}\par
\par
.launch-click-target \{\par
  cursor: pointer;\par
\}\par
\par
/* Notifications */\par
\par
.app-notification \{\par
  color: #999999;  \par
  display: block;\par
  font-size: 11px;\par
  white-space: nowrap;\par
  -webkit-transition: color 150ms linear;\par
\}\par
\par
.app-notification:hover \{\par
  text-decoration: underline;\par
\}\par
\par
/* Promo */\par
/* Show the promo if the webstore has a promo and is the only app on the page.\par
 */\par
.tile:only-of-type > .has-promo > .app-contents > span \{\par
  display: none;\par
\}\par
\par
.tile:only-of-type > .has-promo .app-img-container > .apps-promo-logo \{\par
  display: block;\par
\}\par
\par
.apps-promo-logo \{\par
  display: none;\par
  height: 128px;\par
  width: 128px;\par
\}\par
\par
.tile:only-of-type > .has-promo .app-img-container > img:first-child \{\par
  display: none;\par
\}\par
\par
.app-img-container > img:first-child \{\par
  display: block;\par
\}\par
\par
/* TODO(estade): animation? */\par
.tile:only-of-type > .has-promo > .apps-promo-extras \{\par
  display: block;\par
\}\par
\par
.apps-promo-extras \{\par
  display: none;\par
  /* 128 * 5/4 */\par
  left: 160px;\par
  position: absolute;\par
  text-align: left;\par
  top: 0;\par
\}\par
\par
html[dir="rtl"] .apps-promo-extras \{\par
  left: auto;\par
  right: 160px;\par
\}\par
\par
.apps-promo-heading \{\par
  font-weight: bold;\par
  margin-bottom: 5px;\par
  -webkit-margin-start: 3px;\par
\}\par
\par
.g-button-basic \{\par
  border-width: 6px 10px 12px 6px;\par
  color: #fff !important;\par
  display: inline-block;\par
  font-size: 1.3em;\par
  font-weight: bold;\par
  padding: 2px 10px;\par
  text-align: center;\par
  text-decoration: none;\par
  white-space: nowrap;\par
  -webkit-border-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAD4AAABHCAYAAABf7PRNAAAEzUlEQVR4Xu2YP4gkRRTGf9Xdszu79088BMVEAw+8UBMREzURQ3MDMRQEQ8FE0Fi4TDQ4wcRAMLtLTA4EUzVYFUUP1vPk7tyb3fnX3VXf0x0ezcDC9qQ1Ox981LzhVfDr1/2oesHMALj2zc/2+Y09/r4/IcnIX/yF2ReqR5+Obr67DxiAryzAr779tT1/5SovPPcE54ZD2hSIMixD/nkLR3Nj/96En379g99+/4X2cP+Zw2/fvw3IwVV9+OWPC+hXX3yaqggOYEiGhUBuMhl1I+q0zZOXH6E+epQ/2+k7wAdABBJAdf3mHm+98TqTuTg3LDr4oiiQRG5KEoczMT28x2x0l0uDSCiHbwIfAzXQAFaNJg3TxuAo0STYGQRmrTGrRY4aTcX9gynTgzvMxw8g1hDCZeCcpwhQBTCepf/N4gHsboXjdfFfm8hOR3MxHd2lnvxLamYYhus8kIAIxApgOo8MBpU/gEXMtCFLxWZKnI9JscEssaQdYAZUQFEBC8hdIlDhMZLIUUoJSZgSkrGkITAAyg68shrYBqBt4yKuVZKjTGJhMzAHJwBUOPSxC8/3RAHGmqpwd08BmZFixIIoTABgIk8JMMwM6xhKltWBm9F9F4HQvQEZyoEN3Es6CQ54IhAMWcge3N0PTggQus25g/f2qsqzceo1AHceoxf8JKR/H9mSr/qqd0ldYxMY+YLj7gPHhFQQQuGh5cvN6s0NKUEoSGlpu/JEXz610Q9uhEKkZLjIuORgvtgqzc0MJYFvMCnvikuATgd3EXzUJBOG5f2N91f8pEwp+67u6+ngwYQkCCUAIesDjNz9XR3MkARW4DGW+QEGVunqXnVTwmPIGtxXOB08GQwwLCU8PiO3MzMIYXn32biPB8nHb+Bxxic3W2pu6qm4EljArMDjjL9xrd7cTAkTmEq6mJDvqw6rTmAEhlfcYwXylEDC1Qce3C5C7ncUzOip+EllP2XtJjB9FZeEFJCJACj/ru7uv48j+QaP12quHvpfdZIAyBy8W1cHlzzI/pJC/8ktCQoZMlwh74qz4pE1CkoZ0np09e7IivrO6hEoSKoIAIpgyv/ISk/FSyKEEsl8b5v1XB1stQNMsAQGKAGgmDCFbKesyMAE0N/cQjSK0AIgy3uubu6eintSMkIV85+rm47tEPSA+wRmWcZZGD11WoJf+ylrj9Z3rr5+5O7TO3TBWdMGPFdtwDfgG/AN+AZ8A74BrwBSEkWAVAYAlIRJ6w9e1y11A/O6QIIYa0yJHJWaCbGdIyVMfVPW+ggpUi+SW5SabK+lqZ0tbClinA7e1NODLYs1SsduMUvgw4nspISZcGGhAEvzk+BK303a+ctVM8IUfdP6qB3soPloD7AlU6kdf3Y4uPjyhfohpRLrpFRuMd55nPb2rRtABBIOH4DdS69de6/cvvhRmWaUqVkb6FTu0Pzzw/Xx9598BRwAD4ARMAnAENipLl95bPupV14Kw0vPkpptUxxgKoGQJfjh/p3m9q09zQ9GwNiBHwJHwCwAW8A2sAtcAM777yEwAEKG8OZugTkwdeCx/64rQHiCAyag9gdSAkWm4HKWxtlmvrZAqpYTfEP0hAoo3GQEb77KHR22waEBqwDDg6XE0h0yf9WdbdkIsP8ABZhTTDj3evgAAAAASUVORK5CYII=") 6 10 12 6;\par
\}\par
\par
.app .invisible \{\par
  visibility: hidden;\par
\}\par
</style>\par
<style>/* Copyright (c) 2012 The Chromium Authors. All rights reserved.\par
 * Use of this source code is governed by a BSD-style license that can be\par
 * found in the LICENSE file.\par
 */\par
\par
.most-visited \{\par
  position: absolute;\par
  z-index: 0;\par
\}\par
\par
.most-visited \{\par
  display: -webkit-box;\par
  position: absolute;\par
  text-decoration: none;\par
  -webkit-box-orient: vertical;\par
\}\par
\par
.most-visited:focus \{\par
  outline: none;\par
\}\par
\par
.fills-parent \{\par
  bottom: 0;\par
  display: -webkit-box;\par
  left: 0;\par
  position: absolute;\par
  right: 0;\par
  top: 0;\par
\}\par
\par
/* filler mode: hide everything except the thumbnail --- leave a grey rectangle\par
 * in its place. */\par
.filler * \{\par
  visibility: hidden;\par
\}\par
\par
.filler \{\par
  pointer-events: none;\par
\}\par
\par
.most-visited .close-button \{\par
  opacity: 0;\par
  position: absolute;\par
  right: 0;\par
  top: 0;\par
  z-index: 5;\par
  -webkit-transition: opacity 150ms;\par
\}\par
\par
html[dir=rtl] .most-visited .close-button \{\par
  left: 0;\par
  right: auto;\par
\}\par
\par
.most-visited:hover .close-button \{\par
  opacity: 1;\par
  -webkit-transition-delay: 500ms;\par
\}\par
\par
.most-visited .close-button:hover \{\par
  -webkit-transition: none;\par
\}\par
\par
.most-visited .favicon \{\par
  -webkit-margin-start: 5px;\par
  background: no-repeat left 50%;\par
  bottom: 7px;\par
  box-sizing: border-box;\par
  display: block;\par
  height: 16px;\par
  position: absolute;\par
  width: 16px;\par
\}\par
\par
html[dir='rtl'] .most-visited .favicon \{\par
  background-position-x: right;\par
\}\par
\par
.most-visited .color-stripe \{\par
  border-bottom-left-radius: 3px 3px;\par
  border-bottom-right-radius: 3px 3px;\par
  /* Matches height of title.  */\par
  bottom: 23px;\par
  height: 3px;\par
  /* Matches padding-top of the title. */\par
  margin-bottom: 8px;\par
  position: absolute;\par
  width: 100%;\par
  z-index: 10;\par
\}\par
\par
.most-visited .title \{\par
  display: block;\par
  height: 23px;\par
  overflow: hidden;\par
  padding-top: 8px;\par
  text-align: center;\par
  text-overflow: ellipsis;\par
  white-space: nowrap;\par
\}\par
\par
.thumbnail \{\par
  background: no-repeat;\par
  /* This shows for missing thumbnails. */\par
  background-color: #eee;\par
  background-size: 100%;\par
  border-radius: 3px;\par
  /* These max dimensions are not necessary, as the sizing logic in the .js\par
   * should be sufficient, but they're here for extra insurance. We never want\par
   * to scale a thumbnail larger than this size. */\par
  max-height: 132px;\par
  max-width: 212px;\par
  -webkit-transition: opacity 150ms;\par
\}\par
\par
.filler .thumbnail \{\par
  /* TODO(estade): there seems to be a webkit bug where this border is not\par
   * always removed when it should be. Investigate. */\par
  border: 1px solid;\par
  visibility: visible;\par
\}\par
\par
.thumbnail-shield \{\par
  border-radius: 3px;\par
  background: -webkit-linear-gradient(rgba(255, 255, 255, 0),\par
                                      rgba(255, 255, 255, 0) 50%,\par
                                      rgba(255, 255, 255, 0.9));\par
\}\par
\par
/* TODO(dbeam): Remove this when printing of -webkit-linear-gradient() works. */\par
@media print \{\par
  .thumbnail-shield \{\par
    background: none;\par
  \}\par
\}\par
\par
.most-visited:focus .thumbnail,\par
.most-visited:hover .thumbnail \{\par
  opacity: 0.95;\par
\}\par
\par
.most-visited:focus .thumbnail-shield,\par
.most-visited:hover .thumbnail-shield,\par
.most-visited:active .thumbnail-shield \{\par
  background: -webkit-linear-gradient(rgba(255, 255, 255, 0),\par
                                      rgba(255, 255, 255, 0) 80%,\par
                                      rgba(255, 255, 255, 0.9));\par
\}\par
\par
/* The thumbnail gets lighter when clicked, but not when the click is on the\par
 * close button. */\par
.most-visited:active .close-button:not(:active) + .thumbnail \{\par
  opacity: 0.9;\par
\}\par
\par
/* The thumbnail gets a shadow when clicked, but not when the click is on the\par
 * close button. */\par
.most-visited:active .close-button:not(:active) + .thumbnail .thumbnail-shield \{\par
  -webkit-box-shadow: inset 0 1px 10px rgba(0, 0, 0, 0.2);\par
\}\par
\par
.thumbnail-wrapper \{\par
  border: 1px solid transparent;\par
  border-radius: 3px;\par
  display: block;\par
  position: relative;\par
  z-index: 5;\par
  -webkit-box-flex: 1;\par
  -webkit-transition: background-color 150ms;\par
\}\par
\par
.filler .thumbnail-wrapper \{\par
  visibility: visible;\par
\}\par
\par
/* 'finishing-drag' is the state we are in after dropping on the trash can.\par
 * Override opacity of the tile to 1, so that the new tile animation\par
 * occurs simultaneously with the trash animation. */\par
.tile.dragging.finishing-drag \{\par
  opacity: 1;\par
\}\par
\par
/* Don't display the new tile until there's something to show.  */\par
.blacklisted \{\par
  opacity: 0;\par
\}\par
</style>\par
<style>/* Copyright (c) 2012 The Chromium Authors. All rights reserved.\par
 * Use of this source code is governed by a BSD-style license that can be\par
 * found in the LICENSE file.\par
 */\par
\par
/* TODO(estade): handle overflow better? I tried overflow-x: hidden and\par
   overflow-y: visible (for the new dot animation), but this makes a scroll\par
   bar appear */\par
#dot-list \{\par
  display: -webkit-box;\par
  height: 100%;\par
  list-style-type: none;\par
  margin: 0;\par
  padding: 0;\par
  /* Expand to take up all available horizontal space.  */\par
  -webkit-box-flex: 1;\par
  /* Center child dots. */\par
  -webkit-box-pack: center;\par
\}\par
\par
html.starting-up #dot-list \{\par
  display: none;\par
\}\par
\par
.dot \{\par
  box-sizing: border-box;\par
  cursor: pointer;\par
  /* max-width: Set in new_tab.js. See measureNavDots() */\par
  outline: none;\par
  text-align: left;\par
  -webkit-box-flex: 1;\par
  -webkit-margin-end: 10px;\par
  -webkit-padding-start: 2px;\par
  -webkit-transition: max-width 250ms, -webkit-margin-end 250ms;\par
\}\par
\par
.dot:last-child \{\par
  -webkit-margin-end: 0;\par
\}\par
\par
.dot.small \{\par
  max-width: 0;\par
  -webkit-margin-end: 0;\par
\}\par
\par
.dot .selection-bar \{\par
  border-bottom: 5px solid;\par
  border-color: rgba(0, 0, 0, 0.1);\par
  height: 10px;\par
  -webkit-transition: border-color 200ms;\par
\}\par
\par
.dot input \{\par
  background-color: transparent;\par
  cursor: inherit;\par
  /* TODO(estade): the font needs tweaking. */\par
  font-size: 8pt;\par
  font-weight: bold;\par
  padding-top: 0;\par
  width: 90%;\par
  -webkit-appearance: caret;\par
  -webkit-transition: color 200ms;\par
\}\par
\par
.dot input:focus \{\par
  cursor: auto;\par
\}\par
\par
/* Everything below here should be themed but we don't have appropriate colors\par
 * yet.\par
 */\par
.dot input \{\par
  color: #b2b2b2;\par
\}\par
\par
.dot:focus input, .dot:hover input, .dot.selected input \{\par
  color: #7f7f7f;\par
\}\par
\par
.dot:focus .selection-bar,\par
.dot:hover .selection-bar,\par
.dot.drag-target .selection-bar \{\par
  border-color: #b2b2b2;\par
\}\par
\par
.dot.selected .selection-bar \{\par
  border-color: #7f7f7f;\par
\}\par
</style>\par
<style>/* Copyright (c) 2012 The Chromium Authors. All rights reserved.\par
 * Use of this source code is governed by a BSD-style license that can be\par
 * found in the LICENSE file.\par
 */\par
\par
html \{\par
  font-family: segoe ui, arial, helvetica, sans-serif;\par
  font-size: 14px;\par
  /* It's necessary to put this here instead of in body in order to get the\par
     background-size of 100% to work properly */\par
  height: 100%;\par
  overflow: hidden;\par
\}\par
\par
body \{\par
  /* Don't highlight links when they're tapped.  Safari has bugs here that\par
     show up as flicker when dragging in some situations */\par
  -webkit-tap-highlight-color: transparent;\par
  /* Don't allow selecting text - can occur when dragging */\par
  -webkit-user-select: none;\par
  background-size: auto 100%;\par
  margin: 0;\par
\}\par
\par
/* [hidden] does display:none, but its priority is too low in some cases. */\par
[hidden] \{\par
  display: none !important;\par
\}\par
\par
#notification-container \{\par
  -webkit-transition-duration: 100ms;\par
  -webkit-transition-property: opacity;\par
  display: block;\par
  margin-top: 2px;\par
  position: relative;\par
  text-align: center;\par
  z-index: 15;\par
\}\par
\par
#notification-container.inactive \{\par
  -webkit-transition-duration: 200ms;\par
  opacity: 0;\par
\}\par
\par
#notification \{\par
  background-color: #FFF199;\par
  border: 1px solid lightGrey;\par
  border-radius: 6px;\par
  color: black;\par
  display: inline-block;\par
  font-weight: bold;\par
  padding: 7px 15px;\par
\}\par
\par
#notification > div > div,\par
#notification > div \{\par
  display: inline-block;\par
\}\par
\par
#notification .close-button \{\par
  -webkit-margin-start: 0.5em;\par
  vertical-align: middle;\par
\}\par
\par
.close-button \{\par
  background: no-repeat;\par
  background-color: transparent;\par
  /* TODO(estade): this should animate between states. */\par
  background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAQAAAC1+jfqAAAAiElEQVR42r2RsQrDMAxEBRdl8SDcX8lQPGg1GBI6lvz/h7QyRRXV0qUULwfvwZ1tenw5PxToRPWMC52eA9+WDnlh3HFQ/xBQl86NFYJqeGflkiogrOvVlIFhqURFVho3x1moGAa3deMs+LS30CAhBN5nNxeT5hbJ1zwmji2k+aF6NENIPf/hs54f0sZFUVAMigAAAABJRU5ErkJggg==");\par
  border: 0;\par
  cursor: default;\par
  display: inline-block;\par
  height: 16px;\par
  padding: 0;\par
  width: 16px;\par
\}\par
\par
.close-button:hover,\par
.close-button:focus \{\par
  background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAQAAAC1+jfqAAAAqklEQVR4XqWRMQ6DMAxF/1Fyilyj2SmIBUG5QcTCyJA5Z8jGhlBPgRi4TmoDraVmKFJlWYrlp/g5QfwRlwEVNWVa4WzfH9jK6kCkEkBjwxOhLghheMWMELUAqqwQ4OCbnE4LJnhr5IYdqQt4DJQjhe9u4vBBmnxHHNzRFkDGjHDo0VuTAqy2vAG4NkvXXDHxbGsIGlj3e835VFNtdugma/Jk0eXq0lP//5svi4PtO01oFfYAAAAASUVORK5CYII=");\par
\}\par
\par
.close-button:active \{\par
  background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAQAAAC1+jfqAAAARElEQVQoz2P4z4AfMlBLAYMdwxkghgEwD1XBGTC0g0sDIaYJECVwFqoChBK4WegKkJWArSJZAQErCDqSKG/iCyhaRhYA9LDIbULDzlIAAAAASUVORK5CYII=");\par
\}\par
\par
.linkButton \{\par
  -webkit-margin-start: 0.5em;\par
  color: #06C;\par
  cursor: pointer;\par
  display: inline-block;\par
  text-decoration: underline;\par
\}\par
\par
#card-slider-frame \{\par
  /* Must match #footer height. */\par
  bottom: 50px;\par
  overflow: hidden;\par
  /* We want this to fill the window except for the region used\par
     by footer */\par
  position: fixed;\par
  top: 0;\par
  width: 100%;\par
\}\par
\par
#page-list \{\par
  /* fill the apps-frame */\par
  height: 100%;\par
  display: -webkit-box;\par
\}\par
\par
#attribution \{\par
  bottom: 0;\par
  left: auto;\par
  margin-left: 8px;\par
  /* Leave room for the scrollbar. */\par
  margin-right: 13px;\par
  position: absolute;\par
  right: 0;\par
  text-align: left;\par
  z-index: -5;\par
\}\par
\par
/* For themes that right-align their images, we flip the attribution to the\par
 * left to avoid conflicts.  */\par
html[themegravity='right'] #attribution,\par
html[dir='rtl'] #attribution \{\par
  left: 0;\par
  right: auto;\par
  text-align: right;\par
\}\par
\par
#attribution > span \{\par
  display: block;\par
  font-size: 84%;\par
\}\par
\par
#footer \{\par
  background-image: -webkit-linear-gradient(\par
      rgba(242, 242, 242, 0.9), rgba(222, 222, 222, 0.9));\par
  bottom: 0;\par
  position: fixed;\par
  width: 100%;\par
  z-index: 5;\par
\}\par
\par
/* TODO(estade): remove this border hack and replace with a webkit-gradient\par
 * border-image on #footer once WebKit supports border-image-slice.\par
 * See {{\field{\*\fldinst{HYPERLINK https://bugs.webkit.org/show_bug.cgi?id=20127 }}{\fldrslt{https://bugs.webkit.org/show_bug.cgi?id=20127\ul0\cf0}}}}\f0\fs22  */\par
#footer-border \{\par
  height: 1px;\par
\}\par
\par
#footer-content \{\par
  -webkit-box-align: center;\par
  display: -webkit-box;\par
  height: 49px;\par
\}\par
\par
#footer-content > * \{\par
  margin: 0 9px;\par
\}\par
\par
#logo-img \{\par
  margin-top: 4px;\par
\}\par
\par
.starting-up * \{\par
  -webkit-transition: none !important;\par
\}\par
\par
/* Login Status. **************************************************************/\par
\par
#login-container \{\par
  -webkit-box-shadow: none;\par
  background: transparent none;\par
  border: none;\par
  cursor: pointer;\par
  font-size: 13px;\par
  /* Leave room for the scrollbar. */\par
  margin-left: 13px;\par
  margin-right: 13px;\par
  margin-top: 5px;\par
  padding: 0;\par
  position: fixed;\par
  right: 0;\par
  text-align: right;\par
  top: 0;\par
  z-index: 10;\par
\}\par
\par
html[dir='rtl'] #login-container \{\par
  left: 0;\par
  right: auto;\par
\}\par
\par
.login-status-icon \{\par
  -webkit-padding-end: 37px;\par
  background-position: right center;\par
  background-repeat: no-repeat;\par
  min-height: 27px;\par
\}\par
\par
html[dir='rtl'] .login-status-icon \{\par
  background-position-x: left;\par
\}\par
\par
.profile-name:hover \{\par
  text-decoration: underline;\par
\}\par
\par
.link-span \{\par
  text-decoration: underline;\par
\}\par
\par
#login-status-bubble-contents \{\par
  font-size: 13px;\par
\}\par
\par
#login-status-message-container \{\par
  margin-bottom: 13px;\par
\}\par
\par
#login-status-learn-more \{\par
  display: inline-block;\par
\}\par
\par
.login-status-row \{\par
  -webkit-box-align: center;\par
  -webkit-box-orient: horizontal;\par
  -webkit-box-pack: end;\par
  display: -webkit-box;\par
\}\par
\par
#login-status-advanced-container \{\par
  -webkit-box-flex: 1;\par
\}\par
\par
#login-status-dismiss \{\par
  min-width: 6em;\par
\}\par
\par
/* Trash. *********************************************************************/\par
\par
#trash \{\par
  -webkit-transition: top 200ms, opacity 0;\par
  -webkit-transition-delay: 0, 200ms;\par
  color: #222;\par
  height: 100%;\par
  position: absolute;\par
  opacity: 0;\par
  right: 0;\par
  top: 50px;\par
  width: auto;\par
\}\par
\par
html[dir='rtl'] #trash \{\par
  left: 0;\par
  right: auto;\par
\}\par
\par
#footer.showing-trash-mode #trash \{\par
  -webkit-transition-delay: 0, 0;\par
  -webkit-transition-duration: 0, 200ms;\par
  opacity: 0.75;\par
  top: 0;\par
\}\par
\par
#footer.showing-trash-mode #trash.drag-target \{\par
  opacity: 1;\par
\}\par
\par
#trash > .trash-text \{\par
  -webkit-padding-end: 7px;\par
  -webkit-padding-start: 30px;\par
  border: 1px dashed #7f7f7f;\par
  border-radius: 4px;\par
  display: inline-block;\par
  font-size: 84%;\par
  padding-bottom: 9px;\par
  padding-top: 10px;\par
  position: relative;\par
  top: 7px;\par
\}\par
\par
#trash > .lid,\par
#trash > .can \{\par
  top: 18px;\par
\}\par
\par
#footer.showing-trash-mode #trash.drag-target .lid \{\par
  -webkit-transform: rotate(-45deg);\par
\}\par
\par
html[dir='rtl'] #footer.showing-trash-mode #trash.drag-target .lid \{\par
  -webkit-transform: rotate(45deg);\par
\}\par
\par
#fontMeasuringDiv \{\par
  /* The font attributes match the nav inputs. */\par
  font-size: 8pt;\par
  font-weight: bold;\par
  pointer-events: none;\par
  position: absolute;\par
  visibility: hidden;\par
\}\par
\par
/* Page switcher buttons. *****************************************************/\par
\par
.page-switcher \{\par
  -webkit-transition: width 150ms, right 150ms, background-color 150ms;\par
  background-color: transparent;\par
  border: none;\par
  bottom: 0;\par
  font-size: 40px;\par
  padding: 0;\par
  position: absolute;\par
  margin: 0;\par
  max-width: 150px;\par
  min-width: 90px;\par
  outline: none;\par
  top: 0;\par
  z-index: 5;\par
\}\par
\par
#chrome-web-store-href \{\par
  -webkit-padding-end: 12px;\par
  /* Match transition delay of recently closed button. */\par
  -webkit-transition-delay: 100ms;\par
  color: #7F7F7F;\par
  cursor: pointer;\par
  display: none;\par
  margin: 0;\par
  text-decoration: none;\par
\}\par
\par
#chrome-web-store-title \{\par
  -webkit-padding-end: 26px;\par
  -webkit-padding-start: 16px;\par
  background: url('chrome://theme/IDR_WEBSTORE_ICON_24') right 50% no-repeat;\par
  display: inline-block;\par
  font-weight: bold;\par
  font-size: 9pt;\par
  line-height: 49px;\par
\}\par
\par
#chrome-web-store-href:hover \{\par
  color: #666;\par
\}\par
\par
html[dir='rtl'] #chrome-web-store-title \{\par
  background-position-x: left;\par
\}\par
\par
/* Show the chrome-web-store button when the experiment is turned on. */\par
.enable-cws-experiment #chrome-web-store-href \{\par
  display: inline-block;\par
\}\par
\par
/* Reserve space for the menu button even when it's hidden. */\par
#footer.showing-trash-mode #chrome-web-store-href \{\par
  visibility: hidden;\par
\}\par
\par
#footer.showing-trash-mode #chrome-web-store-href \{\par
  -webkit-transition-delay: 0;\par
  opacity: 0;\par
\}\par
</style>\par
<style>/* Copyright (c) 2012 The Chromium Authors. All rights reserved.\par
 * Use of this source code is governed by a BSD-style license that can be\par
 * found in the LICENSE file. */\par
\par
#recently-closed-menu-button \{\par
  -webkit-appearance: none;\par
  -webkit-padding-end: 15px;\par
  -webkit-padding-start: 9px;\par
  -webkit-transition: opacity 200ms;\par
  -webkit-transition-delay: 100ms;\par
  background: none;\par
  border: 0;\par
  color: #7F7F7F;\par
  cursor: pointer;\par
  display: block;\par
  margin: 0;\par
  font-size: 9pt;\par
  font-weight: bold;\par
  height: 100%;\par
  /* The padding increases the clickable area. */\par
  padding-bottom: 0;\par
  padding-top: 0;\par
\}\par
\par
.enable-cws-experiment #recently-closed-menu-button \{\par
  position: relative;\par
  -webkit-margin-end: 0;\par
  -webkit-padding-end: 16px;\par
\}\par
\par
#recently-closed-menu-button:hover:not([menu-shown]) \{\par
  color: #666;\par
\}\par
\par
#recently-closed-menu-button:hover:not([menu-shown]) .disclosure-triangle \{\par
  background-color: #666;\par
\}\par
\par
#recently-closed-menu-button[menu-shown] \{\par
  color: #555;\par
\}\par
\par
#recently-closed-menu-button[menu-shown] .disclosure-triangle \{\par
  background-color: #555;\par
\}\par
\par
/* Reserve space for the menu button even when it's hidden. */\par
#recently-closed-menu-button.invisible,\par
#footer.showing-trash-mode #recently-closed-menu-button \{\par
  visibility: hidden;\par
\}\par
\par
#footer.showing-trash-mode #recently-closed-menu-button \{\par
  opacity: 0;\par
  -webkit-transition-delay: 0;\par
\}\par
\par
#recently-closed-menu-button > * \{\par
  vertical-align: middle;\par
\}\par
\par
.recent-menu \{\par
  padding: 6px 8px;\par
  /* Needs to be above #footer. */\par
  z-index: 10;\par
\}\par
\par
.recent-menu-item \{\par
  background: no-repeat 0 50%;\par
  background-color: transparent !important;\par
  background-size: 16px 16px;\par
  box-sizing: border-box;\par
  display: block;\par
  font-size: 100%;\par
  line-height: 20px;\par
  margin: 8px;\par
  max-width: 450px;\par
  overflow: hidden;\par
  text-overflow: ellipsis;\par
  white-space: nowrap;\par
  -webkit-margin-start: 0;\par
  -webkit-padding-end: 0;\par
  -webkit-padding-start: 22px;\par
\}\par
\par
.recent-menu-item:not(:hover) \{\par
  text-decoration: none;\par
\}\par
\par
.recent-menu-item:first-of-type \{\par
  margin-top: 4px;\par
\}\par
\par
.recent-menu-item:last-of-type \{\par
  margin-bottom: 4px;\par
\}\par
\par
html[dir='rtl'] .recent-menu-item \{\par
  background: no-repeat 100% 50%;\par
\}\par
\par
.recent-window \{\par
  background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAA0UlEQVR42s2OSwsBYRSGz1+Uv6CQyTUsLFzKlFtmMWUQvkSJxIgfYGVrZWFjr9jY2L3mzJSUoo6NxdPbWTxPhwCQWq+gNisMmDWv7a5yVvHtYrsoZuPBLvXsOfzWVURvOQdZ0wna2xt2++OT5uIAX+vyFWs2AZnjoSudzvdXOPL1A3M0BBn9jie9w+GPGP0uqNYyPUFA1XFJNxrigG7UQYWKLg4UK2VQrpQXB9j9g0A2lxUHMo5LqUxCHEilk6BYXBMHoo5LES0oDrBL4VAAv/AAQoVZHAc9DoAAAAAASUVORK5CYII=");\par
\}\par
\par
/* TODO(estade): find a better color for active. */\par
.recent-menu-item:active,\par
.recent-menu-item:visited,\par
.recent-menu-item:link \{\par
  color: hsl(213, 90%, 24%) !important;\par
\}\par
\par
.disclosure-triangle \{\par
  background-color: #7F7F7F;\par
  display: inline-block;\par
  height: 9px;\par
  width: 9px;\par
  -webkit-margin-start: 2px;\par
  -webkit-mask-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAkAAAAJCAYAAADgkQYQAAAAJUlEQVQYV2NgoDuYSQSGK/RB0+yDrACbQqwKkBUW41OArJB0AAACXws0ERupuAAAAABJRU5ErkJggg==");\par
\}\par
\par
#vertical-separator \{\par
  background-color: #B2B2B2;\par
  display: none;\par
  height: 20px;\par
  left: 15px;\par
  position: relative;\par
  right: 15px;\par
  width: 1px;\par
\}\par
\par
.enable-cws-experiment #vertical-separator \{\par
  display: inline-block;\par
\}\par
</style>\par
<style>/* Copyright (c) 2011 The Chromium Authors. All rights reserved.\par
 * Use of this source code is governed by a BSD-style license that can be\par
 * found in the LICENSE file.\par
 */\par
\par
.tile-page \{\par
  display: -webkit-box;\par
  height: 100%;\par
  position: relative;\par
  width: 100%;\par
  -webkit-box-orient: vertical;\par
\}\par
\par
.tile-page-scrollbar \{\par
  margin: 0 4px;\par
  pointer-events: none;\par
  position: absolute;\par
  right: 0;\par
  width: 5px;\par
  z-index: 5;\par
  -webkit-box-sizing: border-box;\par
\}\par
\par
.tile-page-content \{\par
  overflow-y: scroll;\par
  /* This value is mirrored in TilePage.updateTopMargin_ */\par
  padding-top: 60px;\par
  position: relative;\par
  text-align: center;\par
  width: 100%;\par
  /* TODO(estade): this mask is disabled for technical reasons. It negatively\par
   * impacts performance of page switching, also it causes problems with Mac\par
   * text: {{\field{\*\fldinst{HYPERLINK http://crbug.com/86955 }}{\fldrslt{http://crbug.com/86955\ul0\cf0}}}}\f0\fs22\par
  -webkit-mask-image: -webkit-linear-gradient(bottom, transparent, black 30px);\par
  */\par
  /* The following four properties are necessary so that the mask won't clip\par
   * the scrollbar. */\par
  box-sizing: border-box;\par
  /* Scrollbar width(13px) + balance right padding.  */\par
  padding-left: 93px;\par
  padding-right: 80px;\par
  -webkit-box-flex: 1;\par
  /* Don't apply clip mask to padding. */\par
  -webkit-mask-clip: content-box;\par
\}\par
\par
.tile-grid \{\par
  position: relative;\par
  width: 100%;\par
\}\par
\par
.tile \{\par
  display: inline-block;\par
  position: absolute;\par
  -webkit-print-color-adjust: exact;\par
  /* Don't offer the context menu on long-press. */\par
  -webkit-touch-callout: none;\par
  -webkit-user-drag: element;\par
\}\par
\par
/* I don't know why this is necessary. -webkit-user-drag: element on .tile\par
 * should be enough. If we don't do this, we get 2 drag representations for\par
 * the image. */\par
.tile img \{\par
  -webkit-user-drag: none;\par
\}\par
\par
.doppleganger \{\par
  left: 0 !important;\par
  right: 0 !important;\par
  top: 0 !important;\par
\}\par
\par
.tile.dragging \{\par
  opacity: 0;\par
\}\par
\par
.tile.drag-representation \{\par
  pointer-events: none;\par
  position: fixed;\par
  z-index: 3;\par
  -webkit-transition: opacity 200ms;\par
\}\par
\par
.tile.drag-representation.placing > * \{\par
  -webkit-transition: -webkit-transform 200ms;\par
\}\par
\par
/* When a drag finishes while we're not showing the page where the tile\par
 * belongs, the tile shrinks to a dot. */\par
.tile.drag-representation.dropped-on-other-page > * \{\par
   -webkit-transform: scale(0) rotate(0);\par
\}\par
\par
.tile.drag-representation.deleting > * \{\par
  -webkit-transform: scale(0) rotate(360deg);\par
  -webkit-transition: -webkit-transform 600ms;\par
\}\par
\par
.animating-tile-page .tile,\par
.tile.drag-representation.placing \{\par
  -webkit-transition: left 200ms, right 200ms, top 200ms;\par
\}\par
\par
.hovering-on-trash \{\par
  opacity: 0.6;\par
\}\par
\par
.animating-tile-page .top-margin \{\par
  -webkit-transition: margin-bottom 200ms;\par
\}\par
\par
@-webkit-keyframes bounce \{\par
  0% \{\par
    -webkit-transform: scale(0, 0);\par
  \}\par
\par
  60% \{\par
    -webkit-transform: scale(1.2, 1.2);\par
  \}\par
\par
  100% \{\par
    -webkit-transform: scale(1, 1);\par
  \}\par
\}\par
\par
.tile > .new-tile-contents \{\par
  -webkit-animation: bounce 500ms ease-in-out;\par
\}\par
\par
@-webkit-keyframes blipout \{\par
  0% \{\par
    -webkit-transform: scale(1, 1);\par
  \}\par
\par
  60% \{\par
    opacity: 1;\par
    -webkit-animation-timing-function: ease-in;\par
    -webkit-transform: scale(1.3, 0.02);\par
  \}\par
\par
  90% \{\par
    opacity: 0.7;\par
    -webkit-animation-timing-function: default;\par
    -webkit-transform: scale(0.3, 0.02);\par
  \}\par
\par
  100% \{\par
    opacity: 0;\par
    -webkit-animation-timing-function: linear;\par
    -webkit-transform: scale(0.3, 0.02);\par
  \}\par
\}\par
\par
.tile > .removing-tile-contents \{\par
  pointer-events: none;\par
  -webkit-animation: blipout 300ms;\par
\}\par
\par
.tile-page:not(.selected-card) * \{\par
  -webkit-transition: none !important;\par
\}\par
\par
/** Scrollbars ****************************************************************/\par
\par
.tile-page-content::-webkit-scrollbar \{\par
  width: 13px;\par
\}\par
\par
.tile-page-content::-webkit-scrollbar-button \{\par
  display: none;\par
\}\par
</style>\par
<link id="themecss" rel="stylesheet" href="chrome://theme/css/newtab.css?1455578975327">\par
\par
<script>// Copyright (c) 2011 The Chromium Authors. All rights reserved.\par
// Use of this source code is governed by a BSD-style license that can be\par
// found in the LICENSE file.\par
\par
/** @fileoverview EventTracker is a simple class that manages the addition and\par
 *  removal of DOM event listeners. In particular, it keeps track of all\par
 *  listeners that have been added and makes it easy to remove some or all of\par
 *  them without requiring all the information again. This is particularly\par
 *  handy when the listener is a generated function such as a lambda or the\par
 *  result of calling Function.bind.\par
 */\par
\par
// Use an anonymous function to enable strict mode just for this file (which\par
// will be concatenated with other files when embedded in Chrome)\par
var EventTracker = (function() \{\par
  'use strict';\par
\par
  /**\par
   *  Create an EventTracker to track a set of events.\par
   *  EventTracker instances are typically tied 1:1 with other objects or\par
   *  DOM elements whose listeners should be removed when the object is disposed\par
   *  or the corresponding elements are removed from the DOM.\par
   *  @constructor\par
   */\par
  function EventTracker() \{\par
    /**\par
     *  @type \{Array.<EventTracker.Entry>\}\par
     *  @private\par
     */\par
    this.listeners_ = [];\par
  \}\par
\par
  /**\par
   * The type of the internal tracking entry.\par
   *  @typedef \{\{node: !Node,\par
   *            eventType: string,\par
   *            listener: Function,\par
   *            capture: boolean\}\}\par
   */\par
  EventTracker.Entry;\par
\par
  EventTracker.prototype = \{\par
    /**\par
     * Add an event listener - replacement for Node.addEventListener.\par
     * @param \{!Node\} node The DOM node to add a listener to.\par
     * @param \{string\} eventType The type of event to subscribe to.\par
     * @param \{Function\} listener The listener to add.\par
     * @param \{boolean\} capture Whether to invoke during the capture phase.\par
     */\par
    add: function(node, eventType, listener, capture) \{\par
      var h = \{\par
        node: node,\par
        eventType: eventType,\par
        listener: listener,\par
        capture: capture\par
      \};\par
      this.listeners_.push(h);\par
      node.addEventListener(eventType, listener, capture);\par
    \},\par
\par
    /**\par
     * Remove any specified event listeners added with this EventTracker.\par
     * @param \{!Node\} node The DOM node to remove a listener from.\par
     * @param \{?string\} eventType The type of event to remove.\par
     */\par
    remove: function(node, eventType) \{\par
      this.listeners_ = this.listeners_.filter(function(h) \{\par
        if (h.node == node && (!eventType || (h.eventType == eventType))) \{\par
          EventTracker.removeEventListener_(h);\par
          return false;\par
        \}\par
        return true;\par
      \});\par
    \},\par
\par
    /**\par
     * Remove all event listeners added with this EventTracker.\par
     */\par
    removeAll: function() \{\par
      this.listeners_.forEach(EventTracker.removeEventListener_);\par
      this.listeners_ = [];\par
    \}\par
  \};\par
\par
  /**\par
   * Remove a single event listener given it's tracker entry.  It's up to the\par
   * caller to ensure the entry is removed from listeners_.\par
   * @param \{EventTracker.Entry\} h The entry describing the listener to remove.\par
   * @private\par
   */\par
  EventTracker.removeEventListener_ = function(h) \{\par
    h.node.removeEventListener(h.eventType, h.listener, h.capture);\par
  \};\par
\par
  return EventTracker;\par
\})();\par
\par
</script>\par
<script>// Copyright (c) 2011 The Chromium Authors. All rights reserved.\par
// Use of this source code is governed by a BSD-style license that can be\par
// found in the LICENSE file.\par
\par
// TODO(arv): Namespace\par
\par
/**\par
 * The local strings get injected into the page using a variable named\par
 * \{@code templateData\}. This class provides a simpler interface to access those\par
 * strings.\par
 *\par
 * @param \{Object\} opt_templateData Optional object containing translated\par
 *     strings.  If this is not supplied during construction, it can be\par
 *     assigned to the templateData property after construction.  If all else\par
 *     fails, the value of window.templateDate will be used.\par
 * @constructor\par
 */\par
function LocalStrings(opt_templateData) \{\par
  this.templateData = opt_templateData;\par
\}\par
\par
// Start of anonymous namespace.\par
(function() \{\par
\par
/**\par
 * Returns a formatted string where $1 to $9 are replaced by the second to the\par
 * tenth argument.\par
 * @param \{string\} s The format string.\par
 * @param \{...string\} The extra values to include in the formatted output.\par
 * @return \{string\} The string after format substitution.\par
 */\par
function replaceArgs(s, args) \{\par
  return s.replace(/\\$[$1-9]/g, function(m) \{\par
    return (m == '$$') ? '$' : args[m[1]];\par
  \});\par
\}\par
\par
/**\par
 * Returns a string after removing Windows-style accelerators.\par
 * @param \{string\} s The input string that may contain accelerators.\par
 * @return \{string\} The resulting string with accelerators removed.\par
 */\par
function trimAccelerators(s) \{\par
  return s.replace(/&\{1,2\}/g, function(m) \{\par
    return (m == '&&') ? '&' : '';\par
  \});\par
\}\par
\par
LocalStrings.prototype = \{\par
  /**\par
   * The template data object.\par
   * @type \{Object\}\par
   */\par
  templateData: null,\par
\par
  /**\par
   * Gets a localized string by its id.\par
   * @param \{string\} s The ID of the string we want.\par
   * @return \{string\} The localized string.\par
   */\par
  getString: function(id) \{\par
    // TODO(arv): We should not rely on a global variable here.\par
    return (this.templateData || window.templateData)[id] || '';\par
  \},\par
\par
  /**\par
   * Returns a formatted localized string where $1 to $9 are replaced by the\par
   * second to the tenth argument.\par
   * @param \{string\} id The ID of the string we want.\par
   * @param \{...string\} The extra values to include in the formatted output.\par
   * @return \{string\} The formatted string.\par
   */\par
  getStringF: function(id, var_args) \{\par
    return replaceArgs(this.getString(id), arguments);\par
  \},\par
\};\par
\par
// End of anonymous namespace.\par
\})();\par
</script>\par
<script>/**\par
 * Whitelist of tag names allowed in parseHtmlSubset.\par
 * @type \{[string]\}\par
 */\par
var allowedTags = ['A', 'B', 'STRONG'];\par
\par
/**\par
 * Parse a very small subset of HTML.\par
 * @param \{string\} s The string to parse.\par
 * @throws \{Error\} In case of non supported markup.\par
 * @return \{DocumentFragment\} A document fragment containing the DOM tree.\par
 */\par
var allowedAttributes = \{\par
  'href': function(node, value) \{\par
    // Only allow a[href] starting with {{\field{\*\fldinst{HYPERLINK http:// }}{\fldrslt{http://\ul0\cf0}}}}\f0\fs22  and {{\field{\*\fldinst{HYPERLINK https:// }}{\fldrslt{https://\ul0\cf0}}}}\f0\fs22\par
    return node.tagName == 'A' && (value.indexOf('{{\field{\*\fldinst{HYPERLINK http:// }}{\fldrslt{http://\ul0\cf0}}}}\f0\fs22 ') == 0 ||\par
        value.indexOf('{{\field{\*\fldinst{HYPERLINK https:// }}{\fldrslt{https://\ul0\cf0}}}}\f0\fs22 ') == 0);\par
  \},\par
  'target': function(node, value) \{\par
    // Allow a[target] but reset the value to "".\par
    if (node.tagName != 'A')\par
      return false;\par
    node.setAttribute('target', '');\par
    return true;\par
  \}\par
\}\par
\par
/**\par
 * Parse a very small subset of HTML.  This ensures that insecure HTML /\par
 * javascript cannot be injected into the new tab page.\par
 * @param \{string\} s The string to parse.\par
 * @throws \{Error\} In case of non supported markup.\par
 * @return \{DocumentFragment\} A document fragment containing the DOM tree.\par
 */\par
function parseHtmlSubset(s) \{\par
  function walk(n, f) \{\par
    f(n);\par
    for (var i = 0; i < n.childNodes.length; i++) \{\par
      walk(n.childNodes[i], f);\par
    \}\par
  \}\par
\par
  function assertElement(node) \{\par
    if (allowedTags.indexOf(node.tagName) == -1)\par
      throw Error(node.tagName + ' is not supported');\par
  \}\par
\par
  function assertAttribute(attrNode, node) \{\par
    var n = attrNode.nodeName;\par
    var v = attrNode.nodeValue;\par
    if (!allowedAttributes.hasOwnProperty(n) || !allowedAttributes[n](node, v))\par
      throw Error(node.tagName + '[' + n + '="' + v + '"] is not supported');\par
  \}\par
\par
  var r = document.createRange();\par
  r.selectNode(document.body);\par
  // This does not execute any scripts.\par
  var df = r.createContextualFragment(s);\par
  walk(df, function(node) \{\par
    switch (node.nodeType) \{\par
      case Node.ELEMENT_NODE:\par
        assertElement(node);\par
        var attrs = node.attributes;\par
        for (var i = 0; i < attrs.length; i++) \{\par
          assertAttribute(attrs[i], node);\par
        \}\par
        break;\par
\par
      case Node.COMMENT_NODE:\par
      case Node.DOCUMENT_FRAGMENT_NODE:\par
      case Node.TEXT_NODE:\par
        break;\par
\par
      default:\par
        throw Error('Node type ' + node.nodeType + ' is not supported');\par
    \}\par
  \});\par
  return df;\par
\}\par
</script>\par
<script>// Copyright (c) 2011 The Chromium Authors. All rights reserved.\par
// Use of this source code is governed by a BSD-style license that can be\par
// found in the LICENSE file.\par
\par
/**\par
 * The global object.\par
 * @type \{!Object\}\par
 */\par
const global = this;\par
\par
/**\par
 * Alias for document.getElementById.\par
 * @param \{string\} id The ID of the element to find.\par
 * @return \{HTMLElement\} The found element or null if not found.\par
 */\par
function $(id) \{\par
  return document.getElementById(id);\par
\}\par
\par
/**\par
 * Calls chrome.send with a callback and restores the original afterwards.\par
 * @param \{string\} name The name of the message to send.\par
 * @param \{!Array\} params The parameters to send.\par
 * @param \{string\} callbackName The name of the function that the backend calls.\par
 * @param \{!Function\} The function to call.\par
 */\par
function chromeSend(name, params, callbackName, callback) \{\par
  var old = global[callbackName];\par
  global[callbackName] = function() \{\par
    // restore\par
    global[callbackName] = old;\par
\par
    var args = Array.prototype.slice.call(arguments);\par
    return callback.apply(global, args);\par
  \};\par
  chrome.send(name, params);\par
\}\par
\par
/**\par
 * Generates a CSS url string.\par
 * @param \{string\} s The URL to generate the CSS url for.\par
 * @return \{string\} The CSS url string.\par
 */\par
function url(s) \{\par
  // {{\field{\*\fldinst{HYPERLINK http://www.w3.org/TR/css3-values/#uris }}{\fldrslt{http://www.w3.org/TR/css3-values/#uris\ul0\cf0}}}}\f0\fs22\par
  // Parentheses, commas, whitespace characters, single quotes (') and double\par
  // quotes (") appearing in a URI must be escaped with a backslash\par
  var s2 = s.replace(/(\\(|\\)|\\,|\\s|\\'|\\"|{{\field{\*\fldinst{HYPERLINK "\\\\\\\\)/g"}}{\fldrslt{\\\\)/g\ul0\cf0}}}}\f0\fs22 , '{{\field{\*\fldinst{HYPERLINK "\\\\\\\\$1'"}}{\fldrslt{\\\\$1'\ul0\cf0}}}}\f0\fs22 );\par
  // WebKit has a bug when it comes to URLs that end with \\\par
  // {{\field{\*\fldinst{HYPERLINK https://bugs.webkit.org/show_bug.cgi?id=28885 }}{\fldrslt{https://bugs.webkit.org/show_bug.cgi?id=28885\ul0\cf0}}}}\f0\fs22\par
  if (/\\\\\\\\$/.test(s2)) \{\par
    // Add a space to work around the WebKit bug.\par
    s2 += ' ';\par
  \}\par
  return 'url("' + s2 + '")';\par
\}\par
\par
/**\par
 * Parses query parameters from Location.\par
 * @param \{string\} s The URL to generate the CSS url for.\par
 * @return \{object\} Dictionary containing name value pairs for URL\par
 */\par
function parseQueryParams(location) \{\par
  var params = \{\};\par
  var query = unescape(location.search.substring(1));\par
  var vars = query.split("&");\par
  for (var i=0; i < vars.length; i++) \{\par
    var pair = vars[i].split("=");\par
    params[pair[0]] = pair[1];\par
  \}\par
  return params;\par
\}\par
\par
function findAncestorByClass(el, className) \{\par
  return findAncestor(el, function(el) \{\par
    if (el.classList)\par
      return el.classList.contains(className);\par
    return null;\par
  \});\par
\}\par
\par
/**\par
 * Return the first ancestor for which the \{@code predicate\} returns true.\par
 * @param \{Node\} node The node to check.\par
 * @param \{function(Node) : boolean\} predicate The function that tests the\par
 *     nodes.\par
 * @return \{Node\} The found ancestor or null if not found.\par
 */\par
function findAncestor(node, predicate) \{\par
  var last = false;\par
  while (node != null && !(last = predicate(node))) \{\par
    node = node.parentNode;\par
  \}\par
  return last ? node : null;\par
\}\par
\par
function swapDomNodes(a, b) \{\par
  var afterA = a.nextSibling;\par
  if (afterA == b) \{\par
    swapDomNodes(b, a);\par
    return;\par
  \}\par
  var aParent = a.parentNode;\par
  b.parentNode.replaceChild(a, b);\par
  aParent.insertBefore(b, afterA);\par
\}\par
\par
/**\par
 * Disables text selection and dragging.\par
 */\par
function disableTextSelectAndDrag() \{\par
  // Disable text selection.\par
  document.onselectstart = function(e) \{\par
    e.preventDefault();\par
  \}\par
\par
  // Disable dragging.\par
  document.ondragstart = function(e) \{\par
    e.preventDefault();\par
  \}\par
\}\par
\par
/**\par
 * Check the directionality of the page.\par
 * @return \{boolean\} True if Chrome is running an RTL UI.\par
 */\par
function isRTL() \{\par
  return document.documentElement.dir == 'rtl';\par
\}\par
\par
/**\par
 * Simple common assertion API\par
 * @param \{*\} condition The condition to test.  Note that this may be used to\par
 *     test whether a value is defined or not, and we don't want to force a\par
 *     cast to Boolean.\par
 * @param \{string=\} opt_message A message to use in any error.\par
 */\par
function assert(condition, opt_message) \{\par
  'use strict';\par
  if (!condition) \{\par
    var msg = 'Assertion failed';\par
    if (opt_message)\par
      msg = msg + ': ' + opt_message;\par
    throw new Error(msg);\par
  \}\par
\}\par
\par
/**\par
 * Get an element that's known to exist by its ID. We use this instead of just\par
 * calling getElementById and not checking the result because this lets us\par
 * satisfy the JSCompiler type system.\par
 * @param \{string\} id The identifier name.\par
 * @return \{!Element\} the Element.\par
 */\par
function getRequiredElement(id) \{\par
  var element = $(id);\par
  assert(element, 'Missing required element: ' + id);\par
  return element;\par
\}\par
\par
// Handle click on a link. If the link points to a chrome: or file: url, then\par
// call into the browser to do the navigation.\par
document.addEventListener('click', function(e) \{\par
  // Allow preventDefault to work.\par
  if (!e.returnValue)\par
    return;\par
\par
  var el = e.target;\par
  if (el.nodeType == Node.ELEMENT_NODE &&\par
      el.webkitMatchesSelector('A, A *')) \{\par
    while (el.tagName != 'A') \{\par
      el = el.parentElement;\par
    \}\par
\par
    if ((el.protocol == '{{\field{\*\fldinst{HYPERLINK file: }}{\fldrslt{file:\ul0\cf0}}}}\f0\fs22 ' || el.protocol == 'about:') &&\par
        (e.button == 0 || e.button == 1)) \{\par
      chrome.send('navigateToUrl', [\par
        el.href,\par
        el.target,\par
        e.button,\par
        e.altKey,\par
        e.ctrlKey,\par
        e.metaKey,\par
        e.shiftKey\par
      ]);\par
      e.preventDefault();\par
    \}\par
  \}\par
\});\par
\par
/**\par
 * Creates a new URL which is the old URL with a GET param of key=value.\par
 * @param \{string\} url The base URL. There is not sanity checking on the URL so\par
 *     it must be passed in a proper format.\par
 * @param \{string\} key The key of the param.\par
 * @param \{string\} value The value of the param.\par
 * @return \{string\}\par
 */\par
function appendParam(url, key, value) \{\par
  var param = encodeURIComponent(key) + '=' + encodeURIComponent(value);\par
\par
  if (url.indexOf('?') == -1)\par
    return url + '?' + param;\par
  return url + '&' + param;\par
\}\par
</script>\par
\par
<script>// Copyright (c) 2012 The Chromium Authors. All rights reserved.\par
// Use of this source code is governed by a BSD-style license that can be\par
// found in the LICENSE file.\par
\par
const cr = (function() \{\par
\par
  /**\par
   * Whether we are using a Mac or not.\par
   * @type \{boolean\}\par
   */\par
  const isMac = /Mac/.test(navigator.platform);\par
\par
  /**\par
   * Whether this is on the Windows platform or not.\par
   * @type \{boolean\}\par
   */\par
  const isWindows = /Win/.test(navigator.platform);\par
\par
  /**\par
   * Whether this is on chromeOS or not.\par
   * @type \{boolean\}\par
   */\par
  const isChromeOS = /CrOS/.test(navigator.userAgent);\par
\par
  /**\par
   * Whether this is on vanilla Linux (not chromeOS).\par
   * @type \{boolean\}\par
   */\par
  const isLinux = /Linux/.test(navigator.userAgent);\par
\par
  /**\par
   * Whether this uses GTK or not.\par
   * @type \{boolean\}\par
   */\par
  const isGTK = /GTK/.test(chrome.toolkit);\par
\par
  /**\par
   * Whether this uses the views toolkit or not.\par
   * @type \{boolean\}\par
   */\par
  const isViews = /views/.test(chrome.toolkit);\par
\par
  /**\par
   * Whether this window is optimized for touch-based input.\par
   * @type \{boolean\}\par
   */\par
  const isTouchOptimized = !!chrome.touchOptimized;\par
\par
  /**\par
   * Sets the os and toolkit attributes in the <html> element so that platform\par
   * specific css rules can be applied.\par
   */\par
  function enablePlatformSpecificCSSRules() \{\par
    if (isMac)\par
      doc.documentElement.setAttribute('os', 'mac');\par
    if (isWindows)\par
      doc.documentElement.setAttribute('os', 'windows');\par
    if (isChromeOS)\par
      doc.documentElement.setAttribute('os', 'chromeos');\par
    if (isLinux)\par
      doc.documentElement.setAttribute('os', 'linux');\par
    if (isGTK)\par
      doc.documentElement.setAttribute('toolkit', 'gtk');\par
    if (isViews)\par
      doc.documentElement.setAttribute('toolkit', 'views');\par
    if (isTouchOptimized)\par
      doc.documentElement.setAttribute('touch-optimized', '');\par
  \}\par
\par
  /**\par
   * Builds an object structure for the provided namespace path,\par
   * ensuring that names that already exist are not overwritten. For\par
   * example:\par
   * "a.b.c" -> a = \{\};a.b=\{\};a.b.c=\{\};\par
   * @param \{string\} name Name of the object that this file defines.\par
   * @param \{*=\} opt_object The object to expose at the end of the path.\par
   * @param \{Object=\} opt_objectToExportTo The object to add the path to;\par
   *     default is \{@code window\}.\par
   * @private\par
   */\par
  function exportPath(name, opt_object, opt_objectToExportTo) \{\par
    var parts = name.split('.');\par
    var cur = opt_objectToExportTo || window /* global */;\par
\par
    for (var part; parts.length && (part = parts.shift());) \{\par
      if (!parts.length && opt_object !== undefined) \{\par
        // last part and we have an object; use it\par
        cur[part] = opt_object;\par
      \} else if (part in cur) \{\par
        cur = cur[part];\par
      \} else \{\par
        cur = cur[part] = \{\};\par
      \}\par
    \}\par
    return cur;\par
  \};\par
\par
  // cr.Event is called CrEvent in here to prevent naming conflicts. We also\par
  // store the original Event in case someone does a global alias of cr.Event.\par
  const DomEvent = Event;\par
\par
  /**\par
   * Creates a new event to be used with cr.EventTarget or DOM EventTarget\par
   * objects.\par
   * @param \{string\} type The name of the event.\par
   * @param \{boolean=\} opt_bubbles Whether the event bubbles. Default is false.\par
   * @param \{boolean=\} opt_preventable Whether the default action of the event\par
   *     can be prevented.\par
   * @constructor\par
   * @extends \{DomEvent\}\par
   */\par
  function CrEvent(type, opt_bubbles, opt_preventable) \{\par
    var e = cr.doc.createEvent('Event');\par
    e.initEvent(type, !!opt_bubbles, !!opt_preventable);\par
    e.__proto__ = CrEvent.prototype;\par
    return e;\par
  \}\par
\par
  CrEvent.prototype = \{\par
    __proto__: DomEvent.prototype\par
  \};\par
\par
  /**\par
   * Fires a property change event on the target.\par
   * @param \{EventTarget\} target The target to dispatch the event on.\par
   * @param \{string\} propertyName The name of the property that changed.\par
   * @param \{*\} newValue The new value for the property.\par
   * @param \{*\} oldValue The old value for the property.\par
   */\par
  function dispatchPropertyChange(target, propertyName, newValue, oldValue) \{\par
    var e = new CrEvent(propertyName + 'Change');\par
    e.propertyName = propertyName;\par
    e.newValue = newValue;\par
    e.oldValue = oldValue;\par
    target.dispatchEvent(e);\par
  \}\par
\par
  /**\par
   * Converts a camelCase javascript property name to a hyphenated-lower-case\par
   * attribute name.\par
   * @param \{string\} jsName The javascript camelCase property name.\par
   * @return \{string\} The equivalent hyphenated-lower-case attribute name.\par
   */\par
  function getAttributeName(jsName) \{\par
    return jsName.replace(/([A-Z])/g, '-$1').toLowerCase();\par
  \}\par
\par
  /**\par
   * The kind of property to define in \{@code defineProperty\}.\par
   * @enum \{number\}\par
   */\par
  const PropertyKind = \{\par
    /**\par
     * Plain old JS property where the backing data is stored as a "private"\par
     * field on the object.\par
     */\par
    JS: 'js',\par
\par
    /**\par
     * The property backing data is stored as an attribute on an element.\par
     */\par
    ATTR: 'attr',\par
\par
    /**\par
     * The property backing data is stored as an attribute on an element. If the\par
     * element has the attribute then the value is true.\par
     */\par
    BOOL_ATTR: 'boolAttr'\par
  \};\par
\par
  /**\par
   * Helper function for defineProperty that returns the getter to use for the\par
   * property.\par
   * @param \{string\} name\par
   * @param \{cr.PropertyKind\} kind\par
   * @return \{function():*\} The getter for the property.\par
   */\par
  function getGetter(name, kind) \{\par
    switch (kind) \{\par
      case PropertyKind.JS:\par
        var privateName = name + '_';\par
        return function() \{\par
          return this[privateName];\par
        \};\par
      case PropertyKind.ATTR:\par
        var attributeName = getAttributeName(name);\par
        return function() \{\par
          return this.getAttribute(attributeName);\par
        \};\par
      case PropertyKind.BOOL_ATTR:\par
        var attributeName = getAttributeName(name);\par
        return function() \{\par
          return this.hasAttribute(attributeName);\par
        \};\par
    \}\par
  \}\par
\par
  /**\par
   * Helper function for defineProperty that returns the setter of the right\par
   * kind.\par
   * @param \{string\} name The name of the property we are defining the setter\par
   *     for.\par
   * @param \{cr.PropertyKind\} kind The kind of property we are getting the\par
   *     setter for.\par
   * @param \{function(*):void\} opt_setHook A function to run after the property\par
   *     is set, but before the propertyChange event is fired.\par
   * @return \{function(*):void\} The function to use as a setter.\par
   */\par
  function getSetter(name, kind, opt_setHook) \{\par
    switch (kind) \{\par
      case PropertyKind.JS:\par
        var privateName = name + '_';\par
        return function(value) \{\par
          var oldValue = this[privateName];\par
          if (value !== oldValue) \{\par
            this[privateName] = value;\par
            if (opt_setHook)\par
              opt_setHook.call(this, value, oldValue);\par
            dispatchPropertyChange(this, name, value, oldValue);\par
          \}\par
        \};\par
\par
      case PropertyKind.ATTR:\par
        var attributeName = getAttributeName(name);\par
        return function(value) \{\par
          var oldValue = this[attributeName];\par
          if (value !== oldValue) \{\par
            if (value == undefined)\par
              this.removeAttribute(attributeName);\par
            else\par
              this.setAttribute(attributeName, value);\par
            if (opt_setHook)\par
              opt_setHook.call(this, value, oldValue);\par
            dispatchPropertyChange(this, name, value, oldValue);\par
          \}\par
        \};\par
\par
      case PropertyKind.BOOL_ATTR:\par
        var attributeName = getAttributeName(name);\par
        return function(value) \{\par
          var oldValue = this[attributeName];\par
          if (value !== oldValue) \{\par
            if (value)\par
              this.setAttribute(attributeName, name);\par
            else\par
              this.removeAttribute(attributeName);\par
            if (opt_setHook)\par
              opt_setHook.call(this, value, oldValue);\par
            dispatchPropertyChange(this, name, value, oldValue);\par
          \}\par
        \};\par
    \}\par
  \}\par
\par
  /**\par
   * Defines a property on an object. When the setter changes the value a\par
   * property change event with the type \{@code name + 'Change'\} is fired.\par
   * @param \{!Object\} obj The object to define the property for.\par
   * @param \{string\} name The name of the property.\par
   * @param \{cr.PropertyKind=\} opt_kind What kind of underlying storage to use.\par
   * @param \{function(*):void\} opt_setHook A function to run after the\par
   *     property is set, but before the propertyChange event is fired.\par
   */\par
  function defineProperty(obj, name, opt_kind, opt_setHook) \{\par
    if (typeof obj == 'function')\par
      obj = obj.prototype;\par
\par
    var kind = opt_kind || PropertyKind.JS;\par
\par
    if (!obj.__lookupGetter__(name))\par
      obj.__defineGetter__(name, getGetter(name, kind));\par
\par
    if (!obj.__lookupSetter__(name))\par
      obj.__defineSetter__(name, getSetter(name, kind, opt_setHook));\par
  \}\par
\par
  /**\par
   * Counter for use with createUid\par
   */\par
  var uidCounter = 1;\par
\par
  /**\par
   * @return \{number\} A new unique ID.\par
   */\par
  function createUid() \{\par
    return uidCounter++;\par
  \}\par
\par
  /**\par
   * Returns a unique ID for the item. This mutates the item so it needs to be\par
   * an object\par
   * @param \{!Object\} item The item to get the unique ID for.\par
   * @return \{number\} The unique ID for the item.\par
   */\par
  function getUid(item) \{\par
    if (item.hasOwnProperty('uid'))\par
      return item.uid;\par
    return item.uid = createUid();\par
  \}\par
\par
  /**\par
   * Dispatches a simple event on an event target.\par
   * @param \{!EventTarget\} target The event target to dispatch the event on.\par
   * @param \{string\} type The type of the event.\par
   * @param \{boolean=\} opt_bubbles Whether the event bubbles or not.\par
   * @param \{boolean=\} opt_cancelable Whether the default action of the event\par
   *     can be prevented.\par
   * @return \{boolean\} If any of the listeners called \{@code preventDefault\}\par
   *     during the dispatch this will return false.\par
   */\par
  function dispatchSimpleEvent(target, type, opt_bubbles, opt_cancelable) \{\par
    var e = new cr.Event(type, opt_bubbles, opt_cancelable);\par
    return target.dispatchEvent(e);\par
  \}\par
\par
  /**\par
   * @param \{string\} name\par
   * @param \{!Function\} fun\par
   */\par
  function define(name, fun) \{\par
    var obj = exportPath(name);\par
    var exports = fun();\par
    for (var propertyName in exports) \{\par
      // Maybe we should check the prototype chain here? The current usage\par
      // pattern is always using an object literal so we only care about own\par
      // properties.\par
      var propertyDescriptor = Object.getOwnPropertyDescriptor(exports,\par
                                                               propertyName);\par
      if (propertyDescriptor)\par
        Object.defineProperty(obj, propertyName, propertyDescriptor);\par
    \}\par
  \}\par
\par
  /**\par
   * Document used for various document related operations.\par
   * @type \{!Document\}\par
   */\par
  var doc = document;\par
\par
\par
  /**\par
   * Allows you to run func in the context of a different document.\par
   * @param \{!Document\} document The document to use.\par
   * @param \{function():*\} func The function to call.\par
   */\par
  function withDoc(document, func) \{\par
    var oldDoc = doc;\par
    doc = document;\par
    try \{\par
      func();\par
    \} finally \{\par
      doc = oldDoc;\par
    \}\par
  \}\par
\par
  /**\par
   * Adds a \{@code getInstance\} static method that always return the same\par
   * instance object.\par
   * @param \{!Function\} ctor The constructor for the class to add the static\par
   *     method to.\par
   */\par
  function addSingletonGetter(ctor) \{\par
    ctor.getInstance = function() \{\par
      return ctor.instance_ || (ctor.instance_ = new ctor());\par
    \};\par
  \}\par
\par
  return \{\par
    addSingletonGetter: addSingletonGetter,\par
    isChromeOS: isChromeOS,\par
    isMac: isMac,\par
    isWindows: isWindows,\par
    isLinux: isLinux,\par
    isViews: isViews,\par
    isTouchOptimized: isTouchOptimized,\par
    enablePlatformSpecificCSSRules: enablePlatformSpecificCSSRules,\par
    define: define,\par
    defineProperty: defineProperty,\par
    PropertyKind: PropertyKind,\par
    createUid: createUid,\par
    getUid: getUid,\par
    dispatchSimpleEvent: dispatchSimpleEvent,\par
    dispatchPropertyChange: dispatchPropertyChange,\par
\par
    /**\par
     * The document that we are currently using.\par
     * @type \{!Document\}\par
     */\par
    get doc() \{\par
      return doc;\par
    \},\par
    withDoc: withDoc,\par
    Event: CrEvent\par
  \};\par
\})();\par
</script>\par
<script>// Copyright (c) 2010 The Chromium Authors. All rights reserved.\par
// Use of this source code is governed by a BSD-style license that can be\par
// found in the LICENSE file.\par
\par
cr.define('cr.ui', function() \{\par
\par
  /**\par
   * Decorates elements as an instance of a class.\par
   * @param \{string|!Element\} source The way to find the element(s) to decorate.\par
   *     If this is a string then \{@code querySeletorAll\} is used to find the\par
   *     elements to decorate.\par
   * @param \{!Function\} constr The constructor to decorate with. The constr\par
   *     needs to have a \{@code decorate\} function.\par
   */\par
  function decorate(source, constr) \{\par
    var elements;\par
    if (typeof source == 'string')\par
      elements = cr.doc.querySelectorAll(source);\par
    else\par
      elements = [source];\par
\par
    for (var i = 0, el; el = elements[i]; i++) \{\par
      if (!(el instanceof constr))\par
        constr.decorate(el);\par
    \}\par
  \}\par
\par
  /**\par
   * Helper function for creating new element for define.\par
   */\par
  function createElementHelper(tagName, opt_bag) \{\par
    // Allow passing in ownerDocument to create in a different document.\par
    var doc;\par
    if (opt_bag && opt_bag.ownerDocument)\par
      doc = opt_bag.ownerDocument;\par
    else\par
      doc = cr.doc;\par
    return doc.createElement(tagName);\par
  \}\par
\par
  /**\par
   * Creates the constructor for a UI element class.\par
   *\par
   * Usage:\par
   * <pre>\par
   * var List = cr.ui.define('list');\par
   * List.prototype = \{\par
   *   __proto__: HTMLUListElement.prototype,\par
   *   decorate: function() \{\par
   *     ...\par
   *   \},\par
   *   ...\par
   * \};\par
   * </pre>\par
   *\par
   * @param \{string|Function\} tagNameOrFunction The tagName or\par
   *     function to use for newly created elements. If this is a function it\par
   *     needs to return a new element when called.\par
   * @return \{function(Object=):Element\} The constructor function which takes\par
   *     an optional property bag. The function also has a static\par
   *     \{@code decorate\} method added to it.\par
   */\par
  function define(tagNameOrFunction) \{\par
    var createFunction, tagName;\par
    if (typeof tagNameOrFunction == 'function') \{\par
      createFunction = tagNameOrFunction;\par
      tagName = '';\par
    \} else \{\par
      createFunction = createElementHelper;\par
      tagName = tagNameOrFunction;\par
    \}\par
\par
    /**\par
     * Creates a new UI element constructor.\par
     * @param \{Object=\} opt_propertyBag Optional bag of properties to set on the\par
     *     object after created. The property \{@code ownerDocument\} is special\par
     *     cased and it allows you to create the element in a different\par
     *     document than the default.\par
     * @constructor\par
     */\par
    function f(opt_propertyBag) \{\par
      var el = createFunction(tagName, opt_propertyBag);\par
      f.decorate(el);\par
      for (var propertyName in opt_propertyBag) \{\par
        el[propertyName] = opt_propertyBag[propertyName];\par
      \}\par
      return el;\par
    \}\par
\par
    /**\par
     * Decorates an element as a UI element class.\par
     * @param \{!Element\} el The element to decorate.\par
     */\par
    f.decorate = function(el) \{\par
      el.__proto__ = f.prototype;\par
      el.decorate();\par
    \};\par
\par
    return f;\par
  \}\par
\par
  /**\par
   * Input elements do not grow and shrink with their content. This is a simple\par
   * (and not very efficient) way of handling shrinking to content with support\par
   * for min width and limited by the width of the parent element.\par
   * @param \{HTMLElement\} el The element to limit the width for.\par
   * @param \{number\} parentEl The parent element that should limit the size.\par
   * @param \{number\} min The minimum width.\par
   */\par
  function limitInputWidth(el, parentEl, min) \{\par
    // Needs a size larger than borders\par
    el.style.width = '10px';\par
    var doc = el.ownerDocument;\par
    var win = doc.defaultView;\par
    var computedStyle = win.getComputedStyle(el);\par
    var parentComputedStyle = win.getComputedStyle(parentEl);\par
    var rtl = computedStyle.direction == 'rtl';\par
\par
    // To get the max width we get the width of the treeItem minus the position\par
    // of the input.\par
    var inputRect = el.getBoundingClientRect();  // box-sizing\par
    var parentRect = parentEl.getBoundingClientRect();\par
    var startPos = rtl ? parentRect.right - inputRect.right :\par
        inputRect.left - parentRect.left;\par
\par
    // Add up border and padding of the input.\par
    var inner = parseInt(computedStyle.borderLeftWidth, 10) +\par
        parseInt(computedStyle.paddingLeft, 10) +\par
        parseInt(computedStyle.paddingRight, 10) +\par
        parseInt(computedStyle.borderRightWidth, 10);\par
\par
    // We also need to subtract the padding of parent to prevent it to overflow.\par
    var parentPadding = rtl ? parseInt(parentComputedStyle.paddingLeft, 10) :\par
        parseInt(parentComputedStyle.paddingRight, 10);\par
\par
    var max = parentEl.clientWidth - startPos - inner - parentPadding;\par
\par
    function limit() \{\par
      if (el.scrollWidth > max) \{\par
        el.style.width = max + 'px';\par
      \} else \{\par
        el.style.width = 0;\par
        var sw = el.scrollWidth;\par
        if (sw < min) \{\par
          el.style.width = min + 'px';\par
        \} else \{\par
          el.style.width = sw + 'px';\par
        \}\par
      \}\par
    \}\par
\par
    el.addEventListener('input', limit);\par
    limit();\par
  \}\par
\par
  return \{\par
    decorate: decorate,\par
    define: define,\par
    limitInputWidth: limitInputWidth\par
  \};\par
\});\par
</script>\par
<script>// Copyright (c) 2011 The Chromium Authors. All rights reserved.\par
// Use of this source code is governed by a BSD-style license that can be\par
// found in the LICENSE file.\par
\par
// require: event_tracker.js\par
\par
cr.define('cr.ui', function() \{\par
\par
  // The arrow location specifies how the arrow and bubble are positioned in\par
  // relation to the anchor node.\par
  const ArrowLocation = \{\par
    // The arrow is positioned at the top and the start of the bubble. In left\par
    // to right mode this is the top left. The entire bubble is positioned below\par
    // the anchor node.\par
    TOP_START : "top-start",\par
    // The arrow is positioned at the top and the end of the bubble. In left to\par
    // right mode this is the top right. The entire bubble is positioned below\par
    // the anchor node.\par
    TOP_END : "top-end",\par
    // The arrow is positioned at the bottom and the start of the bubble. In\par
    // left to right mode this is the bottom left. The entire bubble is\par
    // positioned above the anchor node.\par
    BOTTOM_START : "bottom-start",\par
    // The arrow is positioned at the bottom and the end of the bubble. In\par
    // left to right mode this is the bottom right. The entire bubble is\par
    // positioned above the anchor node.\par
    BOTTOM_END : "bottom-end"\par
  \};\par
\par
  // The bubble alignment specifies the horizontal position of the bubble in\par
  // relation to the anchor node.\par
  const BubbleAlignment = \{\par
    // The bubble is positioned so that the tip of the arrow points to the\par
    // middle of the anchor node.\par
    ARROW_TO_MID_ANCHOR : "arrow-to-mid-anchor",\par
    // The bubble is positioned so that the edge nearest to the arrow is lined\par
    // up with the edge of the anchor node.\par
    BUBBLE_EDGE_TO_ANCHOR_EDGE : "bubble-edge-anchor-edge"\par
  \};\par
\par
  // The horizontal distance between the tip of the arrow and the start or the\par
  // end of the bubble (as specified by the arrow location).\par
  const ARROW_OFFSET_X = 30;\par
\par
  // The vertical distance between the tip of the arrow and the bottom or top of\par
  // the bubble (as specified by the arrow location). Note, if you change this\par
  // then you should also change the "top" and "bottom" values for .bubble-arrow\par
  // in bubble.css.\par
  const ARROW_OFFSET_Y = 8;\par
\par
  /**\par
   * Bubble is a free-floating informational bubble with a triangular arrow\par
   * that points at a place of interest on the page.\par
   */\par
  var Bubble = cr.ui.define('div');\par
\par
  Bubble.prototype = \{\par
    __proto__: HTMLDivElement.prototype,\par
\par
    decorate: function() \{\par
      this.className = 'bubble';\par
      this.innerHTML =\par
          '<div class=\\"bubble-contents\\"></div>' +\par
          '<div class=\\"bubble-close\\"></div>' +\par
          '<div class=\\"bubble-shadow\\"></div>' +\par
          '<div class=\\"bubble-arrow\\"></div>';\par
\par
      this.hidden = true;\par
      this.handleCloseEvent = this.hide;\par
      this.deactivateToDismissDelay_ = 0;\par
      this.bubbleAlignment = BubbleAlignment.ARROW_TO_MID_ANCHOR;\par
    \},\par
\par
    /**\par
     * Sets the child node of the bubble.\par
     * @param \{node\} An HTML element\par
     */\par
    set content(node) \{\par
      var bubbleContent = this.querySelector('.bubble-contents');\par
      bubbleContent.innerHTML = "";\par
      bubbleContent.appendChild(node);\par
    \},\par
\par
    /**\par
     * Handles close event which is triggered when the close button\par
     * is clicked. By default is set to this.hide.\par
     * @param \{function\} A function with no parameters\par
     */\par
    set handleCloseEvent(func) \{\par
      this.handleCloseEvent_ = func;\par
    \},\par
\par
    /**\par
     * Sets the anchor node, i.e. the node that this bubble points at.\par
     * @param \{HTMLElement\} node The new anchor node.\par
     */\par
    set anchorNode(node) \{\par
      this.anchorNode_ = node;\par
\par
      if (!this.hidden)\par
        this.reposition();\par
    \},\par
\par
    /**\par
     * Sets the arrow location.\par
     * @param \{cr.ui.ArrowLocation\} arrowLocation The new arrow location.\par
     */\par
    setArrowLocation: function(arrowLocation) \{\par
      this.isRight_ = arrowLocation == ArrowLocation.TOP_END ||\par
                      arrowLocation == ArrowLocation.BOTTOM_END;\par
      if (document.documentElement.dir == 'rtl')\par
        this.isRight_ = !this.isRight_;\par
      this.isTop_ = arrowLocation == ArrowLocation.TOP_START ||\par
                    arrowLocation == ArrowLocation.TOP_END;\par
\par
      var bubbleArrow = this.querySelector('.bubble-arrow');\par
      bubbleArrow.setAttribute('is-right', this.isRight_);\par
      bubbleArrow.setAttribute('is-top', this.isTop_);\par
\par
      if (!this.hidden)\par
        this.reposition();\par
    \},\par
\par
    /**\par
     * Sets the bubble alignment.\par
     * @param \{cr.ui.BubbleAlignment\} alignment The new bubble alignment.\par
     */\par
    set bubbleAlignment(alignment) \{\par
      this.bubbleAlignment_ = alignment;\par
    \},\par
\par
    /**\par
     * Sets the delay before the user is allowed to click outside the bubble\par
     * to dismiss it. Using a delay makes it less likely that the user will\par
     * unintentionally dismiss the bubble.\par
     * @param \{int\} delay The delay in miliseconds.\par
     */\par
    set deactivateToDismissDelay(delay) \{\par
      this.deactivateToDismissDelay_ = delay;\par
    \},\par
\par
    /**\par
     * Hides or shows the close button.\par
     * @param \{Boolean\} isVisible True if the close button should be visible.\par
     */\par
    setCloseButtonVisible: function(isVisible) \{\par
      this.querySelector('.bubble-close').hidden = !isVisible;\par
    \},\par
\par
    /**\par
     * Updates the position of the bubble. This is automatically called when\par
     * the window is resized, but should also be called any time the layout\par
     * may have changed.\par
     */\par
    reposition: function() \{\par
      var clientRect = this.anchorNode_.getBoundingClientRect();\par
\par
      var left;\par
      if (this.bubbleAlignment_ ==\par
          BubbleAlignment.BUBBLE_EDGE_TO_ANCHOR_EDGE) \{\par
        left = this.isRight_ ? clientRect.right - this.clientWidth :\par
            clientRect.left;\par
      \} else \{\par
        var anchorMid = (clientRect.left + clientRect.right) / 2;\par
        left = this.isRight_ ? anchorMid - this.clientWidth + ARROW_OFFSET_X :\par
            anchorMid - ARROW_OFFSET_X;\par
      \}\par
      var top = this.isTop_ ? clientRect.bottom + ARROW_OFFSET_Y :\par
          clientRect.top - this.clientHeight - ARROW_OFFSET_Y;\par
\par
      this.style.left = left + 'px';\par
      this.style.top = top + 'px';\par
    \},\par
\par
    /**\par
     * Starts showing the bubble. The bubble will show until the user clicks\par
     * away or presses Escape.\par
     */\par
    show: function() \{\par
      if (!this.hidden)\par
        return;\par
\par
      document.body.appendChild(this);\par
      this.hidden = false;\par
      this.reposition();\par
      this.showTime_ = Date.now();\par
\par
      this.eventTracker_ = new EventTracker;\par
      this.eventTracker_.add(window, 'resize', this.reposition.bind(this));\par
\par
      var doc = this.ownerDocument;\par
      this.eventTracker_.add(doc, 'keydown', this, true);\par
      this.eventTracker_.add(doc, 'mousedown', this, true);\par
    \},\par
\par
    /**\par
     * Hides the bubble from view.\par
     */\par
    hide: function() \{\par
      this.hidden = true;\par
      this.eventTracker_.removeAll();\par
      this.parentNode.removeChild(this);\par
    \},\par
\par
    /**\par
     * Handles keydown and mousedown events, dismissing the bubble if\par
     * necessary.\par
     * @param \{Event\} e The event.\par
     */\par
    handleEvent: function(e) \{\par
      switch (e.type) \{\par
        case 'keydown': \{\par
          if (e.keyCode == 27)  // Esc\par
            this.hide();\par
          break;\par
        \}\par
        case 'mousedown': \{\par
          if (e.target == this.querySelector('.bubble-close')) \{\par
            this.handleCloseEvent_();\par
          \} else if (!this.contains(e.target)) \{\par
            if (Date.now() - this.showTime_ < this.deactivateToDismissDelay_)\par
              return;\par
            this.hide();\par
          \} else \{\par
            return;\par
          \}\par
          break;\par
        \}\par
      \}\par
    \},\par
  \};\par
\par
  return \{\par
    ArrowLocation : ArrowLocation,\par
    Bubble : Bubble,\par
    BubbleAlignment : BubbleAlignment\par
  \};\par
\});\par
</script>\par
<script>// Copyright (c) 2012 The Chromium Authors. All rights reserved.\par
// Use of this source code is governed by a BSD-style license that can be\par
// found in the LICENSE file.\par
\par
/**\par
 * @fileoverview Card slider implementation. Allows you to create interactions\par
 * that have items that can slide left to right to reveal additional items.\par
 * Works by adding the necessary event handlers to a specific DOM structure\par
 * including a frame, container and cards.\par
 * - The frame defines the boundary of one item. Each card will be expanded to\par
 *   fill the width of the frame. This element is also overflow hidden so that\par
 *   the additional items left / right do not trigger horizontal scrolling.\par
 * - The container is what all the touch events are attached to. This element\par
 *   will be expanded to be the width of all cards.\par
 * - The cards are the individual viewable items. There should be one card for\par
 *   each item in the list. Only one card will be visible at a time. Two cards\par
 *   will be visible while you are transitioning between cards.\par
 *\par
 * This class is designed to work well on any hardware-accelerated touch device.\par
 * It should still work on pre-hardware accelerated devices it just won't feel\par
 * very good. It should also work well with a mouse.\par
 */\par
\par
// Use an anonymous function to enable strict mode just for this file (which\par
// will be concatenated with other files when embedded in Chrome\par
cr.define('cr.ui', function() \{\par
  'use strict';\par
\par
  /**\par
   * @constructor\par
   * @param \{!Element\} frame The bounding rectangle that cards are visible in.\par
   * @param \{!Element\} container The surrounding element that will have event\par
   *     listeners attached to it.\par
   * @param \{number\} cardWidth The width of each card should have.\par
   */\par
  function CardSlider(frame, container, cardWidth) \{\par
    /**\par
     * @type \{!Element\}\par
     * @private\par
     */\par
    this.frame_ = frame;\par
\par
    /**\par
     * @type \{!Element\}\par
     * @private\par
     */\par
    this.container_ = container;\par
\par
    /**\par
     * Array of card elements.\par
     * @type \{!Array.<!Element>\}\par
     * @private\par
     */\par
    this.cards_ = [];\par
\par
    /**\par
     * Index of currently shown card.\par
     * @type \{number\}\par
     * @private\par
     */\par
    this.currentCard_ = -1;\par
\par
    /**\par
     * @type \{number\}\par
     * @private\par
     */\par
    this.cardWidth_ = cardWidth;\par
\par
    /**\par
     * @type \{!cr.ui.TouchHandler\}\par
     * @private\par
     */\par
    this.touchHandler_ = new cr.ui.TouchHandler(this.container_);\par
  \}\par
\par
\par
  /**\par
   * The time to transition between cards when animating. Measured in ms.\par
   * @type \{number\}\par
   * @private\par
   * @const\par
   */\par
  CardSlider.TRANSITION_TIME_ = 200;\par
\par
\par
  /**\par
   * The minimum velocity required to transition cards if they did not drag past\par
   * the halfway point between cards. Measured in pixels / ms.\par
   * @type \{number\}\par
   * @private\par
   * @const\par
   */\par
  CardSlider.TRANSITION_VELOCITY_THRESHOLD_ = 0.2;\par
\par
\par
  CardSlider.prototype = \{\par
    /**\par
     * The current left offset of the container relative to the frame.\par
     * @type \{number\}\par
     * @private\par
     */\par
    currentLeft_: 0,\par
\par
    /**\par
     * Initialize all elements and event handlers. Must call after construction\par
     * and before usage.\par
     */\par
    initialize: function() \{\par
      var view = this.container_.ownerDocument.defaultView;\par
      assert(view.getComputedStyle(this.container_).display == '-webkit-box',\par
          'Container should be display -webkit-box.');\par
      assert(view.getComputedStyle(this.frame_).overflow == 'hidden',\par
          'Frame should be overflow hidden.');\par
      assert(view.getComputedStyle(this.container_).position == 'static',\par
          'Container should be position static.');\par
\par
      this.updateCardWidths_();\par
\par
      this.mouseWheelScrollAmount_ = 0;\par
      this.mouseWheelCardSelected_ = false;\par
      this.mouseWheelIsContinuous_ = false;\par
      this.scrollClearTimeout_ = null;\par
      this.frame_.addEventListener('mousewheel',\par
                                   this.onMouseWheel_.bind(this));\par
      this.container_.addEventListener(\par
          'webkitTransitionEnd', this.onWebkitTransitionEnd_.bind(this));\par
\par
      // Also support touch events in case a touch screen happens to be\par
      // available.  Ideally we would support touch events whenever they\par
      // are fired, but for now restrict this extra code to when we know\par
      // we want to support touch input.\par
      if (cr.isTouchOptimized) \{\par
        var TouchHandler = cr.ui.TouchHandler;\par
        this.container_.addEventListener(TouchHandler.EventType.TOUCH_START,\par
                                         this.onTouchStart_.bind(this));\par
        this.container_.addEventListener(TouchHandler.EventType.DRAG_START,\par
                                         this.onDragStart_.bind(this));\par
        this.container_.addEventListener(TouchHandler.EventType.DRAG_MOVE,\par
                                         this.onDragMove_.bind(this));\par
        this.container_.addEventListener(TouchHandler.EventType.DRAG_END,\par
                                         this.onDragEnd_.bind(this));\par
\par
        this.touchHandler_.enable(/* opt_capture */ false);\par
      \}\par
    \},\par
\par
    /**\par
     * Use in cases where the width of the frame has changed in order to update\par
     * the width of cards. For example should be used when orientation changes\par
     * in full width sliders.\par
     * @param \{number\} newCardWidth Width all cards should have, in pixels.\par
     */\par
    resize: function(newCardWidth) \{\par
      if (newCardWidth != this.cardWidth_) \{\par
        this.cardWidth_ = newCardWidth;\par
\par
        this.updateCardWidths_();\par
\par
        // Must upate the transform on the container to show the correct card.\par
        this.transformToCurrentCard_();\par
      \}\par
    \},\par
\par
    /**\par
     * Sets the cards used. Can be called more than once to switch card sets.\par
     * @param \{!Array.<!Element>\} cards The individual viewable cards.\par
     * @param \{number\} index Index of the card to in the new set of cards to\par
     *     navigate to.\par
     */\par
    setCards: function(cards, index) \{\par
      assert(index >= 0 && index < cards.length,\par
          'Invalid index in CardSlider#setCards');\par
      this.cards_ = cards;\par
\par
      this.updateCardWidths_();\par
\par
      // Jump to the given card index.\par
      this.selectCard(index);\par
    \},\par
\par
    /**\par
     * Updates the width of each card.\par
     * @private\par
     */\par
    updateCardWidths_: function() \{\par
      for (var i = 0, card; card = this.cards_[i]; i++)\par
        card.style.width = this.cardWidth_ + 'px';\par
    \},\par
\par
    /**\par
     * Returns the index of the current card.\par
     * @return \{number\} index of the current card.\par
     */\par
    get currentCard() \{\par
      return this.currentCard_;\par
    \},\par
\par
    /**\par
     * Allows setting the current card index.\par
     * @param \{number\} index A new index to set the current index to.\par
     * @return \{number\} The new index after having been set.\par
     */\par
    set currentCard(index) \{\par
      return (this.currentCard_ = index);\par
    \},\par
\par
    /**\par
     * Returns the number of cards.\par
     * @return \{number\} number of cards.\par
     */\par
    get cardCount() \{\par
      return this.cards_.length;\par
    \},\par
\par
    /**\par
     * Returns the current card itself.\par
     * @return \{!Element\} the currently shown card.\par
     */\par
    get currentCardValue() \{\par
      return this.cards_[this.currentCard_];\par
    \},\par
\par
    /**\par
     * Handle horizontal scrolls to flip between pages.\par
     * @private\par
     */\par
    onMouseWheel_: function(e) \{\par
      if (e.wheelDeltaX == 0)\par
        return;\par
\par
      // Prevent OS X 10.7+ history swiping on the NTP.\par
      e.preventDefault();\par
\par
      // Continuous devices such as an Apple Touchpad or Apple MagicMouse will\par
      // send arbitrary delta values. Conversly, standard mousewheels will\par
      // send delta values in increments of 120.  (There is of course a small\par
      // chance we mistake a continuous device for a non-continuous device.\par
      // Unfortunately there isn't a better way to do this until real touch\par
      // events are available to desktop clients.)\par
      var DISCRETE_DELTA = 120;\par
      if (e.wheelDeltaX % DISCRETE_DELTA)\par
        this.mouseWheelIsContinuous_ = true;\par
\par
      if (this.mouseWheelIsContinuous_) \{\par
        // For continuous devices, detect a page swipe when the accumulated\par
        // delta matches a pre-defined threshhold.  After changing the page,\par
        // ignore wheel events for a short time before repeating this process.\par
        if (this.mouseWheelCardSelected_) return;\par
        this.mouseWheelScrollAmount_ += e.wheelDeltaX;\par
        if (Math.abs(this.mouseWheelScrollAmount_) >= 600) \{\par
          var pagesToScroll = this.mouseWheelScrollAmount_ > 0 ? 1 : -1;\par
          if (!isRTL())\par
            pagesToScroll *= -1;\par
          var newCardIndex = this.currentCard + pagesToScroll;\par
          newCardIndex = Math.min(this.cards_.length - 1,\par
                                  Math.max(0, newCardIndex));\par
          this.selectCard(newCardIndex, true);\par
          this.mouseWheelCardSelected_ = true;\par
        \}\par
      \} else \{\par
        // For discrete devices, consider each wheel tick a page change.\par
        var pagesToScroll = e.wheelDeltaX / DISCRETE_DELTA;\par
        if (!isRTL())\par
          pagesToScroll *= -1;\par
        var newCardIndex = this.currentCard + pagesToScroll;\par
        newCardIndex = Math.min(this.cards_.length - 1,\par
                                Math.max(0, newCardIndex));\par
        this.selectCard(newCardIndex, true);\par
      \}\par
\par
      // We got a mouse wheel event, so cancel any pending scroll wheel timeout.\par
      if (this.scrollClearTimeout_ != null)\par
        clearTimeout(this.scrollClearTimeout_);\par
      // If we didn't use up all the scroll, hold onto it for a little bit, but\par
      // drop it after a delay.\par
      if (this.mouseWheelScrollAmount_ != 0) \{\par
        this.scrollClearTimeout_ =\par
            setTimeout(this.clearMouseWheelScroll_.bind(this), 500);\par
      \}\par
    \},\par
\par
    /**\par
     * Resets the amount of horizontal scroll we've seen to 0. See\par
     * onMouseWheel_.\par
     * @private\par
     */\par
    clearMouseWheelScroll_: function() \{\par
      this.mouseWheelScrollAmount_ = 0;\par
      this.mouseWheelCardSelected_ = false;\par
    \},\par
\par
    /**\par
     * Handles the ends of -webkit-transitions on -webkit-transform (animated\par
     * card switches).\par
     * @param \{Event\} e The webkitTransitionEnd event.\par
     * @private\par
     */\par
    onWebkitTransitionEnd_: function(e) \{\par
      // Ignore irrelevant transitions that might bubble up.\par
      if (e.target !== this.container_ ||\par
          e.propertyName != '-webkit-transform') \{\par
        return;\par
      \}\par
      this.fireChangeEndedEvent_(true);\par
    \},\par
\par
    /**\par
     * Dispatches a simple event to tell subscribers we're done moving to the\par
     * newly selected card.\par
     * @param \{boolean\} wasAnimated whether or not the change was animated.\par
     * @private\par
     */\par
    fireChangeEndedEvent_: function(wasAnimated) \{\par
      var e = document.createEvent('Event');\par
      e.initEvent('cardSlider:card_change_ended', true, true);\par
      e.cardSlider = this;\par
      e.changedTo = this.currentCard_;\par
      e.wasAnimated = wasAnimated;\par
      this.container_.dispatchEvent(e);\par
    \},\par
\par
    /**\par
     * Add a card to the card slider at a particular index. If the card being\par
     * added is inserted in front of the current card, cardSlider.currentCard\par
     * will be adjusted accordingly (to current card + 1).\par
     * @param \{!Node\} card A card that will be added to the card slider.\par
     * @param \{number\} index An index at which the given |card| should be\par
     *     inserted. Must be positive and less than the number of cards.\par
     */\par
    addCardAtIndex: function(card, index) \{\par
      assert(card instanceof Node, '|card| isn\\'t a Node');\par
      this.assertValidIndex_(index);\par
      this.cards_ = Array.prototype.concat.call(\par
          this.cards_.slice(0, index), card, this.cards_.slice(index));\par
\par
      if (this.currentCard_ == -1)\par
        this.currentCard_ = 0;\par
      else if (index <= this.currentCard_)\par
        this.selectCard(this.currentCard_ + 1, false, true);\par
\par
      this.fireAddedEvent_(card, index);\par
    \},\par
\par
    /**\par
     * Append a card to the end of the list.\par
     * @param \{!Node\} card A card to add at the end of the card slider.\par
     */\par
    appendCard: function(card) \{\par
      assert(card instanceof Node, '|card| isn\\'t a Node');\par
      this.cards_.push(card);\par
      this.fireAddedEvent_(card, this.cards_.length - 1);\par
    \},\par
\par
    /**\par
     * Dispatches a simple event to tell interested subscribers that a card was\par
     * added to this card slider.\par
     * @param \{Node\} card The recently added card.\par
     * @param \{number\} index The position of the newly added card.\par
     * @private\par
     */\par
    fireAddedEvent_: function(card, index) \{\par
      this.assertValidIndex_(index);\par
      var e = document.createEvent('Event');\par
      e.initEvent('cardSlider:card_added', true, true);\par
      e.addedIndex = index;\par
      e.addedCard = card;\par
      this.container_.dispatchEvent(e);\par
    \},\par
\par
    /**\par
     * Removes a card by index from the card slider. If the card to be removed\par
     * is the current card or in front of the current card, the current card\par
     * will be updated (to current card - 1).\par
     * @param \{!Node\} card A card to be removed.\par
     */\par
    removeCard: function(card) \{\par
      assert(card instanceof Node, '|card| isn\\'t a Node');\par
      this.removeCardAtIndex(this.cards_.indexOf(card));\par
    \},\par
\par
    /**\par
     * Removes a card by index from the card slider. If the card to be removed\par
     * is the current card or in front of the current card, the current card\par
     * will be updated (to current card - 1).\par
     * @param \{number\} index The index of the tile that should be removed.\par
     */\par
    removeCardAtIndex: function(index) \{\par
      this.assertValidIndex_(index);\par
      var removed = this.cards_.splice(index, 1).pop();\par
\par
      if (this.cards_.length == 0)\par
        this.currentCard_ = -1;\par
      else if (index < this.currentCard_)\par
        this.selectCard(this.currentCard_ - 1, false, true);\par
\par
      this.fireRemovedEvent_(removed, index);\par
    \},\par
\par
    /**\par
     * Dispatches a cardSlider:card_removed event so interested subscribers know\par
     * when a card was removed from this card slider.\par
     * @param \{Node\} card The recently removed card.\par
     * @param \{number\} index The index of the card before it was removed.\par
     * @private\par
     */\par
    fireRemovedEvent_: function(card, index) \{\par
      var e = document.createEvent('Event');\par
      e.initEvent('cardSlider:card_removed', true, true);\par
      e.removedCard = card;\par
      e.removedIndex = index;\par
      this.container_.dispatchEvent(e);\par
    \},\par
\par
    /**\par
     * Checks the the given |index| exists in this.cards_.\par
     * @param \{number\} index An index to check.\par
     * @private\par
     */\par
    assertValidIndex_: function(index) \{\par
      assert(index >= 0 && index < this.cards_.length);\par
    \},\par
\par
    /**\par
     * Selects a new card, ensuring that it is a valid index, transforming the\par
     * view and possibly calling the change card callback.\par
     * @param \{number\} newCardIndex Index of card to show.\par
     * @param \{boolean=\} opt_animate If true will animate transition from\par
     *     current position to new position.\par
     * @param \{boolean=\} opt_dontNotify If true, don't tell subscribers that\par
     *     we've changed cards.\par
     */\par
    selectCard: function(newCardIndex, opt_animate, opt_dontNotify) \{\par
      this.assertValidIndex_(newCardIndex);\par
\par
      var previousCard = this.currentCardValue;\par
      var isChangingCard =\par
          !this.cards_[newCardIndex].classList.contains('selected-card');\par
\par
      if (isChangingCard) \{\par
        if (previousCard)\par
          previousCard.classList.remove('selected-card');\par
        this.currentCard_ = newCardIndex;\par
        this.currentCardValue.classList.add('selected-card');\par
      \}\par
\par
      var willTransitionHappen = this.transformToCurrentCard_(opt_animate);\par
\par
      if (isChangingCard && !opt_dontNotify) \{\par
        var event = document.createEvent('Event');\par
        event.initEvent('cardSlider:card_changed', true, true);\par
        event.cardSlider = this;\par
        event.wasAnimated = !!opt_animate;\par
        this.container_.dispatchEvent(event);\par
\par
        // We also dispatch an event on the cards themselves.\par
        if (previousCard) \{\par
          cr.dispatchSimpleEvent(previousCard, 'carddeselected',\par
                                 true, true);\par
        \}\par
        cr.dispatchSimpleEvent(this.currentCardValue, 'cardselected',\par
                               true, true);\par
      \}\par
\par
      // If we're not changing, animated, or transitioning, fire a\par
      // cardSlider:card_change_ended event right away.\par
      if ((!isChangingCard || !opt_animate || !willTransitionHappen) &&\par
          !opt_dontNotify) \{\par
        this.fireChangeEndedEvent_(false);\par
      \}\par
    \},\par
\par
    /**\par
     * Selects a card from the stack. Passes through to selectCard.\par
     * @param \{Node\} newCard The card that should be selected.\par
     * @param \{boolean=\} opt_animate Whether to animate.\par
     */\par
    selectCardByValue: function(newCard, opt_animate) \{\par
      var i = this.cards_.indexOf(newCard);\par
      assert(i != -1);\par
      this.selectCard(i, opt_animate);\par
    \},\par
\par
    /**\par
     * Centers the view on the card denoted by this.currentCard. Can either\par
     * animate to that card or snap to it.\par
     * @param \{boolean=\} opt_animate If true will animate transition from\par
     *     current position to new position.\par
     * @return \{boolean\} Whether or not a transformation was necessary.\par
     * @private\par
     */\par
    transformToCurrentCard_: function(opt_animate) \{\par
      var prevLeft = this.currentLeft_;\par
      this.currentLeft_ = -this.cardWidth_ *\par
          (isRTL() ? this.cards_.length - this.currentCard - 1 :\par
                     this.currentCard);\par
\par
      // If there's no change, return something to let the caller know there\par
      // won't be a transition occuring.\par
      if (prevLeft == this.currentLeft_)\par
        return false;\par
\par
      // Animate to the current card, which will either transition if the\par
      // current card is new, or reset the existing card if we didn't drag\par
      // enough to change cards.\par
      var transition = '';\par
      if (opt_animate) \{\par
        transition = '-webkit-transform ' + CardSlider.TRANSITION_TIME_ +\par
                     'ms ease-in-out';\par
      \}\par
      this.container_.style.WebkitTransition = transition;\par
      this.translateTo_(this.currentLeft_);\par
\par
      return true;\par
    \},\par
\par
    /**\par
     * Moves the view to the specified position.\par
     * @param \{number\} x Horizontal position to move to.\par
     * @private\par
     */\par
    translateTo_: function(x) \{\par
      // We use a webkitTransform to slide because this is GPU accelerated on\par
      // Chrome and iOS.  Once Chrome does GPU acceleration on the position\par
      // fixed-layout elements we could simply set the element's position to\par
      // fixed and modify 'left' instead.\par
      this.container_.style.WebkitTransform = 'translate3d(' + x + 'px, 0, 0)';\par
    \},\par
\par
    /* Touch ******************************************************************/\par
\par
    /**\par
     * Clear any transition that is in progress and enable dragging for the\par
     * touch.\par
     * @param \{!cr.ui.TouchHandler.Event\} e The TouchHandler event.\par
     * @private\par
     */\par
    onTouchStart_: function(e) \{\par
      this.container_.style.WebkitTransition = '';\par
      e.enableDrag = true;\par
    \},\par
\par
    /**\par
     * Tell the TouchHandler that dragging is acceptable when the user begins by\par
     * scrolling horizontally.\par
     * @param \{!cr.ui.TouchHandler.Event\} e The TouchHandler event.\par
     * @private\par
     */\par
    onDragStart_: function(e) \{\par
      e.enableDrag = Math.abs(e.dragDeltaX) > Math.abs(e.dragDeltaY);\par
    \},\par
\par
    /**\par
     * On each drag move event reposition the container appropriately so the\par
     * cards look like they are sliding.\par
     * @param \{!cr.ui.TouchHandler.Event\} e The TouchHandler event.\par
     * @private\par
     */\par
    onDragMove_: function(e) \{\par
      var deltaX = e.dragDeltaX;\par
      // If dragging beyond the first or last card then apply a backoff so the\par
      // dragging feels stickier than usual.\par
      if (!this.currentCard && deltaX > 0 ||\par
          this.currentCard == (this.cards_.length - 1) && deltaX < 0) \{\par
        deltaX /= 2;\par
      \}\par
      this.translateTo_(this.currentLeft_ + deltaX);\par
    \},\par
\par
    /**\par
     * On drag end events we may want to transition to another card, depending\par
     * on the ending position of the drag and the velocity of the drag.\par
     * @param \{!cr.ui.TouchHandler.Event\} e The TouchHandler event.\par
     * @private\par
     */\par
    onDragEnd_: function(e) \{\par
      var deltaX = e.dragDeltaX;\par
      var velocity = this.touchHandler_.getEndVelocity().x;\par
      var newX = this.currentLeft_ + deltaX;\par
      var newCardIndex = Math.round(-newX / this.cardWidth_);\par
\par
      if (newCardIndex == this.currentCard && Math.abs(velocity) >\par
          CardSlider.TRANSITION_VELOCITY_THRESHOLD_) \{\par
        // If the drag wasn't far enough to change cards but the velocity was\par
        // high enough to transition anyways. If the velocity is to the left\par
        // (negative) then the user wishes to go right (card +1).\par
        newCardIndex += velocity > 0 ? -1 : 1;\par
      \}\par
\par
      this.selectCard(newCardIndex, /* animate */ true);\par
    \},\par
\par
    /**\par
     * Cancel any current touch/slide as if we saw a touch end\par
     */\par
    cancelTouch: function() \{\par
      // Stop listening to any current touch\par
      this.touchHandler_.cancelTouch();\par
\par
      // Ensure we're at a card bounary\par
      this.transformToCurrentCard_(true);\par
    \},\par
  \};\par
\par
  return \{\par
    CardSlider: CardSlider\par
  \};\par
\});\par
</script>\par
<script>// Copyright (c) 2012 The Chromium Authors. All rights reserved.\par
// Use of this source code is governed by a BSD-style license that can be\par
// found in the LICENSE file.\par
\par
cr.define('cr.ui', function() \{\par
\par
  const Menu = cr.ui.Menu;\par
\par
  /**\par
   * Handles context menus.\par
   * @constructor\par
   */\par
  function ContextMenuHandler() \{\}\par
\par
  ContextMenuHandler.prototype = \{\par
\par
    /**\par
     * The menu that we are currently showing.\par
     * @type \{cr.ui.Menu\}\par
     */\par
    menu_: null,\par
    get menu() \{\par
      return this.menu_;\par
    \},\par
\par
    /**\par
     * Shows a menu as a context menu.\par
     * @param \{!Event\} e The event triggering the show (usally a contextmenu\par
     *     event).\par
     * @param \{!cr.ui.Menu\} menu The menu to show.\par
     */\par
    showMenu: function(e, menu) \{\par
      this.menu_ = menu;\par
\par
      menu.style.display = 'block';\par
      // when the menu is shown we steal all keyboard events.\par
      var doc = menu.ownerDocument;\par
      doc.addEventListener('keydown', this, true);\par
      doc.addEventListener('mousedown', this, true);\par
      doc.addEventListener('blur', this, true);\par
      doc.defaultView.addEventListener('resize', this);\par
      menu.addEventListener('contextmenu', this);\par
      menu.addEventListener('activate', this);\par
      this.positionMenu_(e, menu);\par
    \},\par
\par
    /**\par
     * Hide the currently shown menu.\par
     */\par
    hideMenu: function() \{\par
      var menu = this.menu;\par
      if (!menu)\par
        return;\par
\par
      menu.style.display = 'none';\par
      var doc = menu.ownerDocument;\par
      doc.removeEventListener('keydown', this, true);\par
      doc.removeEventListener('mousedown', this, true);\par
      doc.removeEventListener('blur', this, true);\par
      doc.defaultView.removeEventListener('resize', this);\par
      menu.removeEventListener('contextmenu', this);\par
      menu.removeEventListener('activate', this);\par
      menu.selectedIndex = -1;\par
      this.menu_ = null;\par
\par
      // On windows we might hide the menu in a right mouse button up and if\par
      // that is the case we wait some short period before we allow the menu\par
      // to be shown again.\par
      this.hideTimestamp_ = cr.isWindows ? Date.now() : 0;\par
    \},\par
\par
    /**\par
     * Positions the menu\par
     * @param \{!Event\} e The event object triggering the showing.\par
     * @param \{!cr.ui.Menu\} menu The menu to position.\par
     * @private\par
     */\par
    positionMenu_: function(e, menu) \{\par
      // TODO(arv): Handle scrolled documents when needed.\par
\par
      var element = e.currentTarget;\par
      var x, y;\par
      // When the user presses the context menu key (on the keyboard) we need\par
      // to detect this.\par
      if (this.keyIsDown_) \{\par
        var rect = element.getRectForContextMenu ?\par
                       element.getRectForContextMenu() :\par
                       element.getBoundingClientRect();\par
        var offset = Math.min(rect.width, rect.height) / 2;\par
        x = rect.left + offset;\par
        y = rect.top + offset;\par
      \} else \{\par
        x = e.clientX;\par
        y = e.clientY;\par
      \}\par
\par
      cr.ui.positionPopupAtPoint(x, y, menu);\par
    \},\par
\par
    /**\par
     * Handles event callbacks.\par
     * @param \{!Event\} e The event object.\par
     */\par
    handleEvent: function(e) \{\par
      // Keep track of keydown state so that we can use that to determine the\par
      // reason for the contextmenu event.\par
      switch (e.type) \{\par
        case 'keydown':\par
          this.keyIsDown_ = !e.ctrlKey && !e.altKey &&\par
              // context menu key or Shift-F10\par
              (e.keyCode == 93 && !e.shiftKey ||\par
               e.keyIdentifier == 'F10' && e.shiftKey);\par
          break;\par
\par
        case 'keyup':\par
          this.keyIsDown_ = false;\par
          break;\par
      \}\par
\par
      // Context menu is handled even when we have no menu.\par
      if (e.type != 'contextmenu' && !this.menu)\par
        return;\par
\par
      switch (e.type) \{\par
        case 'mousedown':\par
          if (!this.menu.contains(e.target))\par
            this.hideMenu();\par
          else\par
            e.preventDefault();\par
          break;\par
        case 'keydown':\par
          // keyIdentifier does not report 'Esc' correctly\par
          if (e.keyCode == 27 /* Esc */) \{\par
            this.hideMenu();\par
            e.stopPropagation();\par
            e.preventDefault();\par
\par
          // If the menu is visible we let it handle all the keyboard events.\par
          \} else if (this.menu) \{\par
            this.menu.handleKeyDown(e);\par
            e.preventDefault();\par
            e.stopPropagation();\par
          \}\par
          break;\par
\par
        case 'activate':\par
        case 'blur':\par
        case 'resize':\par
          this.hideMenu();\par
          break;\par
\par
        case 'contextmenu':\par
          if ((!this.menu || !this.menu.contains(e.target)) &&\par
              (!this.hideTimestamp_ || Date.now() - this.hideTimestamp_ > 50))\par
            this.showMenu(e, e.currentTarget.contextMenu);\par
          e.preventDefault();\par
          // Don't allow elements further up in the DOM to show their menus.\par
          e.stopPropagation();\par
          break;\par
      \}\par
    \},\par
\par
    /**\par
     * Adds a contextMenu property to an element or element class.\par
     * @param \{!Element|!Function\} element The element or class to add the\par
     *     contextMenu property to.\par
     */\par
    addContextMenuProperty: function(element) \{\par
      if (typeof element == 'function')\par
        element = element.prototype;\par
\par
      element.__defineGetter__('contextMenu', function() \{\par
        return this.contextMenu_;\par
      \});\par
      element.__defineSetter__('contextMenu', function(menu) \{\par
        var oldContextMenu = this.contextMenu;\par
\par
        if (typeof menu == 'string' && menu[0] == '#') \{\par
          menu = this.ownerDocument.getElementById(menu.slice(1));\par
          cr.ui.decorate(menu, Menu);\par
        \}\par
\par
        if (menu === oldContextMenu)\par
          return;\par
\par
        if (oldContextMenu && !menu) \{\par
          this.removeEventListener('contextmenu', contextMenuHandler);\par
          this.removeEventListener('keydown', contextMenuHandler);\par
          this.removeEventListener('keyup', contextMenuHandler);\par
        \}\par
        if (menu && !oldContextMenu) \{\par
          this.addEventListener('contextmenu', contextMenuHandler);\par
          this.addEventListener('keydown', contextMenuHandler);\par
          this.addEventListener('keyup', contextMenuHandler);\par
        \}\par
\par
        this.contextMenu_ = menu;\par
\par
        if (menu && menu.id)\par
          this.setAttribute('contextmenu', '#' + menu.id);\par
\par
        cr.dispatchPropertyChange(this, 'contextMenu', menu, oldContextMenu);\par
      \});\par
\par
      if (!element.getRectForContextMenu) \{\par
        /**\par
         * @return \{!ClientRect\} The rect to use for positioning the context\par
         *     menu when the context menu is not opened using a mouse position.\par
         */\par
        element.getRectForContextMenu = function() \{\par
          return this.getBoundingClientRect();\par
        \};\par
      \}\par
    \},\par
\par
    /**\par
     * Sets the given contextMenu to the given element. A contextMenu property\par
     * would be added if necessary.\par
     * @param \{!Element\} element The element or class to set the contextMenu to.\par
     * @param \{!cr.ui.Menu\} contextMenu The contextMenu property to be set.\par
     */\par
    setContextMenu: function(element, contextMenu) \{\par
      if (!element.contextMenu)\par
        this.addContextMenuProperty(element);\par
      element.contextMenu = contextMenu;\par
    \}\par
  \};\par
\par
  /**\par
   * The singleton context menu handler.\par
   * @type \{!ContextMenuHandler\}\par
   */\par
  var contextMenuHandler = new ContextMenuHandler;\par
\par
  // Export\par
  return \{\par
    contextMenuHandler: contextMenuHandler\par
  \};\par
\});\par
</script>\par
<script>// Copyright (c) 2011 The Chromium Authors. All rights reserved.\par
// Use of this source code is governed by a BSD-style license that can be\par
// found in the LICENSE file.\par
\par
/**\par
 * @fileoverview DragWrapper\par
 * A class for simplifying HTML5 drag and drop. Classes should use this to\par
 * handle the nitty gritty of nested drag enters and leaves.\par
 */\par
cr.define('cr.ui', function() \{\par
  /**\par
   * Creates a DragWrapper which listens for drag target events on |target| and\par
   * delegates event handling to |handler|. The |handler| must implement:\par
   *   shouldAcceptDrag\par
   *   doDragEnter\par
   *   doDragLeave\par
   *   doDragOver\par
   *   doDrop\par
   */\par
  function DragWrapper(target, handler) \{\par
    this.initialize(target, handler);\par
  \}\par
\par
  DragWrapper.prototype = \{\par
    initialize: function(target, handler) \{\par
      target.addEventListener('dragenter',\par
                              this.onDragEnter_.bind(this));\par
      target.addEventListener('dragover', this.onDragOver_.bind(this));\par
      target.addEventListener('drop', this.onDrop_.bind(this));\par
      target.addEventListener('dragleave', this.onDragLeave_.bind(this));\par
\par
      this.target_ = target;\par
      this.handler_ = handler;\par
    \},\par
\par
    /**\par
     * The number of un-paired dragenter events that have fired on |this|. This\par
     * is incremented by |onDragEnter_| and decremented by |onDragLeave_|. This\par
     * is necessary because dragging over child widgets will fire additional\par
     * enter and leave events on |this|. A non-zero value does not necessarily\par
     * indicate that |isCurrentDragTarget()| is true.\par
     * @type \{number\}\par
     * @private\par
     */\par
    dragEnters_: 0,\par
\par
    /**\par
     * Whether the tile page is currently being dragged over with data it can\par
     * accept.\par
     * @type \{boolean\}\par
     */\par
    get isCurrentDragTarget() \{\par
      return this.target_.classList.contains('drag-target');\par
    \},\par
\par
    /**\par
     * Handler for dragenter events fired on |target_|.\par
     * @param \{Event\} e A MouseEvent for the drag.\par
     * @private\par
     */\par
    onDragEnter_: function(e) \{\par
      if (++this.dragEnters_ == 1) \{\par
        if (this.handler_.shouldAcceptDrag(e)) \{\par
          this.target_.classList.add('drag-target');\par
          this.handler_.doDragEnter(e);\par
        \}\par
      \} else \{\par
        // Sometimes we'll get an enter event over a child element without an\par
        // over event following it. In this case we have to still call the\par
        // drag over handler so that we make the necessary updates (one visible\par
        // symptom of not doing this is that the cursor's drag state will\par
        // flicker during drags).\par
        this.onDragOver_(e);\par
      \}\par
    \},\par
\par
    /**\par
     * Thunk for dragover events fired on |target_|.\par
     * @param \{Event\} e A MouseEvent for the drag.\par
     * @private\par
     */\par
    onDragOver_: function(e) \{\par
      if (!this.target_.classList.contains('drag-target'))\par
        return;\par
      this.handler_.doDragOver(e);\par
    \},\par
\par
    /**\par
     * Thunk for drop events fired on |target_|.\par
     * @param \{Event\} e A MouseEvent for the drag.\par
     * @private\par
     */\par
    onDrop_: function(e) \{\par
      this.dragEnters_ = 0;\par
      if (!this.target_.classList.contains('drag-target'))\par
        return;\par
      this.target_.classList.remove('drag-target');\par
      this.handler_.doDrop(e);\par
    \},\par
\par
    /**\par
     * Thunk for dragleave events fired on |target_|.\par
     * @param \{Event\} e A MouseEvent for the drag.\par
     * @private\par
     */\par
    onDragLeave_: function(e) \{\par
      if (--this.dragEnters_ > 0)\par
        return;\par
\par
      this.target_.classList.remove('drag-target');\par
      this.handler_.doDragLeave(e);\par
    \},\par
  \};\par
\par
  return \{\par
    DragWrapper: DragWrapper\par
  \};\par
\});\par
</script>\par
<script>// Copyright (c) 2012 The Chromium Authors. All rights reserved.\par
// Use of this source code is governed by a BSD-style license that can be\par
// found in the LICENSE file.\par
\par
// require: event_tracker.js\par
\par
cr.define('cr.ui', function() \{\par
  'use strict';\par
\par
  /**\par
   * ExpandableBubble is a free-floating compact informational bubble with an\par
   * arrow that points at a place of interest on the page. When clicked, the\par
   * bubble expands to show more of its content. Width of the bubble is the\par
   * width of the node it is overlapping when unexpanded. Expanded, it is of a\par
   * fixed width, but variable height. Currently the arrow is always positioned\par
   * at the bottom right and points down.\par
   * @constructor\par
   * @extends \{cr.ui.div\}\par
   */\par
  var ExpandableBubble = cr.ui.define('div');\par
\par
  ExpandableBubble.prototype = \{\par
    __proto__: HTMLDivElement.prototype,\par
\par
    /** @inheritDoc */\par
    decorate: function() \{\par
      this.className = 'expandable-bubble';\par
      this.innerHTML =\par
          '<div class="expandable-bubble-contents">' +\par
            '<div class="expandable-bubble-title"></div>' +\par
            '<div class="expandable-bubble-main" hidden></div>' +\par
          '</div>' +\par
          '<div class="expandable-bubble-close" hidden></div>';\par
\par
      this.hidden = true;\par
      this.bubbleSuppressed = false;\par
      this.handleCloseEvent = this.hide;\par
    \},\par
\par
    /**\par
     * Sets the title of the bubble. The title is always visible when the\par
     * bubble is visible.\par
     * @type \{Node\} An HTML element to set as the title.\par
     */\par
    set contentTitle(node) \{\par
      var bubbleTitle = this.querySelector('.expandable-bubble-title');\par
      bubbleTitle.textContent = '';\par
      bubbleTitle.appendChild(node);\par
    \},\par
\par
    /**\par
     * Sets the content node of the bubble. The content node is only visible\par
     * when the bubble is expanded.\par
     * @param \{Node\} An HTML element.\par
     */\par
    set content(node) \{\par
      var bubbleMain = this.querySelector('.expandable-bubble-main');\par
      bubbleMain.textContent = '';\par
      bubbleMain.appendChild(node);\par
    \},\par
\par
    /**\par
     * Sets the anchor node, i.e. the node that this bubble points at and\par
     * partially overlaps.\par
     * @param \{HTMLElement\} node The new anchor node.\par
     */\par
    set anchorNode(node) \{\par
      this.anchorNode_ = node;\par
\par
      if (!this.hidden)\par
        this.resizeAndReposition();\par
    \},\par
\par
    /**\par
     * Handles the close event which is triggered when the close button\par
     * is clicked. By default is set to this.hide.\par
     * @param \{function\} A function with no parameters\par
     */\par
    set handleCloseEvent(func) \{\par
      this.handleCloseEvent_ = func;\par
    \},\par
\par
    /**\par
     * Temporarily suppresses the bubble from view (and toggles it back).\par
     * 'Suppressed' and 'hidden' are two bubble states that both indicate that\par
     * the bubble should not be visible, but when you 'un-suppress' a bubble,\par
     * only a suppressed bubble becomes visible. This can be handy, for example,\par
     * if the user switches away from the app card (then we need to know which\par
     * bubbles to show (only the suppressed ones, not the hidden ones). Hiding\par
     * and un-hiding a bubble overrides the suppressed state (a bubble cannot\par
     * be suppressed but not hidden).\par
     */\par
    set suppressed(suppress) \{\par
      if (suppress) \{\par
        // If the bubble is already hidden, then we don't need to suppress it.\par
        if (this.hidden)\par
          return;\par
\par
        this.hidden = true;\par
      \} else if (this.bubbleSuppressed) \{\par
        this.hidden = false;\par
      \}\par
      this.bubbleSuppressed = suppress;\par
      this.resizeAndReposition(this);\par
    \},\par
\par
    /**\par
     * Updates the position of the bubble.\par
     * @private\par
     */\par
    reposition_: function() \{\par
      var clientRect = this.anchorNode_.getBoundingClientRect();\par
\par
      // Center bubble in collapsed mode (if it doesn't take up all the room we\par
      // have).\par
      var offset = 0;\par
      if (!this.expanded)\par
        offset = (clientRect.width - parseInt(this.style.width)) / 2;\par
      this.style.left = this.style.right = clientRect.left + offset + 'px';\par
\par
      var top = Math.max(0, clientRect.top - 4);\par
      this.style.top = this.expanded ?\par
          (top - this.offsetHeight + this.unexpandedHeight) + 'px' :\par
          top + 'px';\par
    \},\par
\par
    /**\par
     * Resizes the bubble and then repositions it.\par
     * @private\par
     */\par
    resizeAndReposition: function() \{\par
      var clientRect = this.anchorNode_.getBoundingClientRect();\par
      var width = clientRect.width;\par
\par
      var bubbleTitle = this.querySelector('.expandable-bubble-title');\par
      var closeElement = this.querySelector('.expandable-bubble-close');\par
      var closeWidth = this.expanded ? closeElement.clientWidth : 0;\par
      var margin = 15;\par
\par
      // Suppress the width style so we can get it to calculate its width.\par
      // We'll set the right width again when we are done.\par
      bubbleTitle.style.width = '';\par
\par
      if (this.expanded) \{\par
        // We always show the full title but never show less width than 250\par
        // pixels.\par
        var expandedWidth =\par
            Math.max(250, bubbleTitle.scrollWidth + closeWidth + margin);\par
        this.style.marginLeft = (width - expandedWidth) + 'px';\par
        width = expandedWidth;\par
      \} else \{\par
        var newWidth = Math.min(bubbleTitle.scrollWidth + margin, width);\par
        // If we've maxed out in width then apply the mask.\par
        this.masked = newWidth == width;\par
        width = newWidth;\par
        this.style.marginLeft = '0';\par
      \}\par
\par
      // Width is determined by the width of the title (when not expanded) but\par
      // capped to the width of the anchor node.\par
      this.style.width = width + 'px';\par
      bubbleTitle.style.width = Math.max(0, width - margin - closeWidth) + 'px';\par
\par
      // Also reposition the bubble -- dimensions have potentially changed.\par
      this.reposition_();\par
    \},\par
\par
    /*\par
     * Expand the bubble (bringing the full content into view).\par
     * @private\par
     */\par
    expandBubble_: function() \{\par
      this.querySelector('.expandable-bubble-main').hidden = false;\par
      this.querySelector('.expandable-bubble-close').hidden = false;\par
      this.expanded = true;\par
      this.resizeAndReposition();\par
    \},\par
\par
    /**\par
     * Collapse the bubble, hiding the main content and the close button.\par
     * This is automatically called when the window is resized.\par
     * @private\par
     */\par
    collapseBubble_: function() \{\par
      this.querySelector('.expandable-bubble-main').hidden = true;\par
      this.querySelector('.expandable-bubble-close').hidden = true;\par
      this.expanded = false;\par
      this.resizeAndReposition();\par
    \},\par
\par
    /**\par
     * The onclick handler for the notification (expands the bubble).\par
     * @param \{Event\} e The event.\par
     * @private\par
     */\par
    onNotificationClick_ : function(e) \{\par
      if (!this.contains(e.target))\par
        return;\par
\par
      if (!this.expanded) \{\par
        // Save the height of the unexpanded bubble, so we can make sure to\par
        // position it correctly (arrow points in the same location) after\par
        // we expand it.\par
        this.unexpandedHeight = this.offsetHeight;\par
      \}\par
\par
      this.expandBubble_();\par
    \},\par
\par
    /**\par
     * Shows the bubble. The bubble will start collapsed and expand when\par
     * clicked.\par
     */\par
    show: function() \{\par
      if (!this.hidden)\par
        return;\par
\par
      document.body.appendChild(this);\par
      this.hidden = false;\par
      this.resizeAndReposition();\par
\par
      this.eventTracker_ = new EventTracker;\par
      this.eventTracker_.add(window,\par
                             'load', this.resizeAndReposition.bind(this));\par
      this.eventTracker_.add(window,\par
                             'resize', this.resizeAndReposition.bind(this));\par
      this.eventTracker_.add(this, 'click', this.onNotificationClick_);\par
\par
      var doc = this.ownerDocument;\par
      this.eventTracker_.add(doc, 'keydown', this, true);\par
      this.eventTracker_.add(doc, 'mousedown', this, true);\par
    \},\par
\par
    /**\par
     * Hides the bubble from view.\par
     */\par
    hide: function() \{\par
      this.hidden = true;\par
      this.bubbleSuppressed = false;\par
      this.eventTracker_.removeAll();\par
      this.parentNode.removeChild(this);\par
    \},\par
\par
    /**\par
     * Handles keydown and mousedown events, dismissing the bubble if\par
     * necessary.\par
     * @param \{Event\} e The event.\par
     * @private\par
     */\par
    handleEvent: function(e) \{\par
      var handled = false;\par
      switch (e.type) \{\par
        case 'keydown':\par
          if (e.keyCode == 27) \{  // Esc.\par
            if (this.expanded) \{\par
              this.collapseBubble_();\par
              handled = true;\par
            \}\par
          \}\par
          break;\par
\par
        case 'mousedown':\par
          if (e.target == this.querySelector('.expandable-bubble-close')) \{\par
            this.handleCloseEvent_();\par
            handled = true;\par
          \} else if (!this.contains(e.target)) \{\par
            if (this.expanded) \{\par
              this.collapseBubble_();\par
              handled = true;\par
            \}\par
          \}\par
          break;\par
      \}\par
\par
      if (handled) \{\par
        // The bubble emulates a focus grab when expanded, so when we've\par
        // collapsed/hide the bubble we consider the event handles and don't\par
        // need to propagate it further.\par
        e.stopPropagation();\par
        e.preventDefault();\par
      \}\par
    \},\par
  \};\par
\par
  /**\par
   * Whether the bubble is expanded or not.\par
   * @type \{boolean\}\par
   */\par
  cr.defineProperty(ExpandableBubble, 'expanded', cr.PropertyKind.BOOL_ATTR);\par
\par
  /**\par
   * Whether the title needs to be masked out towards the right, which indicates\par
   * to the user that part of the text is clipped. This is only used when the\par
   * bubble is collapsed and the title doesn't fit because it is maxed out in\par
   * width within the anchored node.\par
   * @type \{boolean\}\par
   */\par
  cr.defineProperty(ExpandableBubble, 'masked', cr.PropertyKind.BOOL_ATTR);\par
\par
  return \{\par
    ExpandableBubble: ExpandableBubble\par
  \};\par
\});\par
</script>\par
<script>// Copyright (c) 2010 The Chromium Authors. All rights reserved.\par
// Use of this source code is governed by a BSD-style license that can be\par
// found in the LICENSE file.\par
\par
cr.define('cr.ui', function() \{\par
\par
  const MenuItem = cr.ui.MenuItem;\par
\par
  /**\par
   * Creates a new menu element.\par
   * @param \{Object=\} opt_propertyBag Optional properties.\par
   * @constructor\par
   * @extends \{HTMLMenuElement\}\par
   */\par
  var Menu = cr.ui.define('menu');\par
\par
  Menu.prototype = \{\par
    __proto__: HTMLMenuElement.prototype,\par
\par
    selectedIndex_: -1,\par
\par
    /**\par
     * Initializes the menu element.\par
     */\par
    decorate: function() \{\par
      this.addEventListener('mouseover', this.handleMouseOver_);\par
      this.addEventListener('mouseout', this.handleMouseOut_);\par
\par
      // Decorate the children as menu items.\par
      var children = this.children;\par
      for (var i = 0, child; child = children[i]; i++) \{\par
        cr.ui.decorate(child, MenuItem);\par
      \}\par
    \},\par
\par
    /**\par
     * Walks up the ancestors until a menu item belonging to this menu is found.\par
     * @param \{Element\} el\par
     * @return \{cr.ui.MenuItem\} The found menu item or null.\par
     * @private\par
     */\par
    findMenuItem_: function(el) \{\par
      while (el && el.parentNode != this) \{\par
        el = el.parentNode;\par
      \}\par
      return el;\par
    \},\par
\par
    /**\par
     * Handles mouseover events and selects the hovered item.\par
     * @param \{Event\} e The mouseover event.\par
     * @private\par
     */\par
    handleMouseOver_: function(e) \{\par
      var overItem = this.findMenuItem_(e.target);\par
      this.selectedItem = overItem;\par
    \},\par
\par
    /**\par
     * Handles mouseout events and deselects any selected item.\par
     * @param \{Event\} e The mouseout event.\par
     * @private\par
     */\par
    handleMouseOut_: function(e) \{\par
      this.selectedItem = null;\par
    \},\par
\par
    /**\par
     * The selected menu item or null if none.\par
     * @type \{cr.ui.MenuItem\}\par
     */\par
    get selectedItem() \{\par
      return this.children[this.selectedIndex];\par
    \},\par
    set selectedItem(item) \{\par
      var index = Array.prototype.indexOf.call(this.children, item);\par
      this.selectedIndex = index;\par
    \},\par
\par
    /**\par
     * This is the function that handles keyboard navigation. This is usually\par
     * called by the element responsible for managing the menu.\par
     * @param \{Event\} e The keydown event object.\par
     * @return \{boolean\} Whether the event was handled be the menu.\par
     */\par
    handleKeyDown: function(e) \{\par
      var item = this.selectedItem;\par
\par
      var self = this;\par
      function selectNextVisible(m) \{\par
        var children = self.children;\par
        var len = children.length;\par
        var i = self.selectedIndex;\par
        if (i == -1 && m == -1) \{\par
          // Edge case when we need to go the last item fisrt.\par
          i = 0;\par
        \}\par
        while (true) \{\par
          i = (i + m + len) % len;\par
          item = children[i];\par
          if (item && !item.isSeparator() && !item.hidden)\par
            break;\par
        \}\par
        if (item)\par
          self.selectedIndex = i;\par
      \}\par
\par
      switch (e.keyIdentifier) \{\par
        case 'Down':\par
          selectNextVisible(1);\par
          return true;\par
        case 'Up':\par
          selectNextVisible(-1);\par
          return true;\par
        case 'Enter':\par
        case 'U+0020': // Space\par
          if (item) \{\par
            if (cr.dispatchSimpleEvent(item, 'activate', true, true)) \{\par
              if (item.command)\par
                item.command.execute();\par
            \}\par
          \}\par
          return true;\par
      \}\par
\par
      return false;\par
    \}\par
  \};\par
\par
  function selectedIndexChanged(selectedIndex, oldSelectedIndex) \{\par
    var oldSelectedItem = this.children[oldSelectedIndex];\par
    if (oldSelectedItem)\par
      oldSelectedItem.selected = false;\par
    var item = this.selectedItem;\par
    if (item)\par
      item.selected = true;\par
  \}\par
  /**\par
   * The selected menu item.\par
   * @type \{number\}\par
   */\par
  cr.defineProperty(Menu, 'selectedIndex', cr.PropertyKind.JS,\par
      selectedIndexChanged);\par
\par
  // Export\par
  return \{\par
    Menu: Menu\par
  \};\par
\});\par
</script>\par
<script>// Copyright (c) 2011 The Chromium Authors. All rights reserved.\par
// Use of this source code is governed by a BSD-style license that can be\par
// found in the LICENSE file.\par
\par
cr.define('cr.ui', function() \{\par
  const Command = cr.ui.Command;\par
\par
  /**\par
   * Creates a new menu item element.\par
   * @param \{Object=\} opt_propertyBag Optional properties.\par
   * @constructor\par
   * @extends \{HTMLDivElement\}\par
   */\par
  var MenuItem = cr.ui.define('div');\par
\par
  /**\par
   * Creates a new menu separator element.\par
   * @return \{cr.ui.MenuItem\}\par
   */\par
  MenuItem.createSeparator = function() \{\par
    var el = cr.doc.createElement('hr');\par
    MenuItem.decorate(el);\par
    return el;\par
  \};\par
\par
  MenuItem.prototype = \{\par
    __proto__: HTMLButtonElement.prototype,\par
\par
    /**\par
     * Initializes the menu item.\par
     */\par
    decorate: function() \{\par
      var commandId;\par
      if ((commandId = this.getAttribute('command')))\par
        this.command = commandId;\par
\par
      this.addEventListener('mouseup', this.handleMouseUp_);\par
\par
      // Adding the 'custom-appearance' class prevents button.css from changing\par
      // the appearance of this element.\par
      this.classList.add('custom-appearance');\par
    \},\par
\par
    /**\par
     * The command associated with this menu item. If this is set to a string\par
     * of the form "#element-id" then the element is looked up in the document\par
     * of the command.\par
     * @type \{cr.ui.Command\}\par
     */\par
    command_: null,\par
    get command() \{\par
      return this.command_;\par
    \},\par
    set command(command) \{\par
      if (this.command_) \{\par
        this.command_.removeEventListener('labelChange', this);\par
        this.command_.removeEventListener('disabledChange', this);\par
        this.command_.removeEventListener('hiddenChange', this);\par
        this.command_.removeEventListener('checkedChange', this);\par
      \}\par
\par
      if (typeof command == 'string' && command[0] == '#') \{\par
        command = this.ownerDocument.getElementById(command.slice(1));\par
        cr.ui.decorate(command, Command);\par
      \}\par
\par
      this.command_ = command;\par
      if (command) \{\par
        if (command.id)\par
          this.setAttribute('command', '#' + command.id);\par
\par
        this.label = command.label;\par
        this.disabled = command.disabled;\par
        this.hidden = command.hidden;\par
\par
        this.command_.addEventListener('labelChange', this);\par
        this.command_.addEventListener('disabledChange', this);\par
        this.command_.addEventListener('hiddenChange', this);\par
        this.command_.addEventListener('checkedChange', this);\par
      \}\par
    \},\par
\par
    /**\par
     * The text label.\par
     * @type \{string\}\par
     */\par
    get label() \{\par
      return this.textContent;\par
    \},\par
    set label(label) \{\par
      this.textContent = label;\par
    \},\par
\par
    /**\par
     * @return \{boolean\} Whether the menu item is a separator.\par
     */\par
    isSeparator: function() \{\par
      return this.tagName == 'HR';\par
    \},\par
\par
    /**\par
     * Handles mouseup events. This dispatches an active event and if there\par
     * is an assiciated command then that is executed.\par
     * @param \{Event\} The mouseup event object.\par
     * @private\par
     */\par
    handleMouseUp_: function(e) \{\par
      if (!this.disabled && !this.isSeparator() && this.selected) \{\par
        // Dispatch command event followed by executing the command object.\par
        if (cr.dispatchSimpleEvent(this, 'activate', true, true)) \{\par
          var command = this.command;\par
          if (command)\par
            command.execute();\par
        \}\par
      \}\par
    \},\par
\par
    /**\par
     * Handles changes to the associated command.\par
     * @param \{Event\} e The event object.\par
     */\par
    handleEvent: function(e) \{\par
      switch (e.type) \{\par
        case 'disabledChange':\par
          this.disabled = this.command.disabled;\par
          break;\par
        case 'hiddenChange':\par
          this.hidden = this.command.hidden;\par
          break;\par
        case 'labelChange':\par
          this.label = this.command.label;\par
          break;\par
        case 'checkedChange':\par
          this.checked = this.command.checked;\par
          break;\par
      \}\par
    \}\par
  \};\par
\par
  /**\par
   * Whether the menu item is disabled or not.\par
   * @type \{boolean\}\par
   */\par
  cr.defineProperty(MenuItem, 'disabled', cr.PropertyKind.BOOL_ATTR);\par
\par
  /**\par
   * Whether the menu item is hidden or not.\par
   * @type \{boolean\}\par
   */\par
  cr.defineProperty(MenuItem, 'hidden', cr.PropertyKind.BOOL_ATTR);\par
\par
  /**\par
   * Whether the menu item is selected or not.\par
   * @type \{boolean\}\par
   */\par
  cr.defineProperty(MenuItem, 'selected', cr.PropertyKind.BOOL_ATTR);\par
\par
  /**\par
   * Whether the menu item is checked or not.\par
   * @type \{boolean\}\par
   */\par
  cr.defineProperty(MenuItem, 'checked', cr.PropertyKind.BOOL_ATTR);\par
\par
  // Export\par
  return \{\par
    MenuItem: MenuItem\par
  \};\par
\});\par
</script>\par
<script>// Copyright (c) 2010 The Chromium Authors. All rights reserved.\par
// Use of this source code is governed by a BSD-style license that can be\par
// found in the LICENSE file.\par
\par
/**\par
 * @fileoverview This file provides utility functions for position popups.\par
 */\par
\par
cr.define('cr.ui', function() \{\par
\par
  /**\par
   * Type def for rects as returned by getBoundingClientRect.\par
   * @typedef \{ \{left: number, top: number, width: number, height: number,\par
   *             right: number, bottom: number\}\}\par
   */\par
  var Rect;\par
\par
  /**\par
   * Enum for defining how to anchor a popup to an anchor element.\par
   * @enum \{number\}\par
   */\par
  const AnchorType = \{\par
    /**\par
     * The popup's right edge is aligned with the left edge of the anchor.\par
     * The popup's top edge is aligned with the top edge of the anchor.\par
     */\par
    BEFORE: 1,  // p: right, a: left, p: top, a: top\par
\par
    /**\par
     * The popop's left edge is aligned with the right edge of the anchor.\par
     * The popup's top edge is aligned with the top edge of the anchor.\par
     */\par
    AFTER: 2,  // p: left a: right, p: top, a: top\par
\par
    /**\par
     * The popop's bottom edge is aligned with the top edge of the anchor.\par
     * The popup's left edge is aligned with the left edge of the anchor.\par
     */\par
    ABOVE: 3,  // p: bottom, a: top, p: left, a: left\par
\par
    /**\par
     * The popop's top edge is aligned with the bottom edge of the anchor.\par
     * The popup's left edge is aligned with the left edge of the anchor.\par
     */\par
    BELOW: 4  // p: top, a: bottom, p: left, a: left\par
  \};\par
\par
  /**\par
   * Helper function for positionPopupAroundElement and positionPopupAroundRect.\par
   * @param \{!Rect\} anchorRect The rect for the anchor.\par
   * @param \{!HTMLElement\} popupElement The element used for the popup.\par
   * @param \{AnchorType\} type The type of anchoring to do.\par
   * @param \{boolean\} invertLeftRight Whether to invert the right/left\par
   *     alignment.\par
   */\par
  function positionPopupAroundRect(anchorRect, popupElement, type,\par
                                   invertLeftRight) \{\par
    var popupRect = popupElement.getBoundingClientRect();\par
    var availRect;\par
    var ownerDoc = popupElement.ownerDocument;\par
    var cs = ownerDoc.defaultView.getComputedStyle(popupElement);\par
    var docElement = ownerDoc.documentElement;\par
\par
    if (cs.position == 'fixed') \{\par
      // For 'fixed' positioned popups, the available rectangle should be based\par
      // on the viewport rather than the document.\par
      availRect = \{\par
        height: docElement.clientHeight,\par
        width: docElement.clientWidth,\par
        top: 0,\par
        bottom: docElement.clientHeight,\par
        left: 0,\par
        right: docElement.clientWidth\par
      \};\par
    \} else \{\par
      availRect = popupElement.offsetParent.getBoundingClientRect();\par
    \}\par
\par
    if (cs.direction == 'rtl')\par
      invertLeftRight = !invertLeftRight;\par
\par
    // Flip BEFORE, AFTER based on alignment.\par
    if (invertLeftRight) \{\par
      if (type == AnchorType.BEFORE)\par
        type = AnchorType.AFTER;\par
      else if (type == AnchorType.AFTER)\par
        type = AnchorType.BEFORE;\par
    \}\par
\par
    // Flip type based on available size\par
    switch (type) \{\par
      case AnchorType.BELOW:\par
        if (anchorRect.bottom + popupRect.height > availRect.height &&\par
            popupRect.height <= anchorRect.top) \{\par
          type = AnchorType.ABOVE;\par
        \}\par
        break;\par
      case AnchorType.ABOVE:\par
        if (popupRect.height > anchorRect.top &&\par
            anchorRect.bottom + popupRect.height <= availRect.height) \{\par
          type = AnchorType.BELOW;\par
        \}\par
        break;\par
      case AnchorType.AFTER:\par
        if (anchorRect.right + popupRect.width > availRect.width &&\par
            popupRect.width <= anchorRect.left) \{\par
          type = AnchorType.BEFORE;\par
        \}\par
        break;\par
      case AnchorType.BEFORE:\par
        if (popupRect.width > anchorRect.left &&\par
            anchorRect.right + popupRect.width <= availRect.width) \{\par
          type = AnchorType.AFTER;\par
        \}\par
        break;\par
    \}\par
    // flipping done\par
\par
    var style = popupElement.style;\par
    // Reset all directions.\par
    style.left = style.right = style.top = style.bottom = 'auto'\par
\par
    // Primary direction\par
    switch (type) \{\par
      case AnchorType.BELOW:\par
        if (anchorRect.bottom + popupRect.height <= availRect.height)\par
          style.top = anchorRect.bottom + 'px';\par
        else\par
          style.bottom = '0';\par
        break;\par
      case AnchorType.ABOVE:\par
        if (availRect.height - anchorRect.top >= 0)\par
          style.bottom = availRect.height - anchorRect.top + 'px';\par
        else\par
          style.top = '0';\par
        break;\par
      case AnchorType.AFTER:\par
        if (anchorRect.right + popupRect.width <= availRect.width)\par
          style.left = anchorRect.right + 'px';\par
        else\par
          style.right = '0';\par
        break;\par
      case AnchorType.BEFORE:\par
        if (availRect.width - anchorRect.left >= 0)\par
          style.right = availRect.width - anchorRect.left + 'px';\par
        else\par
          style.left = '0';\par
        break;\par
    \}\par
\par
    // Secondary direction\par
    switch (type) \{\par
      case AnchorType.BELOW:\par
      case AnchorType.ABOVE:\par
        if (invertLeftRight) \{\par
          // align right edges\par
          if (anchorRect.right - popupRect.width >= 0) \{\par
            style.right = availRect.width - anchorRect.right + 'px';\par
\par
          // align left edges\par
          \} else if (anchorRect.left + popupRect.width <= availRect.width) \{\par
            style.left = anchorRect.left + 'px';\par
\par
          // not enough room on either side\par
          \} else \{\par
            style.right = '0';\par
          \}\par
        \} else \{\par
          // align left edges\par
          if (anchorRect.left + popupRect.width <= availRect.width) \{\par
            style.left = anchorRect.left + 'px';\par
\par
          // align right edges\par
          \} else if (anchorRect.right - popupRect.width >= 0) \{\par
            style.right = availRect.width - anchorRect.right + 'px';\par
\par
          // not enough room on either side\par
          \} else \{\par
            style.left = '0';\par
          \}\par
        \}\par
        break;\par
\par
      case AnchorType.AFTER:\par
      case AnchorType.BEFORE:\par
        // align top edges\par
        if (anchorRect.top + popupRect.height <= availRect.height) \{\par
          style.top = anchorRect.top + 'px';\par
\par
        // align bottom edges\par
        \} else if (anchorRect.bottom - popupRect.height >= 0) \{\par
          style.bottom = availRect.height - anchorRect.bottom + 'px';\par
\par
          // not enough room on either side\par
        \} else \{\par
          style.top = '0';\par
        \}\par
        break;\par
    \}\par
  \}\par
\par
  /**\par
   * Positions a popup element relative to an anchor element. The popup element\par
   * should have position set to absolute and it should be a child of the body\par
   * element.\par
   * @param \{!HTMLElement\} anchorElement The element that the popup is anchored\par
   *     to.\par
   * @param \{!HTMLElement\} popupElement The popup element we are positioning.\par
   * @param \{AnchorType\} type The type of anchoring we want.\par
   * @param \{boolean\} invertLeftRight Whether to invert the right/left\par
   *     alignment.\par
   */\par
  function positionPopupAroundElement(anchorElement, popupElement, type,\par
                                      invertLeftRight) \{\par
    var anchorRect = anchorElement.getBoundingClientRect();\par
    positionPopupAroundRect(anchorRect, popupElement, type, invertLeftRight);\par
  \}\par
\par
  /**\par
   * Positions a popup around a point.\par
   * @param \{number\} x The client x position.\par
   * @param \{number\} y The client y position.\par
   * @param \{!HTMLElement\} popupElement The popup element we are positioning.\par
   */\par
  function positionPopupAtPoint(x, y, popupElement) \{\par
    var rect = \{\par
      left: x,\par
      top: y,\par
      width: 0,\par
      height: 0,\par
      right: x,\par
      bottom: y\par
    \};\par
    positionPopupAroundRect(rect, popupElement, AnchorType.BELOW);\par
  \}\par
\par
  // Export\par
  return \{\par
    AnchorType: AnchorType,\par
    positionPopupAroundElement: positionPopupAroundElement,\par
    positionPopupAtPoint: positionPopupAtPoint\par
  \};\par
\});\par
</script>\par
<script>// Copyright (c) 2011 The Chromium Authors. All rights reserved.\par
// Use of this source code is governed by a BSD-style license that can be\par
// found in the LICENSE file.\par
\par
cr.define('cr.ui', function() \{\par
  const Menu = cr.ui.Menu;\par
  const positionPopupAroundElement = cr.ui.positionPopupAroundElement;\par
\par
  /**\par
   * Creates a new menu button element.\par
   * @param \{Object=\} opt_propertyBag Optional properties.\par
   * @constructor\par
   * @extends \{HTMLButtonElement\}\par
   */\par
  var MenuButton = cr.ui.define('button');\par
\par
  MenuButton.prototype = \{\par
    __proto__: HTMLButtonElement.prototype,\par
\par
    /**\par
     * Initializes the menu button.\par
     */\par
    decorate: function() \{\par
      this.addEventListener('mousedown', this);\par
      this.addEventListener('keydown', this);\par
\par
      // Adding the 'custom-appearance' class prevents button.css from changing\par
      // the appearance of this element.\par
      this.classList.add('custom-appearance');\par
\par
      var menu;\par
      if ((menu = this.getAttribute('menu')))\par
        this.menu = menu;\par
\par
      // An event tracker for events we only connect to while the menu is\par
      // displayed.\par
      this.showingEvents_ = new EventTracker();\par
\par
      this.anchorType = cr.ui.AnchorType.BELOW;\par
      this.invertLeftRight = false;\par
    \},\par
\par
    /**\par
     * The menu associated with the menu button.\par
     * @type \{cr.ui.Menu\}\par
     */\par
    get menu() \{\par
      return this.menu_;\par
    \},\par
    set menu(menu) \{\par
      if (typeof menu == 'string' && menu[0] == '#') \{\par
        menu = this.ownerDocument.getElementById(menu.slice(1));\par
        cr.ui.decorate(menu, Menu);\par
      \}\par
\par
      this.menu_ = menu;\par
      if (menu) \{\par
        if (menu.id)\par
          this.setAttribute('menu', '#' + menu.id);\par
      \}\par
    \},\par
\par
    /**\par
     * Handles event callbacks.\par
     * @param \{Event\} e The event object.\par
     */\par
    handleEvent: function(e) \{\par
      if (!this.menu)\par
        return;\par
\par
      switch (e.type) \{\par
        case 'mousedown':\par
          if (e.currentTarget == this.ownerDocument) \{\par
            if (!this.contains(e.target) && !this.menu.contains(e.target))\par
              this.hideMenu();\par
            else\par
              e.preventDefault();\par
          \} else \{\par
            if (this.isMenuShown()) \{\par
              this.hideMenu();\par
            \} else if (e.button == 0) \{  // Only show the menu when using left\par
                                         // mouse button.\par
              this.showMenu();\par
              // Prevent the button from stealing focus on mousedown.\par
              e.preventDefault();\par
            \}\par
          \}\par
          break;\par
        case 'keydown':\par
          this.handleKeyDown(e);\par
          // If the menu is visible we let it handle all the keyboard events.\par
          if (this.isMenuShown() && e.currentTarget == this.ownerDocument) \{\par
            this.menu.handleKeyDown(e);\par
            e.preventDefault();\par
            e.stopPropagation();\par
          \}\par
          break;\par
\par
        case 'activate':\par
        case 'blur':\par
        case 'resize':\par
          this.hideMenu();\par
          break;\par
      \}\par
    \},\par
\par
    /**\par
     * Shows the menu.\par
     */\par
    showMenu: function() \{\par
      this.hideMenu();\par
\par
      this.menu.style.display = 'block';\par
      this.setAttribute('menu-shown', '');\par
\par
      // when the menu is shown we steal all keyboard events.\par
      var doc = this.ownerDocument;\par
      var win = doc.defaultView;\par
      this.showingEvents_.add(doc, 'keydown', this, true);\par
      this.showingEvents_.add(doc, 'mousedown', this, true);\par
      this.showingEvents_.add(doc, 'blur', this, true);\par
      this.showingEvents_.add(win, 'resize', this);\par
      this.showingEvents_.add(this.menu, 'activate', this);\par
      this.positionMenu_();\par
    \},\par
\par
    /**\par
     * Hides the menu. If your menu can go out of scope, make sure to call this\par
     * first.\par
     */\par
    hideMenu: function() \{\par
      if (!this.isMenuShown())\par
        return;\par
\par
      this.removeAttribute('menu-shown');\par
      this.menu.style.display = 'none';\par
\par
      this.showingEvents_.removeAll();\par
      this.menu.selectedIndex = -1;\par
    \},\par
\par
    /**\par
     * Whether the menu is shown.\par
     */\par
    isMenuShown: function() \{\par
      return this.hasAttribute('menu-shown');\par
    \},\par
\par
    /**\par
     * Positions the menu below the menu button. At this point we do not use any\par
     * advanced positioning logic to ensure the menu fits in the viewport.\par
     * @private\par
     */\par
    positionMenu_: function() \{\par
      positionPopupAroundElement(this, this.menu, this.anchorType,\par
                                 this.invertLeftRight);\par
    \},\par
\par
    /**\par
     * Handles the keydown event for the menu button.\par
     */\par
    handleKeyDown: function(e) \{\par
      switch (e.keyIdentifier) \{\par
        case 'Down':\par
        case 'Up':\par
        case 'Enter':\par
        case 'U+0020': // Space\par
          if (!this.isMenuShown())\par
            this.showMenu();\par
          e.preventDefault();\par
          break;\par
        case 'Esc':\par
        case 'U+001B': // Maybe this is remote desktop playing a prank?\par
          this.hideMenu();\par
          break;\par
      \}\par
    \}\par
  \};\par
\par
  // Export\par
  return \{\par
    MenuButton: MenuButton\par
  \};\par
\});\par
</script>\par
<script>// Copyright (c) 2011 The Chromium Authors. All rights reserved.\par
// Use of this source code is governed by a BSD-style license that can be\par
// found in the LICENSE file.\par
\par
/**\par
 * @fileoverview Touch Handler. Class that handles all touch events and\par
 * uses them to interpret higher level gestures and behaviors. TouchEvent is a\par
 * built in mobile safari type:\par
 * {{\field{\*\fldinst{HYPERLINK http://developer.apple.com/safari/library/documentation/UserExperience/Reference/TouchEventClassReference/TouchEvent/TouchEvent.html }}{\fldrslt{http://developer.apple.com/safari/library/documentation/UserExperience/Reference/TouchEventClassReference/TouchEvent/TouchEvent.html\ul0\cf0}}}}\f0\fs22 .\par
 * This class is intended to work with all webkit browsers, tested on Chrome and\par
 * iOS.\par
 *\par
 * The following types of gestures are currently supported.  See the definition\par
 * of TouchHandler.EventType for details.\par
 *\par
 * Single Touch:\par
 *      This provides simple single-touch events.  Any secondary touch is\par
 *      ignored.\par
 *\par
 * Drag:\par
 *      A single touch followed by some movement. This behavior will handle all\par
 *      of the required events and report the properties of the drag to you\par
 *      while the touch is happening and at the end of the drag sequence. This\par
 *      behavior will NOT perform the actual dragging (redrawing the element)\par
 *      for you, this responsibility is left to the client code.\par
 *\par
 * Long press:\par
 *     When your element is touched and held without any drag occuring, the\par
 *     LONG_PRESS event will fire.\par
 */\par
\par
// Use an anonymous function to enable strict mode just for this file (which\par
// will be concatenated with other files when embedded in Chrome)\par
cr.define('cr.ui', function() \{\par
  'use strict';\par
\par
  /**\par
   * A TouchHandler attaches to an Element, listents for low-level touch (or\par
   * mouse) events and dispatching higher-level events on the element.\par
   * @param \{!Element\} element The element to listen on and fire events\par
   * for.\par
   * @constructor\par
   */\par
  function TouchHandler(element) \{\par
    /**\par
     * @type \{!Element\}\par
     * @private\par
     */\par
    this.element_ = element;\par
\par
    /**\par
     * The absolute sum of all touch y deltas.\par
     * @type \{number\}\par
     * @private\par
     */\par
    this.totalMoveY_ = 0;\par
\par
    /**\par
     * The absolute sum of all touch x deltas.\par
     * @type \{number\}\par
     * @private\par
     */\par
    this.totalMoveX_ = 0;\par
\par
    /**\par
     * An array of tuples where the first item is the horizontal component of a\par
     * recent relevant touch and the second item is the touch's time stamp. Old\par
     * touches are removed based on the max tracking time and when direction\par
     * changes.\par
      * @type \{!Array.<number>\}\par
      * @private\par
      */\par
    this.recentTouchesX_ = [];\par
\par
    /**\par
     * An array of tuples where the first item is the vertical component of a\par
     * recent relevant touch and the second item is the touch's time stamp. Old\par
     * touches are removed based on the max tracking time and when direction\par
     * changes.\par
     * @type \{!Array.<number>\}\par
     * @private\par
     */\par
    this.recentTouchesY_ = [];\par
\par
    /**\par
     * Used to keep track of all events we subscribe to so we can easily clean\par
     * up\par
     * @type \{EventTracker\}\par
     * @private\par
     */\par
    this.events_ = new EventTracker();\par
  \}\par
\par
\par
  /**\par
   * DOM Events that may be fired by the TouchHandler at the element\par
   */\par
  TouchHandler.EventType = \{\par
    // Fired whenever the element is touched as the only touch to the device.\par
    // enableDrag defaults to false, set to true to permit dragging.\par
    TOUCH_START: 'touchHandler:touch_start',\par
\par
    // Fired when an element is held for a period of time.  Prevents dragging\par
    // from occuring (even if enableDrag was set to true).\par
    LONG_PRESS: 'touchHandler:long_press',\par
\par
    // If enableDrag was set to true at TOUCH_START, DRAG_START will fire when\par
    // the touch first moves sufficient distance.  enableDrag is set to true but\par
    // can be reset to false to cancel the drag.\par
    DRAG_START: 'touchHandler:drag_start',\par
\par
    // If enableDrag was true after DRAG_START, DRAG_MOVE will fire whenever the\par
    // touch is moved.\par
    DRAG_MOVE: 'touchHandler:drag_move',\par
\par
    // Fired just before TOUCH_END when a drag is released.  Correlates 1:1 with\par
    // a DRAG_START.\par
    DRAG_END: 'touchHandler:drag_end',\par
\par
    // Fired whenever a touch that is being tracked has been released.\par
    // Correlates 1:1 with a TOUCH_START.\par
    TOUCH_END: 'touchHandler:touch_end'\par
  \};\par
\par
\par
  /**\par
   * The type of event sent by TouchHandler\par
   * @constructor\par
   * @param \{string\} type The type of event (one of cr.ui.Grabber.EventType).\par
   * @param \{boolean\} bubbles Whether or not the event should bubble.\par
   * @param \{number\} clientX The X location of the touch.\par
   * @param \{number\} clientY The Y location of the touch.\par
   * @param \{!Element\} touchedElement The element at the current location of the\par
   *        touch.\par
   */\par
  TouchHandler.Event = function(type, bubbles, clientX, clientY,\par
      touchedElement) \{\par
    var event = document.createEvent('Event');\par
    event.initEvent(type, bubbles, true);\par
    event.__proto__ = TouchHandler.Event.prototype;\par
\par
    /**\par
     * The X location of the touch affected\par
     * @type \{number\}\par
     */\par
    event.clientX = clientX;\par
\par
    /**\par
     * The Y location of the touch affected\par
     * @type \{number\}\par
     */\par
    event.clientY = clientY;\par
\par
    /**\par
     * The element at the current location of the touch.\par
     * @type \{!Element\}\par
     */\par
    event.touchedElement = touchedElement;\par
\par
    return event;\par
  \};\par
\par
  TouchHandler.Event.prototype = \{\par
    __proto__: Event.prototype,\par
\par
    /**\par
     * For TOUCH_START and DRAG START events, set to true to enable dragging or\par
     * false to disable dragging.\par
     * @type \{boolean|undefined\}\par
     */\par
    enableDrag: undefined,\par
\par
    /**\par
     * For DRAG events, provides the horizontal component of the\par
     * drag delta. Drag delta is defined as the delta of the start touch\par
     * position and the current drag position.\par
     * @type \{number|undefined\}\par
     */\par
    dragDeltaX: undefined,\par
\par
    /**\par
     * For DRAG events, provides the vertical component of the\par
     * drag delta.\par
     * @type \{number|undefined\}\par
     */\par
    dragDeltaY: undefined\par
  \};\par
\par
  /**\par
   * Minimum movement of touch required to be considered a drag.\par
   * @type \{number\}\par
   * @private\par
   */\par
  TouchHandler.MIN_TRACKING_FOR_DRAG_ = 8;\par
\par
\par
  /**\par
   * The maximum number of ms to track a touch event. After an event is older\par
   * than this value, it will be ignored in velocity calculations.\par
   * @type \{number\}\par
   * @private\par
   */\par
  TouchHandler.MAX_TRACKING_TIME_ = 250;\par
\par
\par
  /**\par
   * The maximum number of touches to track.\par
   * @type \{number\}\par
   * @private\par
   */\par
  TouchHandler.MAX_TRACKING_TOUCHES_ = 5;\par
\par
\par
  /**\par
   * The maximum velocity to return, in pixels per millisecond, that is used\par
   * to guard against errors in calculating end velocity of a drag. This is a\par
   * very fast drag velocity.\par
   * @type \{number\}\par
   * @private\par
   */\par
  TouchHandler.MAXIMUM_VELOCITY_ = 5;\par
\par
\par
  /**\par
   * The velocity to return, in pixel per millisecond, when the time stamps on\par
   * the events are erroneous. The browser can return bad time stamps if the\par
   * thread is blocked for the duration of the drag. This is a low velocity to\par
   * prevent the content from moving quickly after a slow drag. It is less\par
   * jarring if the content moves slowly after a fast drag.\par
   * @type \{number\}\par
   * @private\par
   */\par
  TouchHandler.VELOCITY_FOR_INCORRECT_EVENTS_ = 1;\par
\par
  /**\par
   * The time, in milliseconds, that a touch must be held to be considered\par
   * 'long'.\par
   * @type \{number\}\par
   * @private\par
   */\par
  TouchHandler.TIME_FOR_LONG_PRESS_ = 500;\par
\par
  TouchHandler.prototype = \{\par
    /**\par
     * If defined, the identifer of the single touch that is active.  Note that\par
     * 0 is a valid touch identifier - it should not be treated equivalently to\par
     * undefined.\par
     * @type \{number|undefined\}\par
     * @private\par
     */\par
    activeTouch_: undefined,\par
\par
    /**\par
     * @type \{boolean|undefined\}\par
     * @private\par
     */\par
    tracking_: undefined,\par
\par
    /**\par
     * @type \{number|undefined\}\par
     * @private\par
     */\par
    startTouchX_: undefined,\par
\par
    /**\par
     * @type \{number|undefined\}\par
     * @private\par
     */\par
    startTouchY_: undefined,\par
\par
    /**\par
     * @type \{number|undefined\}\par
     * @private\par
     */\par
    endTouchX_: undefined,\par
\par
    /**\par
     * @type \{number|undefined\}\par
     * @private\par
     */\par
    endTouchY_: undefined,\par
\par
    /**\par
     * Time of the touchstart event.\par
     * @type \{number|undefined\}\par
     * @private\par
     */\par
    startTime_: undefined,\par
\par
    /**\par
     * The time of the touchend event.\par
     * @type \{number|undefined\}\par
     * @private\par
     */\par
    endTime_: undefined,\par
\par
    /**\par
     * @type \{number|undefined\}\par
     * @private\par
     */\par
    lastTouchX_: undefined,\par
\par
    /**\par
     * @type \{number|undefined\}\par
     * @private\par
     */\par
    lastTouchY_: undefined,\par
\par
    /**\par
     * @type \{number|undefined\}\par
     * @private\par
     */\par
    lastMoveX_: undefined,\par
\par
    /**\par
     * @type \{number|undefined\}\par
     * @private\par
     */\par
    lastMoveY_: undefined,\par
\par
    /**\par
     * @type \{number|undefined\}\par
     * @private\par
     */\par
    longPressTimeout_: undefined,\par
\par
    /**\par
     * If defined and true, the next click event should be swallowed\par
     * @type \{boolean|undefined\}\par
     * @private\par
     */\par
    swallowNextClick_: undefined,\par
\par
    /**\par
     * Start listenting for events.\par
     * @param \{boolean=\} opt_capture True if the TouchHandler should listen to\par
     *      during the capture phase.\par
     * @param \{boolean=\} opt_mouse True if the TouchHandler should generate\par
     *      events for mouse input (in addition to touch input).\par
     */\par
    enable: function(opt_capture, opt_mouse) \{\par
      var capture = !!opt_capture;\par
\par
      // Just listen to start events for now. When a touch is occuring we'll\par
      // want to be subscribed to move and end events on the document, but we\par
      // don't want to incur the cost of lots of no-op handlers on the document.\par
      this.events_.add(this.element_, 'touchstart', this.onStart_.bind(this),\par
                       capture);\par
      if (opt_mouse) \{\par
        this.events_.add(this.element_, 'mousedown',\par
                         this.mouseToTouchCallback_(this.onStart_.bind(this)),\par
                         capture);\par
      \}\par
\par
      // If the element is long-pressed, we may need to swallow a click\par
      this.events_.add(this.element_, 'click', this.onClick_.bind(this), true);\par
    \},\par
\par
    /**\par
     * Stop listening to all events.\par
     */\par
    disable: function() \{\par
      this.stopTouching_();\par
      this.events_.removeAll();\par
    \},\par
\par
    /**\par
     * Wraps a callback with translations of mouse events to touch events.\par
     * NOTE: These types really should be function(Event) but then we couldn't\par
     * use this with bind (which operates on any type of function).  Doesn't\par
     * JSDoc support some sort of polymorphic types?\par
     * @param \{Function\} callback The event callback.\par
     * @return \{Function\} The wrapping callback.\par
     * @private\par
     */\par
    mouseToTouchCallback_: function(callback) \{\par
      return function(e) \{\par
        // Note that there may be synthesizes mouse events caused by touch\par
        // events (a mouseDown after a touch-click).  We leave it up to the\par
        // client to worry about this if it matters to them (typically a short\par
        // mouseDown/mouseUp without a click is no big problem and it's not\par
        // obvious how we identify such synthesized events in a general way).\par
        var touch = \{\par
          // any fixed value will do for the identifier - there will only\par
          // ever be a single active 'touch' when using the mouse.\par
          identifier: 0,\par
          clientX: e.clientX,\par
          clientY: e.clientY,\par
          target: e.target\par
        \};\par
        e.touches = [];\par
        e.targetTouches = [];\par
        e.changedTouches = [touch];\par
        if (e.type != 'mouseup') \{\par
          e.touches[0] = touch;\par
          e.targetTouches[0] = touch;\par
        \}\par
        callback(e);\par
      \};\par
    \},\par
\par
    /**\par
     * Begin tracking the touchable element, it is eligible for dragging.\par
     * @private\par
     */\par
    beginTracking_: function() \{\par
      this.tracking_ = true;\par
    \},\par
\par
    /**\par
     * Stop tracking the touchable element, it is no longer dragging.\par
     * @private\par
     */\par
    endTracking_: function() \{\par
      this.tracking_ = false;\par
      this.dragging_ = false;\par
      this.totalMoveY_ = 0;\par
      this.totalMoveX_ = 0;\par
    \},\par
\par
    /**\par
     * Reset the touchable element as if we never saw the touchStart\par
     * Doesn't dispatch any end events - be careful of existing listeners.\par
     */\par
    cancelTouch: function() \{\par
      this.stopTouching_();\par
      this.endTracking_();\par
      // If clients needed to be aware of this, we could fire a cancel event\par
      // here.\par
    \},\par
\par
    /**\par
     * Record that touching has stopped\par
     * @private\par
     */\par
    stopTouching_: function() \{\par
      // Mark as no longer being touched\par
      this.activeTouch_ = undefined;\par
\par
      // If we're waiting for a long press, stop\par
      window.clearTimeout(this.longPressTimeout_);\par
\par
      // Stop listening for move/end events until there's another touch.\par
      // We don't want to leave handlers piled up on the document.\par
      // Note that there's no harm in removing handlers that weren't added, so\par
      // rather than track whether we're using mouse or touch we do both.\par
      this.events_.remove(document, 'touchmove');\par
      this.events_.remove(document, 'touchend');\par
      this.events_.remove(document, 'touchcancel');\par
      this.events_.remove(document, 'mousemove');\par
      this.events_.remove(document, 'mouseup');\par
    \},\par
\par
    /**\par
     * Touch start handler.\par
     * @param \{!TouchEvent\} e The touchstart event.\par
     * @private\par
     */\par
    onStart_: function(e) \{\par
      // Only process single touches.  If there is already a touch happening, or\par
      // two simultaneous touches then just ignore them.\par
      if (e.touches.length > 1)\par
        // Note that we could cancel an active touch here.  That would make\par
        // simultaneous touch behave similar to near-simultaneous. However, if\par
        // the user is dragging something, an accidental second touch could be\par
        // quite disruptive if it cancelled their drag.  Better to just ignore\par
        // it.\par
        return;\par
\par
      // It's still possible there could be an active "touch" if the user is\par
      // simultaneously using a mouse and a touch input.\par
      if (this.activeTouch_ !== undefined)\par
        return;\par
\par
      var touch = e.targetTouches[0];\par
      this.activeTouch_ = touch.identifier;\par
\par
      // We've just started touching so shouldn't swallow any upcoming click\par
      if (this.swallowNextClick_)\par
        this.swallowNextClick_ = false;\par
\par
      // Sign up for end/cancel notifications for this touch.\par
      // Note that we do this on the document so that even if the user drags\par
      // their finger off the element, we'll still know what they're doing.\par
      if (e.type == 'mousedown') \{\par
        this.events_.add(document, 'mouseup',\par
            this.mouseToTouchCallback_(this.onEnd_.bind(this)), false);\par
      \} else \{\par
        this.events_.add(document, 'touchend', this.onEnd_.bind(this), false);\par
        this.events_.add(document, 'touchcancel', this.onEnd_.bind(this),\par
            false);\par
      \}\par
\par
      // This timeout is cleared on touchEnd and onDrag\par
      // If we invoke the function then we have a real long press\par
      window.clearTimeout(this.longPressTimeout_);\par
      this.longPressTimeout_ = window.setTimeout(\par
          this.onLongPress_.bind(this),\par
          TouchHandler.TIME_FOR_LONG_PRESS_);\par
\par
      // Dispatch the TOUCH_START event\par
      if (!this.dispatchEvent_(TouchHandler.EventType.TOUCH_START, touch))\par
        // Dragging was not enabled, nothing more to do\par
        return;\par
\par
      // We want dragging notifications\par
      if (e.type == 'mousedown') \{\par
        this.events_.add(document, 'mousemove',\par
            this.mouseToTouchCallback_(this.onMove_.bind(this)), false);\par
      \} else \{\par
        this.events_.add(document, 'touchmove', this.onMove_.bind(this), false);\par
      \}\par
\par
      this.startTouchX_ = this.lastTouchX_ = touch.clientX;\par
      this.startTouchY_ = this.lastTouchY_ = touch.clientY;\par
      this.startTime_ = e.timeStamp;\par
\par
      this.recentTouchesX_ = [];\par
      this.recentTouchesY_ = [];\par
      this.recentTouchesX_.push(touch.clientX, e.timeStamp);\par
      this.recentTouchesY_.push(touch.clientY, e.timeStamp);\par
\par
      this.beginTracking_();\par
    \},\par
\par
    /**\par
     * Given a list of Touches, find the one matching our activeTouch\par
     * identifier. Note that Chrome currently always uses 0 as the identifier.\par
     * In that case we'll end up always choosing the first element in the list.\par
     * @param \{TouchList\} touches The list of Touch objects to search.\par
     * @return \{!Touch|undefined\} The touch matching our active ID if any.\par
     * @private\par
     */\par
    findActiveTouch_: function(touches) \{\par
      assert(this.activeTouch_ !== undefined, 'Expecting an active touch');\par
      // A TouchList isn't actually an array, so we shouldn't use\par
      // Array.prototype.filter/some, etc.\par
      for (var i = 0; i < touches.length; i++) \{\par
        if (touches[i].identifier == this.activeTouch_)\par
          return touches[i];\par
      \}\par
      return undefined;\par
    \},\par
\par
    /**\par
     * Touch move handler.\par
     * @param \{!TouchEvent\} e The touchmove event.\par
     * @private\par
     */\par
    onMove_: function(e) \{\par
      if (!this.tracking_)\par
        return;\par
\par
      // Our active touch should always be in the list of touches still active\par
      assert(this.findActiveTouch_(e.touches), 'Missing touchEnd');\par
\par
      var that = this;\par
      var touch = this.findActiveTouch_(e.changedTouches);\par
      if (!touch)\par
        return;\par
\par
      var clientX = touch.clientX;\par
      var clientY = touch.clientY;\par
\par
      var moveX = this.lastTouchX_ - clientX;\par
      var moveY = this.lastTouchY_ - clientY;\par
      this.totalMoveX_ += Math.abs(moveX);\par
      this.totalMoveY_ += Math.abs(moveY);\par
      this.lastTouchX_ = clientX;\par
      this.lastTouchY_ = clientY;\par
\par
      if (!this.dragging_ && (this.totalMoveY_ >\par
          TouchHandler.MIN_TRACKING_FOR_DRAG_ ||\par
          this.totalMoveX_ >\par
          TouchHandler.MIN_TRACKING_FOR_DRAG_)) \{\par
        // If we're waiting for a long press, stop\par
        window.clearTimeout(this.longPressTimeout_);\par
\par
        // Dispatch the DRAG_START event and record whether dragging should be\par
        // allowed or not.  Note that this relies on the current value of\par
        // startTouchX/Y - handlers may use the initial drag delta to determine\par
        // if dragging should be permitted.\par
        this.dragging_ = this.dispatchEvent_(\par
            TouchHandler.EventType.DRAG_START, touch);\par
\par
        if (this.dragging_) \{\par
          // Update the start position here so that drag deltas have better\par
          // values but don't touch the recent positions so that velocity\par
          // calculations can still use touchstart position in the time and\par
          // distance delta.\par
          this.startTouchX_ = clientX;\par
          this.startTouchY_ = clientY;\par
          this.startTime_ = e.timeStamp;\par
        \} else \{\par
          this.endTracking_();\par
        \}\par
      \}\par
\par
      if (this.dragging_) \{\par
        this.dispatchEvent_(TouchHandler.EventType.DRAG_MOVE, touch);\par
\par
        this.removeTouchesInWrongDirection_(this.recentTouchesX_,\par
            this.lastMoveX_, moveX);\par
        this.removeTouchesInWrongDirection_(this.recentTouchesY_,\par
            this.lastMoveY_, moveY);\par
        this.removeOldTouches_(this.recentTouchesX_, e.timeStamp);\par
        this.removeOldTouches_(this.recentTouchesY_, e.timeStamp);\par
        this.recentTouchesX_.push(clientX, e.timeStamp);\par
        this.recentTouchesY_.push(clientY, e.timeStamp);\par
      \}\par
\par
      this.lastMoveX_ = moveX;\par
      this.lastMoveY_ = moveY;\par
    \},\par
\par
    /**\par
     * Filters the provided recent touches array to remove all touches except\par
     * the last if the move direction has changed.\par
     * @param \{!Array.<number>\} recentTouches An array of tuples where the first\par
     *     item is the x or y component of the recent touch and the second item\par
     *     is the touch time stamp.\par
     * @param \{number|undefined\} lastMove The x or y component of the previous\par
     *     move.\par
     * @param \{number\} recentMove The x or y component of the most recent move.\par
     * @private\par
     */\par
    removeTouchesInWrongDirection_: function(recentTouches, lastMove,\par
        recentMove) \{\par
      if (lastMove && recentMove && recentTouches.length > 2 &&\par
          (lastMove > 0 ^ recentMove > 0)) \{\par
        recentTouches.splice(0, recentTouches.length - 2);\par
      \}\par
    \},\par
\par
    /**\par
     * Filters the provided recent touches array to remove all touches older\par
     * than the max tracking time or the 5th most recent touch.\par
     * @param \{!Array.<number>\} recentTouches An array of tuples where the first\par
     *     item is the x or y component of the recent touch and the second item\par
     *     is the touch time stamp.\par
     * @param \{number\} recentTime The time of the most recent event.\par
     * @private\par
     */\par
    removeOldTouches_: function(recentTouches, recentTime) \{\par
      while (recentTouches.length && recentTime - recentTouches[1] >\par
          TouchHandler.MAX_TRACKING_TIME_ ||\par
          recentTouches.length >\par
              TouchHandler.MAX_TRACKING_TOUCHES_ * 2) \{\par
        recentTouches.splice(0, 2);\par
      \}\par
    \},\par
\par
    /**\par
     * Touch end handler.\par
     * @param \{!TouchEvent\} e The touchend event.\par
     * @private\par
     */\par
    onEnd_: function(e) \{\par
      var that = this;\par
      assert(this.activeTouch_ !== undefined, 'Expect to already be touching');\par
\par
      // If the touch we're tracking isn't changing here, ignore this touch end.\par
      var touch = this.findActiveTouch_(e.changedTouches);\par
      if (!touch) \{\par
        // In most cases, our active touch will be in the 'touches' collection,\par
        // but we can't assert that because occasionally two touchend events can\par
        // occur at almost the same time with both having empty 'touches' lists.\par
        // I.e., 'touches' seems like it can be a bit more up-to-date than the\par
        // current event.\par
        return;\par
      \}\par
\par
      // This is touchEnd for the touch we're monitoring\par
      assert(!this.findActiveTouch_(e.touches),\par
             'Touch ended also still active');\par
\par
      // Indicate that touching has finished\par
      this.stopTouching_();\par
\par
      if (this.tracking_) \{\par
        var clientX = touch.clientX;\par
        var clientY = touch.clientY;\par
\par
        if (this.dragging_) \{\par
          this.endTime_ = e.timeStamp;\par
          this.endTouchX_ = clientX;\par
          this.endTouchY_ = clientY;\par
\par
          this.removeOldTouches_(this.recentTouchesX_, e.timeStamp);\par
          this.removeOldTouches_(this.recentTouchesY_, e.timeStamp);\par
\par
          this.dispatchEvent_(TouchHandler.EventType.DRAG_END, touch);\par
\par
          // Note that in some situations we can get a click event here as well.\par
          // For now this isn't a problem, but we may want to consider having\par
          // some logic that hides clicks that appear to be caused by a touchEnd\par
          // used for dragging.\par
        \}\par
\par
        this.endTracking_();\par
      \}\par
\par
      // Note that we dispatch the touchEnd event last so that events at\par
      // different levels of semantics nest nicely (similar to how DOM\par
      // drag-and-drop events are nested inside of the mouse events that trigger\par
      // them).\par
      this.dispatchEvent_(TouchHandler.EventType.TOUCH_END, touch);\par
    \},\par
\par
    /**\par
     * Get end velocity of the drag. This method is specific to drag behavior,\par
     * so if touch behavior and drag behavior is split then this should go with\par
     * drag behavior. End velocity is defined as deltaXY / deltaTime where\par
     * deltaXY is the difference between endPosition and the oldest recent\par
     * position, and deltaTime is the difference between endTime and the oldest\par
     * recent time stamp.\par
     * @return \{Object\} The x and y velocity.\par
     */\par
    getEndVelocity: function() \{\par
      // Note that we could move velocity to just be an end-event parameter.\par
      var velocityX = this.recentTouchesX_.length ?\par
          (this.endTouchX_ - this.recentTouchesX_[0]) /\par
          (this.endTime_ - this.recentTouchesX_[1]) : 0;\par
      var velocityY = this.recentTouchesY_.length ?\par
          (this.endTouchY_ - this.recentTouchesY_[0]) /\par
          (this.endTime_ - this.recentTouchesY_[1]) : 0;\par
\par
      velocityX = this.correctVelocity_(velocityX);\par
      velocityY = this.correctVelocity_(velocityY);\par
\par
      return \{\par
        x: velocityX,\par
        y: velocityY\par
      \};\par
    \},\par
\par
    /**\par
     * Correct erroneous velocities by capping the velocity if we think it's too\par
     * high, or setting it to a default velocity if know that the event data is\par
     * bad.\par
     * @param \{number\} velocity The x or y velocity component.\par
     * @return \{number\} The corrected velocity.\par
     * @private\par
     */\par
    correctVelocity_: function(velocity) \{\par
      var absVelocity = Math.abs(velocity);\par
\par
      // We add to recent touches for each touchstart and touchmove. If we have\par
      // fewer than 3 touches (6 entries), we assume that the thread was blocked\par
      // for the duration of the drag and we received events in quick succession\par
      // with the wrong time stamps.\par
      if (absVelocity > TouchHandler.MAXIMUM_VELOCITY_) \{\par
        absVelocity = this.recentTouchesY_.length < 3 ?\par
            TouchHandler.VELOCITY_FOR_INCORRECT_EVENTS_ :\par
                TouchHandler.MAXIMUM_VELOCITY_;\par
      \}\par
      return absVelocity * (velocity < 0 ? -1 : 1);\par
    \},\par
\par
    /**\par
     * Handler when an element has been pressed for a long time\par
     * @private\par
     */\par
    onLongPress_: function() \{\par
      // Swallow any click that occurs on this element without an intervening\par
      // touch start event.  This simple click-busting technique should be\par
      // sufficient here since a real click should have a touchstart first.\par
      this.swallowNextClick_ = true;\par
\par
      // Dispatch to the LONG_PRESS\par
      this.dispatchEventXY_(TouchHandler.EventType.LONG_PRESS, this.element_,\par
          this.startTouchX_, this.startTouchY_);\par
    \},\par
\par
    /**\par
     * Click handler - used to swallow clicks after a long-press\par
     * @param \{!Event\} e The click event.\par
     * @private\par
     */\par
    onClick_: function(e) \{\par
      if (this.swallowNextClick_) \{\par
        e.preventDefault();\par
        e.stopPropagation();\par
        this.swallowNextClick_ = false;\par
      \}\par
    \},\par
\par
    /**\par
     * Dispatch a TouchHandler event to the element\par
     * @param \{string\} eventType The event to dispatch.\par
     * @param \{Touch\} touch The touch triggering this event.\par
     * @return \{boolean|undefined\} The value of enableDrag after dispatching\par
     *         the event.\par
     * @private\par
     */\par
    dispatchEvent_: function(eventType, touch) \{\par
\par
      // Determine which element was touched.  For mouse events, this is always\par
      // the event/touch target.  But for touch events, the target is always the\par
      // target of the touchstart (and it's unlikely we can change this\par
      // since the common implementation of touch dragging relies on it). Since\par
      // touch is our primary scenario (which we want to emulate with mouse),\par
      // we'll treat both cases the same and not depend on the target.\par
      var touchedElement;\par
      if (eventType == TouchHandler.EventType.TOUCH_START) \{\par
        touchedElement = touch.target;\par
      \} else \{\par
        touchedElement = this.element_.ownerDocument.\par
            elementFromPoint(touch.clientX, touch.clientY);\par
      \}\par
\par
      return this.dispatchEventXY_(eventType, touchedElement, touch.clientX,\par
          touch.clientY);\par
    \},\par
\par
    /**\par
     * Dispatch a TouchHandler event to the element\par
     * @param \{string\} eventType The event to dispatch.\par
       @param \{number\} clientX The X location for the event.\par
       @param \{number\} clientY The Y location for the event.\par
     * @return \{boolean|undefined\} The value of enableDrag after dispatching\par
     *         the event.\par
     * @private\par
     */\par
    dispatchEventXY_: function(eventType, touchedElement, clientX, clientY) \{\par
      var isDrag = (eventType == TouchHandler.EventType.DRAG_START ||\par
          eventType == TouchHandler.EventType.DRAG_MOVE ||\par
          eventType == TouchHandler.EventType.DRAG_END);\par
\par
      // Drag events don't bubble - we're really just dragging the element,\par
      // not affecting its parent at all.\par
      var bubbles = !isDrag;\par
\par
      var event = new TouchHandler.Event(eventType, bubbles, clientX, clientY,\par
          touchedElement);\par
\par
      // Set enableDrag when it can be overridden\par
      if (eventType == TouchHandler.EventType.TOUCH_START)\par
        event.enableDrag = false;\par
      else if (eventType == TouchHandler.EventType.DRAG_START)\par
        event.enableDrag = true;\par
\par
      if (isDrag) \{\par
        event.dragDeltaX = clientX - this.startTouchX_;\par
        event.dragDeltaY = clientY - this.startTouchY_;\par
      \}\par
\par
      this.element_.dispatchEvent(event);\par
      return event.enableDrag;\par
    \}\par
  \};\par
\par
  return \{\par
    TouchHandler: TouchHandler\par
  \};\par
\});\par
</script>\par
\par
<script>// Copyright (c) 2012 The Chromium Authors. All rights reserved.\par
// Use of this source code is governed by a BSD-style license that can be\par
// found in the LICENSE file.\par
\par
cr.define('ntp4', function() \{\par
  'use strict';\par
\par
  // We can't pass the currently dragging tile via dataTransfer because of\par
  // {{\field{\*\fldinst{HYPERLINK http://crbug.com/31037 }}{\fldrslt{http://crbug.com/31037\ul0\cf0}}}}\f0\fs22\par
  var currentlyDraggingTile = null;\par
  function getCurrentlyDraggingTile() \{\par
    return currentlyDraggingTile;\par
  \}\par
  function setCurrentlyDraggingTile(tile) \{\par
    currentlyDraggingTile = tile;\par
    if (tile)\par
      ntp4.enterRearrangeMode();\par
    else\par
      ntp4.leaveRearrangeMode();\par
  \}\par
\par
  /**\par
   * Changes the current dropEffect of a drag. This modifies the native cursor\par
   * and serves as an indicator of what we should do at the end of the drag as\par
   * well as give indication to the user if a drop would succeed if they let go.\par
   * @param \{DataTransfer\} dataTransfer A dataTransfer object from a drag event.\par
   * @param \{string\} effect A drop effect to change to (i.e. copy, move, none).\par
   */\par
  function setCurrentDropEffect(dataTransfer, effect) \{\par
    dataTransfer.dropEffect = effect;\par
    if (currentlyDraggingTile)\par
      currentlyDraggingTile.lastDropEffect = dataTransfer.dropEffect;\par
  \}\par
\par
  /**\par
   * Creates a new Tile object. Tiles wrap content on a TilePage, providing\par
   * some styling and drag functionality.\par
   * @constructor\par
   * @extends \{HTMLDivElement\}\par
   */\par
  function Tile(contents) \{\par
    var tile = cr.doc.createElement('div');\par
    tile.__proto__ = Tile.prototype;\par
    tile.initialize(contents);\par
\par
    return tile;\par
  \}\par
\par
  Tile.prototype = \{\par
    __proto__: HTMLDivElement.prototype,\par
\par
    initialize: function(contents) \{\par
      // 'real' as opposed to doppleganger.\par
      this.className = 'tile real';\par
      this.appendChild(contents);\par
      contents.tile = this;\par
\par
      this.addEventListener('dragstart', this.onDragStart_);\par
      this.addEventListener('drag', this.onDragMove_);\par
      this.addEventListener('dragend', this.onDragEnd_);\par
\par
      this.firstChild.addEventListener(\par
          'webkitAnimationEnd', this.onContentsAnimationEnd_.bind(this));\par
\par
      this.eventTracker = new EventTracker();\par
    \},\par
\par
    get index() \{\par
      return Array.prototype.indexOf.call(this.parentNode.children, this);\par
    \},\par
\par
    get tilePage() \{\par
      return findAncestorByClass(this, 'tile-page');\par
    \},\par
\par
    /**\par
     * Position the tile at |x, y|, and store this as the grid location, i.e.\par
     * where the tile 'belongs' when it's not being dragged.\par
     * @param \{number\} x The x coordinate, in pixels.\par
     * @param \{number\} y The y coordinate, in pixels.\par
     */\par
    setGridPosition: function(x, y) \{\par
      this.gridX = x;\par
      this.gridY = y;\par
      this.moveTo(x, y);\par
    \},\par
\par
    /**\par
     * Position the tile at |x, y|.\par
     * @param \{number\} x The x coordinate, in pixels.\par
     * @param \{number\} y The y coordinate, in pixels.\par
     */\par
    moveTo: function(x, y) \{\par
      // left overrides right in LTR, and right takes precedence in RTL.\par
      this.style.left = x + 'px';\par
      this.style.right = x + 'px';\par
      this.style.top = y + 'px';\par
    \},\par
\par
    /**\par
     * The handler for dragstart events fired on |this|.\par
     * @param \{Event\} e The event for the drag.\par
     * @private\par
     */\par
    onDragStart_: function(e) \{\par
      // The user may start dragging again during a previous drag's finishing\par
      // animation.\par
      if (this.classList.contains('dragging'))\par
        this.finalizeDrag_();\par
\par
      setCurrentlyDraggingTile(this);\par
\par
      e.dataTransfer.effectAllowed = 'copyMove';\par
      this.firstChild.setDragData(e.dataTransfer);\par
\par
      // The drag clone is the node we use as a representation during the drag.\par
      // It's attached to the top level document element so that it floats above\par
      // image masks.\par
      this.dragClone = this.cloneNode(true);\par
      this.dragClone.style.right = '';\par
      this.dragClone.classList.add('drag-representation');\par
      $('card-slider-frame').appendChild(this.dragClone);\par
      this.eventTracker.add(this.dragClone, 'webkitTransitionEnd',\par
                            this.onDragCloneTransitionEnd_.bind(this));\par
\par
      this.classList.add('dragging');\par
      // offsetLeft is mirrored in RTL. Un-mirror it.\par
      var offsetLeft = isRTL() ?\par
          this.parentNode.clientWidth - this.offsetLeft :\par
          this.offsetLeft;\par
      this.dragOffsetX = e.x - offsetLeft - this.parentNode.offsetLeft;\par
      this.dragOffsetY = e.y - this.offsetTop -\par
          // Unlike offsetTop, this value takes scroll position into account.\par
          this.parentNode.getBoundingClientRect().top;\par
\par
      this.onDragMove_(e);\par
    \},\par
\par
    /**\par
     * The handler for drag events fired on |this|.\par
     * @param \{Event\} e The event for the drag.\par
     * @private\par
     */\par
    onDragMove_: function(e) \{\par
      if (e.view != window || (e.x == 0 && e.y == 0)) \{\par
        this.dragClone.hidden = true;\par
        return;\par
      \}\par
\par
      this.dragClone.hidden = false;\par
      this.dragClone.style.left = (e.x - this.dragOffsetX) + 'px';\par
      this.dragClone.style.top = (e.y - this.dragOffsetY) + 'px';\par
    \},\par
\par
    /**\par
     * The handler for dragend events fired on |this|.\par
     * @param \{Event\} e The event for the drag.\par
     * @private\par
     */\par
    onDragEnd_: function(e) \{\par
      this.dragClone.hidden = false;\par
      this.dragClone.classList.add('placing');\par
\par
      setCurrentlyDraggingTile(null);\par
\par
      // tilePage will be null if we've already been removed.\par
      var tilePage = this.tilePage;\par
      if (tilePage)\par
        tilePage.positionTile_(this.index);\par
\par
      // Take an appropriate action with the drag clone.\par
      if (this.landedOnTrash) \{\par
        this.dragClone.classList.add('deleting');\par
      \} else if (tilePage) \{\par
        // TODO(dbeam): Until we fix dropEffect to the correct behavior it will\par
        // differ on windows - crbug.com/39399.  That's why we use the custom\par
        // this.lastDropEffect instead of e.dataTransfer.dropEffect.\par
        if (tilePage.selected && this.lastDropEffect != 'copy') \{\par
          // The drag clone can still be hidden from the last drag move event.\par
          this.dragClone.hidden = false;\par
          // The tile's contents may have moved following the respositioning;\par
          // adjust for that.\par
          var contentDiffX = this.dragClone.firstChild.offsetLeft -\par
              this.firstChild.offsetLeft;\par
          var contentDiffY = this.dragClone.firstChild.offsetTop -\par
              this.firstChild.offsetTop;\par
          this.dragClone.style.left = (this.gridX + this.parentNode.offsetLeft -\par
              contentDiffX) + 'px';\par
          this.dragClone.style.top =\par
              (this.gridY + this.parentNode.getBoundingClientRect().top -\par
              contentDiffY) + 'px';\par
        \} else if (this.dragClone.hidden) \{\par
          this.finalizeDrag_();\par
        \} else \{\par
          // The CSS3 transitions spec intentionally leaves it up to individual\par
          // user agents to determine when styles should be applied. On some\par
          // platforms (at the moment, Windows), when you apply both classes\par
          // immediately a transition may not occur correctly. That's why we're\par
          // using a setTimeout here to queue adding the class until the\par
          // previous class (currently: .placing) sets up a transition.\par
          // {{\field{\*\fldinst{HYPERLINK http://dev.w3.org/csswg/css3-transitions/#starting }}{\fldrslt{http://dev.w3.org/csswg/css3-transitions/#starting\ul0\cf0}}}}\f0\fs22\par
          window.setTimeout(function() \{\par
            if (this.dragClone)\par
              this.dragClone.classList.add('dropped-on-other-page');\par
          \}.bind(this), 0);\par
        \}\par
      \}\par
\par
      delete this.lastDropEffect;\par
      this.landedOnTrash = false;\par
    \},\par
\par
    /**\par
     * Creates a clone of this node offset by the coordinates. Used for the\par
     * dragging effect where a tile appears to float off one side of the grid\par
     * and re-appear on the other.\par
     * @param \{number\} x x-axis offset, in pixels.\par
     * @param \{number\} y y-axis offset, in pixels.\par
     */\par
    showDoppleganger: function(x, y) \{\par
      // We always have to clear the previous doppleganger to make sure we get\par
      // style updates for the contents of this tile.\par
      this.clearDoppleganger();\par
\par
      var clone = this.cloneNode(true);\par
      clone.classList.remove('real');\par
      clone.classList.add('doppleganger');\par
      var clonelets = clone.querySelectorAll('.real');\par
      for (var i = 0; i < clonelets.length; i++) \{\par
        clonelets[i].classList.remove('real');\par
      \}\par
\par
      this.appendChild(clone);\par
      this.doppleganger_ = clone;\par
\par
      if (isRTL())\par
        x *= -1;\par
\par
      this.doppleganger_.style.WebkitTransform = 'translate(' + x + 'px, ' +\par
                                                                y + 'px)';\par
    \},\par
\par
    /**\par
     * Destroys the current doppleganger.\par
     */\par
    clearDoppleganger: function() \{\par
      if (this.doppleganger_) \{\par
        this.removeChild(this.doppleganger_);\par
        this.doppleganger_ = null;\par
      \}\par
    \},\par
\par
    /**\par
     * Returns status of doppleganger.\par
     * @return \{boolean\} True if there is a doppleganger showing for |this|.\par
     */\par
    hasDoppleganger: function() \{\par
      return !!this.doppleganger_;\par
    \},\par
\par
    /**\par
     * Cleans up after the drag is over. This is either called when the\par
     * drag representation finishes animating to the final position, or when\par
     * the next drag starts (if the user starts a 2nd drag very quickly).\par
     * @private\par
     */\par
    finalizeDrag_: function() \{\par
      assert(this.classList.contains('dragging'));\par
\par
      var clone = this.dragClone;\par
      this.dragClone = null;\par
\par
      clone.parentNode.removeChild(clone);\par
      this.eventTracker.remove(clone, 'webkitTransitionEnd');\par
      this.classList.remove('dragging');\par
      if (this.firstChild.finalizeDrag)\par
        this.firstChild.finalizeDrag();\par
    \},\par
\par
    /**\par
     * Called when the drag representation node is done migrating to its final\par
     * resting spot.\par
     * @param \{Event\} e The transition end event.\par
     */\par
    onDragCloneTransitionEnd_: function(e) \{\par
      if (this.classList.contains('dragging') &&\par
          (e.propertyName == 'left' || e.propertyName == 'top' ||\par
           e.propertyName == '-webkit-transform')) \{\par
        this.finalizeDrag_();\par
      \}\par
    \},\par
\par
    /**\par
     * Called when an app is removed from Chrome. Animates its disappearance.\par
     * @param \{boolean=\} opt_animate Whether the animation should be animated.\par
     */\par
    doRemove: function(opt_animate) \{\par
      if (opt_animate)\par
        this.firstChild.classList.add('removing-tile-contents');\par
      else\par
        this.tilePage.removeTile(this, false);\par
    \},\par
\par
    /**\par
     * Callback for the webkitAnimationEnd event on the tile's contents.\par
     * @param \{Event\} e The event object.\par
     */\par
    onContentsAnimationEnd_: function(e) \{\par
      if (this.firstChild.classList.contains('new-tile-contents'))\par
        this.firstChild.classList.remove('new-tile-contents');\par
      if (this.firstChild.classList.contains('removing-tile-contents'))\par
        this.tilePage.removeTile(this, true);\par
    \},\par
  \};\par
\par
  /**\par
   * Gives the proportion of the row width that is devoted to a single icon.\par
   * @param \{number\} rowTileCount The number of tiles in a row.\par
   * @param \{number\} tileSpacingFraction The proportion of the tile width which\par
   *     will be used as spacing between tiles.\par
   * @return \{number\} The ratio between icon width and row width.\par
   */\par
  function tileWidthFraction(rowTileCount, tileSpacingFraction) \{\par
    return rowTileCount + (rowTileCount - 1) * tileSpacingFraction;\par
  \}\par
\par
  /**\par
   * Calculates an assortment of tile-related values for a grid with the\par
   * given dimensions.\par
   * @param \{number\} width The pixel width of the grid.\par
   * @param \{number\} numRowTiles The number of tiles in a row.\par
   * @param \{number\} tileSpacingFraction The proportion of the tile width which\par
   *     will be used as spacing between tiles.\par
   * @return \{Object\} A mapping of pixel values.\par
   */\par
  function tileValuesForGrid(width, numRowTiles, tileSpacingFraction) \{\par
    var tileWidth = width / tileWidthFraction(numRowTiles, tileSpacingFraction);\par
    var offsetX = tileWidth * (1 + tileSpacingFraction);\par
    var interTileSpacing = offsetX - tileWidth;\par
\par
    return \{\par
      tileWidth: tileWidth,\par
      offsetX: offsetX,\par
      interTileSpacing: interTileSpacing,\par
    \};\par
  \}\par
\par
  // The smallest amount of horizontal blank space to display on the sides when\par
  // displaying a wide arrangement. There is an additional 26px of margin from\par
  // the tile page padding.\par
  var MIN_WIDE_MARGIN = 18;\par
\par
  /**\par
   * Creates a new TilePage object. This object contains tiles and controls\par
   * their layout.\par
   * @param \{Object\} gridValues Pixel values that define the size and layout\par
   *     of the tile grid.\par
   * @constructor\par
   * @extends \{HTMLDivElement\}\par
   */\par
  function TilePage(gridValues) \{\par
    var el = cr.doc.createElement('div');\par
    el.gridValues_ = gridValues;\par
    el.__proto__ = TilePage.prototype;\par
    el.initialize();\par
\par
    return el;\par
  \}\par
\par
  /**\par
   * Takes a collection of grid layout pixel values and updates them with\par
   * additional tiling values that are calculated from TilePage constants.\par
   * @param \{Object\} grid The grid layout pixel values to update.\par
   */\par
  TilePage.initGridValues = function(grid) \{\par
    // The amount of space we need to display a narrow grid (all narrow grids\par
    // are this size).\par
    grid.narrowWidth =\par
        grid.minTileWidth * tileWidthFraction(grid.minColCount,\par
                                              grid.tileSpacingFraction);\par
    // The minimum amount of space we need to display a wide grid.\par
    grid.minWideWidth =\par
        grid.minTileWidth * tileWidthFraction(grid.maxColCount,\par
                                              grid.tileSpacingFraction);\par
    // The largest we will ever display a wide grid.\par
    grid.maxWideWidth =\par
        grid.maxTileWidth * tileWidthFraction(grid.maxColCount,\par
                                              grid.tileSpacingFraction);\par
    // Tile-related pixel values for the narrow display.\par
    grid.narrowTileValues = tileValuesForGrid(grid.narrowWidth,\par
                                              grid.minColCount,\par
                                              grid.tileSpacingFraction);\par
    // Tile-related pixel values for the minimum narrow display.\par
    grid.wideTileValues = tileValuesForGrid(grid.minWideWidth,\par
                                            grid.maxColCount,\par
                                            grid.tileSpacingFraction);\par
  \};\par
\par
  TilePage.prototype = \{\par
    __proto__: HTMLDivElement.prototype,\par
\par
    initialize: function() \{\par
      this.className = 'tile-page';\par
\par
      // Div that acts as a custom scrollbar. The scrollbar has to live\par
      // outside the content div so it doesn't flicker when scrolling (due to\par
      // repainting after the scroll, then repainting again when moved in the\par
      // onScroll handler). |scrollbar_| is only aesthetic, and it only\par
      // represents the thumb. Actual events are still handled by the invisible\par
      // native scrollbars. This div gives us more flexibility with the visuals.\par
      this.scrollbar_ = this.ownerDocument.createElement('div');\par
      this.scrollbar_.className = 'tile-page-scrollbar';\par
      this.scrollbar_.hidden = true;\par
      this.appendChild(this.scrollbar_);\par
\par
      // This contains everything but the scrollbar.\par
      this.content_ = this.ownerDocument.createElement('div');\par
      this.content_.className = 'tile-page-content';\par
      this.appendChild(this.content_);\par
\par
      // Div that sets the vertical position of the tile grid.\par
      this.topMargin_ = this.ownerDocument.createElement('div');\par
      this.topMargin_.className = 'top-margin';\par
      this.content_.appendChild(this.topMargin_);\par
\par
      // Div that holds the tiles.\par
      this.tileGrid_ = this.ownerDocument.createElement('div');\par
      this.tileGrid_.className = 'tile-grid';\par
      this.tileGrid_.style.minWidth = this.gridValues_.narrowWidth + 'px';\par
      this.content_.appendChild(this.tileGrid_);\par
\par
      // Ordered list of our tiles.\par
      this.tileElements_ = this.tileGrid_.getElementsByClassName('tile real');\par
      // Ordered list of the elements which want to accept keyboard focus. These\par
      // elements will not be a part of the normal tab order; the tile grid\par
      // initially gets focused and then these elements can be focused via the\par
      // arrow keys.\par
      this.focusableElements_ =\par
          this.tileGrid_.getElementsByClassName('focusable');\par
\par
      // These are properties used in updateTopMargin.\par
      this.animatedTopMarginPx_ = 0;\par
      this.topMarginPx_ = 0;\par
\par
      this.eventTracker = new EventTracker();\par
      this.eventTracker.add(window, 'resize', this.onResize_.bind(this));\par
\par
      this.addEventListener('DOMNodeInsertedIntoDocument',\par
                            this.onNodeInsertedIntoDocument_);\par
\par
      this.addEventListener('mousewheel', this.onMouseWheel_);\par
      this.content_.addEventListener('scroll', this.onScroll_.bind(this));\par
\par
      this.dragWrapper_ = new cr.ui.DragWrapper(this.tileGrid_, this);\par
\par
      this.addEventListener('cardselected', this.handleCardSelection_);\par
      this.addEventListener('carddeselected', this.handleCardDeselection_);\par
      this.addEventListener('focus', this.handleFocus_);\par
      this.addEventListener('keydown', this.handleKeyDown_);\par
      this.addEventListener('mousedown', this.handleMouseDown_);\par
\par
      this.focusElementIndex_ = -1;\par
    \},\par
\par
    get tiles() \{\par
      return this.tileElements_;\par
    \},\par
\par
    get tileCount() \{\par
      return this.tileElements_.length;\par
    \},\par
\par
    get selected() \{\par
      return Array.prototype.indexOf.call(this.parentNode.children, this) ==\par
          ntp4.getCardSlider().currentCard;\par
    \},\par
\par
    /**\par
     * The size of the margin (unused space) on the sides of the tile grid, in\par
     * pixels.\par
     * @type \{number\}\par
     */\par
    get sideMargin() \{\par
      return this.layoutValues_.leftMargin;\par
    \},\par
\par
    /**\par
     * Returns the width of the scrollbar, in pixels, if it is active, or 0\par
     * otherwise.\par
     * @type \{number\}\par
     */\par
    get scrollbarWidth() \{\par
      return this.scrollbar_.hidden ? 0 : 13;\par
    \},\par
\par
    /**\par
     * Returns any extra padding to insert to the bottom of a tile page.  By\par
     * default there is none, but subclasses can override.\par
     * @type \{number\}\par
     */\par
    get extraBottomPadding() \{\par
      return 0;\par
    \},\par
\par
    /**\par
     * Removes the tilePage from the DOM and cleans up event handlers.\par
     */\par
    remove: function() \{\par
      // This checks arguments.length as most remove functions have a boolean\par
      // |opt_animate| argument, but that's not necesarilly applicable to\par
      // removing a tilePage. Selecting a different card in an animated way and\par
      // deleting the card afterward is probably a better choice.\par
      assert(typeof arguments[0] != 'boolean',\par
             'This function takes no |opt_animate| argument.');\par
      this.tearDown_();\par
      this.parentNode.removeChild(this);\par
    \},\par
\par
    /**\par
     * Cleans up resources that are no longer needed after this TilePage\par
     * instance is removed from the DOM.\par
     * @private\par
     */\par
    tearDown_: function() \{\par
      this.eventTracker.removeAll();\par
    \},\par
\par
    /**\par
     * Appends a tile to the end of the tile grid.\par
     * @param \{HTMLElement\} tileElement The contents of the tile.\par
     * @param \{?boolean\} animate If true, the append will be animated.\par
     * @protected\par
     */\par
    appendTile: function(tileElement, animate) \{\par
      this.addTileAt(tileElement, this.tileElements_.length, animate);\par
    \},\par
\par
    /**\par
     * Adds the given element to the tile grid.\par
     * @param \{Node\} tileElement The tile object/node to insert.\par
     * @param \{number\} index The location in the tile grid to insert it at.\par
     * @param \{boolean=\} opt_animate If true, the tile in question will be\par
     *     animated (other tiles, if they must reposition, do not animate).\par
     * @protected\par
     */\par
    addTileAt: function(tileElement, index, opt_animate) \{\par
      this.classList.remove('animating-tile-page');\par
      if (opt_animate)\par
        tileElement.classList.add('new-tile-contents');\par
\par
      // Make sure the index is positive and either in the the bounds of\par
      // this.tileElements_ or at the end (meaning append).\par
      assert(index >= 0 && index <= this.tileElements_.length);\par
\par
      var wrapperDiv = new Tile(tileElement);\par
      // If is out of the bounds of the tile element list, .insertBefore() will\par
      // act just like appendChild().\par
      this.tileGrid_.insertBefore(wrapperDiv, this.tileElements_[index]);\par
      this.calculateLayoutValues_();\par
      this.heightChanged_();\par
\par
      this.positionTile_(index);\par
      this.fireAddedEvent(wrapperDiv, index, !!opt_animate);\par
    \},\par
\par
    /**\par
     * Notify interested subscribers that a tile has been removed from this\par
     * page.\par
     * @param \{Tile\} tile The newly added tile.\par
     * @param \{number\} index The index of the tile that was added.\par
     * @param \{boolean\} wasAnimated Whether the removal was animated.\par
     */\par
    fireAddedEvent: function(tile, index, wasAnimated) \{\par
      var e = document.createEvent('Event');\par
      e.initEvent('tilePage:tile_added', true, true);\par
      e.addedIndex = index;\par
      e.addedTile = tile;\par
      e.wasAnimated = wasAnimated;\par
      this.dispatchEvent(e);\par
    \},\par
\par
    /**\par
     * Removes the given tile and animates the repositioning of the other tiles.\par
     * @param \{boolean=\} opt_animate Whether the removal should be animated.\par
     * @param \{boolean=\} opt_dontNotify Whether a page should be removed if the\par
     *     last tile is removed from it.\par
     */\par
    removeTile: function(tile, opt_animate, opt_dontNotify) \{\par
      if (opt_animate)\par
        this.classList.add('animating-tile-page');\par
      var index = tile.index;\par
      tile.parentNode.removeChild(tile);\par
      this.calculateLayoutValues_();\par
      this.cleanupDrag();\par
\par
      if (!opt_dontNotify)\par
        this.fireRemovedEvent(tile, index, !!opt_animate);\par
    \},\par
\par
    /**\par
     * Notify interested subscribers that a tile has been removed from this\par
     * page.\par
     * @param \{Tile\} tile The tile that was removed.\par
     * @param \{number\} oldIndex Where the tile was positioned before removal.\par
     * @param \{boolean\} wasAnimated Whether the removal was animated.\par
     */\par
    fireRemovedEvent: function(tile, oldIndex, wasAnimated) \{\par
      var e = document.createEvent('Event');\par
      e.initEvent('tilePage:tile_removed', true, true);\par
      e.removedIndex = oldIndex;\par
      e.removedTile = tile;\par
      e.wasAnimated = wasAnimated;\par
      this.dispatchEvent(e);\par
    \},\par
\par
    /**\par
     * Removes all tiles from the page.\par
     */\par
    removeAllTiles: function() \{\par
      this.tileGrid_.innerHTML = '';\par
    \},\par
\par
    /**\par
     * Called when the page is selected (in the card selector).\par
     * @param \{Event\} e A custom cardselected event.\par
     * @private\par
     */\par
    handleCardSelection_: function(e) \{\par
      this.tabIndex = 1;\par
\par
      // When we are selected, we re-calculate the layout values. (See comment\par
      // in doDrop.)\par
      this.calculateLayoutValues_();\par
    \},\par
\par
    /**\par
     * Called when the page loses selection (in the card selector).\par
     * @param \{Event\} e A custom carddeselected event.\par
     * @private\par
     */\par
    handleCardDeselection_: function(e) \{\par
      this.tabIndex = -1;\par
      if (this.currentFocusElement_)\par
        this.currentFocusElement_.tabIndex = -1;\par
    \},\par
\par
    /**\par
     * When we get focus, pass it on to the focus element.\par
     * @param \{Event\} e The focus event.\par
     * @private\par
     */\par
    handleFocus_: function(e) \{\par
      if (this.focusableElements_.length == 0)\par
        return;\par
\par
      this.updateFocusElement_();\par
    \},\par
\par
    /**\par
     * Since we are doing custom focus handling, we have to manually\par
     * set focusability on click (as well as keyboard nav above).\par
     * @param \{Event\} e The focus event.\par
     * @private\par
     */\par
    handleMouseDown_: function(e) \{\par
      var focusable = findAncestorByClass(e.target, 'focusable');\par
      if (focusable) \{\par
        this.focusElementIndex_ =\par
            Array.prototype.indexOf.call(this.focusableElements_,\par
                                         focusable);\par
        this.updateFocusElement_();\par
      \} else \{\par
        // This prevents the tile page from getting focus when the user clicks\par
        // inside the grid but outside of any tile.\par
        e.preventDefault();\par
      \}\par
    \},\par
\par
    /**\par
     * Handle arrow key focus nav.\par
     * @param \{Event\} e The focus event.\par
     * @private\par
     */\par
    handleKeyDown_: function(e) \{\par
      // We only handle up, down, left, right without control keys.\par
      if (e.metaKey || e.shiftKey || e.altKey || e.ctrlKey)\par
        return;\par
\par
      // Wrap the given index to |this.focusableElements_|.\par
      var wrap = function(idx) \{\par
        return (idx + this.focusableElements_.length) %\par
            this.focusableElements_.length;\par
      \}.bind(this);\par
\par
      switch (e.keyIdentifier) \{\par
        case 'Right':\par
        case 'Left':\par
          var direction = e.keyIdentifier == 'Right' ? 1 : -1;\par
          this.focusElementIndex_ = wrap(this.focusElementIndex_ + direction);\par
          break;\par
        case 'Up':\par
        case 'Down':\par
          // Look through all focusable elements. Find the first one that is\par
          // in the same column.\par
          var direction = e.keyIdentifier == 'Up' ? -1 : 1;\par
          var currentIndex =\par
              Array.prototype.indexOf.call(this.focusableElements_,\par
                                           this.currentFocusElement_);\par
          var newFocusIdx = wrap(currentIndex + direction)\par
          var tile = this.currentFocusElement_.parentNode;\par
          for (;; newFocusIdx = wrap(newFocusIdx + direction)) \{\par
            var newTile = this.focusableElements_[newFocusIdx].parentNode;\par
            var rowTiles = this.layoutValues_.numRowTiles;\par
            if ((newTile.index - tile.index) % rowTiles == 0)\par
              break;\par
          \}\par
\par
          this.focusElementIndex_ = newFocusIdx;\par
          break;\par
\par
        default:\par
          return;\par
      \}\par
\par
      this.updateFocusElement_();\par
\par
      e.preventDefault();\par
      e.stopPropagation();\par
    \},\par
\par
    /**\par
     * Focuses the element for |this.focusElementIndex_|. Makes the current\par
     * focus element, if any, no longer eligible for focus.\par
     * @private\par
     */\par
    updateFocusElement_: function() \{\par
      this.focusElementIndex_ = Math.min(this.focusableElements_.length - 1,\par
                                         this.focusElementIndex_);\par
      this.focusElementIndex_ = Math.max(0, this.focusElementIndex_);\par
\par
      var newFocusElement = this.focusableElements_[this.focusElementIndex_];\par
      var lastFocusElement = this.currentFocusElement_;\par
      if (lastFocusElement && lastFocusElement != newFocusElement)\par
        lastFocusElement.tabIndex = -1;\par
\par
      newFocusElement.tabIndex = 1;\par
      newFocusElement.focus();\par
      this.tabIndex = -1;\par
    \},\par
\par
    /**\par
     * The current focus element is that element which is eligible for focus.\par
     * @type \{HTMLElement\} The node.\par
     * @private\par
     */\par
    get currentFocusElement_() \{\par
      return this.querySelector('.focusable[tabindex="1"]');\par
    \},\par
\par
    /**\par
     * Makes some calculations for tile layout. These change depending on\par
     * height, width, and the number of tiles.\par
     * TODO(estade): optimize calls to this function. Do nothing if the page is\par
     * hidden, but call before being shown.\par
     * @private\par
     */\par
    calculateLayoutValues_: function() \{\par
      var grid = this.gridValues_;\par
      var availableSpace = this.tileGrid_.clientWidth - 2 * MIN_WIDE_MARGIN;\par
      var wide = availableSpace >= grid.minWideWidth;\par
      var numRowTiles = wide ? grid.maxColCount : grid.minColCount;\par
\par
      var effectiveGridWidth = wide ?\par
          Math.min(Math.max(availableSpace, grid.minWideWidth),\par
                   grid.maxWideWidth) :\par
          grid.narrowWidth;\par
      var realTileValues = tileValuesForGrid(effectiveGridWidth, numRowTiles,\par
                                             grid.tileSpacingFraction);\par
\par
      // leftMargin centers the grid within the avaiable space.\par
      var minMargin = wide ? MIN_WIDE_MARGIN : 0;\par
      var leftMargin =\par
          Math.max(minMargin,\par
                   (this.tileGrid_.clientWidth - effectiveGridWidth) / 2);\par
\par
      var rowHeight = this.heightForWidth(realTileValues.tileWidth) +\par
          realTileValues.interTileSpacing;\par
\par
      this.layoutValues_ = \{\par
        numRowTiles: numRowTiles,\par
        leftMargin: leftMargin,\par
        colWidth: realTileValues.offsetX,\par
        rowHeight: rowHeight,\par
        tileWidth: realTileValues.tileWidth,\par
        wide: wide,\par
      \};\par
\par
      // We need to update the top margin as well.\par
      this.updateTopMargin_();\par
\par
      this.firePageLayoutEvent_();\par
    \},\par
\par
    /**\par
     * Dispatches the custom pagelayout event.\par
     * @private\par
     */\par
    firePageLayoutEvent_: function() \{\par
      cr.dispatchSimpleEvent(this, 'pagelayout', true, true);\par
    \},\par
\par
    /**\par
     * Calculates the x/y coordinates for an element and moves it there.\par
     * @param \{number\} index The index of the element to be positioned.\par
     * @param \{number\} indexOffset If provided, this is added to |index| when\par
     *     positioning the tile. The effect is that the tile will be positioned\par
     *     in a non-default location.\par
     * @private\par
     */\par
    positionTile_: function(index, indexOffset) \{\par
      var grid = this.gridValues_;\par
      var layout = this.layoutValues_;\par
\par
      indexOffset = typeof indexOffset != 'undefined' ? indexOffset : 0;\par
      // Add the offset _after_ the modulus division. We might want to show the\par
      // tile off the side of the grid.\par
      var col = index % layout.numRowTiles + indexOffset;\par
      var row = Math.floor(index / layout.numRowTiles);\par
      // Calculate the final on-screen position for the tile.\par
      var realX = col * layout.colWidth + layout.leftMargin;\par
      var realY = row * layout.rowHeight;\par
\par
      // Calculate the portion of the tile's position that should be animated.\par
      var animatedTileValues = layout.wide ?\par
          grid.wideTileValues : grid.narrowTileValues;\par
      // Animate the difference between three-wide and six-wide.\par
      var animatedLeftMargin = layout.wide ?\par
          0 : (grid.minWideWidth - MIN_WIDE_MARGIN - grid.narrowWidth) / 2;\par
      var animatedX = col * animatedTileValues.offsetX + animatedLeftMargin;\par
      var animatedY = row * (this.heightForWidth(animatedTileValues.tileWidth) +\par
                             animatedTileValues.interTileSpacing);\par
\par
      var tile = this.tileElements_[index];\par
      tile.setGridPosition(animatedX, animatedY);\par
      tile.firstChild.setBounds(layout.tileWidth,\par
                                realX - animatedX,\par
                                realY - animatedY);\par
\par
      // This code calculates whether the tile needs to show a clone of itself\par
      // wrapped around the other side of the tile grid.\par
      var offTheRight = col == layout.numRowTiles ||\par
          (col == layout.numRowTiles - 1 && tile.hasDoppleganger());\par
      var offTheLeft = col == -1 || (col == 0 && tile.hasDoppleganger());\par
      if (this.isCurrentDragTarget && (offTheRight || offTheLeft)) \{\par
        var sign = offTheRight ? 1 : -1;\par
        tile.showDoppleganger(-layout.numRowTiles * layout.colWidth * sign,\par
                              layout.rowHeight * sign);\par
      \} else \{\par
        tile.clearDoppleganger();\par
      \}\par
\par
      if (index == this.tileElements_.length - 1) \{\par
        this.tileGrid_.style.height = (realY + layout.rowHeight) + 'px';\par
        this.queueUpdateScrollbars_();\par
      \}\par
    \},\par
\par
    /**\par
     * Gets the index of the tile that should occupy coordinate (x, y). Note\par
     * that this function doesn't care where the tiles actually are, and will\par
     * return an index even for the space between two tiles. This function is\par
     * effectively the inverse of |positionTile_|.\par
     * @param \{number\} x The x coordinate, in pixels, relative to the left of\par
     *     |this|.\par
     * @param \{number\} y The y coordinate, in pixels, relative to the top of\par
     *     |this|.\par
     * @private\par
     */\par
    getWouldBeIndexForPoint_: function(x, y) \{\par
      var grid = this.gridValues_;\par
      var layout = this.layoutValues_;\par
\par
      var gridClientRect = this.tileGrid_.getBoundingClientRect();\par
      var col = Math.floor((x - gridClientRect.left - layout.leftMargin) /\par
                           layout.colWidth);\par
      if (col < 0 || col >= layout.numRowTiles)\par
        return -1;\par
\par
      if (isRTL())\par
        col = layout.numRowTiles - 1 - col;\par
\par
      var row = Math.floor((y - gridClientRect.top) / layout.rowHeight);\par
      return row * layout.numRowTiles + col;\par
    \},\par
\par
    /**\par
     * Window resize event handler. Window resizes may trigger re-layouts.\par
     * @param \{Object\} e The resize event.\par
     */\par
    onResize_: function(e) \{\par
      if (this.lastWidth_ == this.clientWidth &&\par
          this.lastHeight_ == this.clientHeight) \{\par
        return;\par
      \}\par
\par
      this.calculateLayoutValues_();\par
\par
      this.lastWidth_ = this.clientWidth;\par
      this.lastHeight_ = this.clientHeight;\par
      this.classList.add('animating-tile-page');\par
      this.heightChanged_();\par
\par
      this.repositionTiles_();\par
    \},\par
\par
    /**\par
     * The tile grid has an image mask which fades at the edges. We only show\par
     * the mask when there is an active drag; it obscures doppleganger tiles\par
     * as they enter or exit the grid.\par
     * @private\par
     */\par
    updateMask_: function() \{\par
      if (!this.isCurrentDragTarget) \{\par
        this.tileGrid_.style.WebkitMaskBoxImage = '';\par
        return;\par
      \}\par
\par
      var leftMargin = this.layoutValues_.leftMargin;\par
      // The fade distance is the space between tiles.\par
      var fadeDistance = (this.gridValues_.tileSpacingFraction *\par
          this.layoutValues_.tileWidth);\par
      fadeDistance = Math.min(leftMargin, fadeDistance);\par
      // On Skia we don't use any fade because it works very poorly. See\par
      // {{\field{\*\fldinst{HYPERLINK http://crbug.com/99373 }}{\fldrslt{http://crbug.com/99373\ul0\cf0}}}}\f0\fs22\par
      if (!cr.isMac)\par
        fadeDistance = 1;\par
      var gradient =\par
          '-webkit-linear-gradient(left,' +\par
              'transparent, ' +\par
              'transparent ' + (leftMargin - fadeDistance) + 'px, ' +\par
              'black ' + leftMargin + 'px, ' +\par
              'black ' + (this.tileGrid_.clientWidth - leftMargin) + 'px, ' +\par
              'transparent ' + (this.tileGrid_.clientWidth - leftMargin +\par
                                fadeDistance) + 'px, ' +\par
              'transparent)';\par
      this.tileGrid_.style.WebkitMaskBoxImage = gradient;\par
    \},\par
\par
    updateTopMargin_: function() \{\par
      var layout = this.layoutValues_;\par
\par
      // The top margin is set so that the vertical midpoint of the grid will\par
      // be 1/3 down the page.\par
      var numTiles = this.tileCount +\par
          (this.isCurrentDragTarget && !this.withinPageDrag_ ? 1 : 0);\par
      var numRows = Math.ceil(numTiles / layout.numRowTiles);\par
      var usedHeight = layout.rowHeight * numRows;\par
      // 60 matches the top padding of tile-page (which acts as the minimum).\par
      var newMargin = document.documentElement.clientHeight / 3 -\par
          usedHeight / 3 - 60;\par
      newMargin = Math.max(newMargin, 0);\par
\par
      // |newMargin| is the final margin we actually want to show. However,\par
      // part of that should be animated and part should not (for the same\par
      // reason as with leftMargin). The approach is to consider differences\par
      // when the layout changes from wide to narrow or vice versa as\par
      // 'animatable'. These differences accumulate in animatedTopMarginPx_,\par
      // while topMarginPx_ caches the real (total) margin. Either of these\par
      // calculations may come out to be negative, so we use margins as the\par
      // css property.\par
\par
      if (typeof this.topMarginIsForWide_ == 'undefined')\par
        this.topMarginIsForWide_ = layout.wide;\par
      if (this.topMarginIsForWide_ != layout.wide) \{\par
        this.animatedTopMarginPx_ += newMargin - this.topMarginPx_;\par
        this.topMargin_.style.marginBottom =\par
            this.animatedTopMarginPx_ + 'px';\par
      \}\par
\par
      this.topMarginIsForWide_ = layout.wide;\par
      this.topMarginPx_ = newMargin;\par
      this.topMargin_.style.marginTop =\par
          (this.topMarginPx_ - this.animatedTopMarginPx_) + 'px';\par
    \},\par
\par
    /**\par
     * Handles final setup that can only happen after |this| is inserted into\par
     * the page.\par
     * @private\par
     */\par
    onNodeInsertedIntoDocument_: function(e) \{\par
      this.calculateLayoutValues_();\par
      this.heightChanged_();\par
    \},\par
\par
    /**\par
     * Called when the height of |this| has changed: update the size of\par
     * tileGrid.\par
     * @private\par
     */\par
    heightChanged_: function() \{\par
      // The tile grid will expand to the bottom footer, or enough to hold all\par
      // the tiles, whichever is greater. It would be nicer if tilePage were\par
      // a flex box, and the tile grid could be box-flex: 1, but this exposes a\par
      // bug where repositioning tiles will cause the scroll position to reset.\par
      this.tileGrid_.style.minHeight = (this.clientHeight -\par
          this.tileGrid_.offsetTop - this.content_.offsetTop -\par
          this.extraBottomPadding) + 'px';\par
    \},\par
\par
    /**\par
     * Scrolls the page in response to a mousewheel event.\par
     * @param \{Event\} e The mousewheel event.\par
     */\par
    handleMouseWheel: function(e) \{\par
      this.content_.scrollTop -= e.wheelDeltaY / 3;\par
    \},\par
\par
    /**\par
     * Handles mouse wheels on |this|. We handle this explicitly because we want\par
     * a consistent experience whether the user scrolls on the page or on the\par
     * page switcher (handleMouseWheel provides a common conversion factor\par
     * between wheel delta and scroll delta).\par
     * @param \{Event\} e The mousewheel event.\par
     * @private\par
     */\par
    onMouseWheel_: function(e) \{\par
      if (e.wheelDeltaY == 0)\par
        return;\par
\par
      this.handleMouseWheel(e);\par
      e.preventDefault();\par
      e.stopPropagation();\par
    \},\par
\par
    /**\par
     * Handler for the 'scroll' event on |content_|.\par
     * @param \{Event\} e The scroll event.\par
     * @private\par
     */\par
    onScroll_: function(e) \{\par
      this.queueUpdateScrollbars_();\par
    \},\par
\par
    /**\par
     * ID of scrollbar update timer. If 0, there's no scrollbar re-calc queued.\par
     * @private\par
     */\par
    scrollbarUpdate_: 0,\par
\par
    /**\par
     * Queues an update on the custom scrollbar. Used for two reasons: first,\par
     * coalescing of multiple updates, and second, because action like\par
     * repositioning a tile can require a delay before they affect values\par
     * like clientHeight.\par
     * @private\par
     */\par
    queueUpdateScrollbars_: function() \{\par
      if (this.scrollbarUpdate_)\par
        return;\par
\par
      this.scrollbarUpdate_ = window.setTimeout(\par
          this.doUpdateScrollbars_.bind(this), 0);\par
    \},\par
\par
    /**\par
     * Does the work of calculating the visibility, height and position of the\par
     * scrollbar thumb (there is no track or buttons).\par
     * @private\par
     */\par
    doUpdateScrollbars_: function() \{\par
      this.scrollbarUpdate_ = 0;\par
\par
      var content = this.content_;\par
\par
      // Adjust scroll-height to account for possible header-bar.\par
      var adjustedScrollHeight = content.scrollHeight - content.offsetTop;\par
\par
      if (adjustedScrollHeight <= content.clientHeight) \{\par
        this.scrollbar_.hidden = true;\par
        return;\par
      \} else \{\par
        this.scrollbar_.hidden = false;\par
      \}\par
\par
      var thumbTop = content.offsetTop +\par
          content.scrollTop / adjustedScrollHeight * content.clientHeight;\par
      var thumbHeight = content.clientHeight / adjustedScrollHeight *\par
          this.clientHeight;\par
\par
      this.scrollbar_.style.top = thumbTop + 'px';\par
      this.scrollbar_.style.height = thumbHeight + 'px';\par
      this.firePageLayoutEvent_();\par
    \},\par
\par
    /**\par
     * Get the height for a tile of a certain width. Override this function to\par
     * get non-square tiles.\par
     * @param \{number\} width The pixel width of a tile.\par
     * @return \{number\} The height for |width|.\par
     */\par
    heightForWidth: function(width) \{\par
      return width;\par
    \},\par
\par
    /** Dragging **/\par
\par
    get isCurrentDragTarget() \{\par
      return this.dragWrapper_.isCurrentDragTarget;\par
    \},\par
\par
    /**\par
     * Thunk for dragleave events fired on |tileGrid_|.\par
     * @param \{Event\} e A MouseEvent for the drag.\par
     */\par
    doDragLeave: function(e) \{\par
      this.cleanupDrag();\par
    \},\par
\par
    /**\par
     * Performs all actions necessary when a drag enters the tile page.\par
     * @param \{Event\} e A mouseover event for the drag enter.\par
     */\par
    doDragEnter: function(e) \{\par
\par
      // Applies the mask so doppleganger tiles disappear into the fog.\par
      this.updateMask_();\par
\par
      this.classList.add('animating-tile-page');\par
      this.withinPageDrag_ = this.contains(currentlyDraggingTile);\par
      this.dragItemIndex_ = this.withinPageDrag_ ?\par
          currentlyDraggingTile.index : this.tileElements_.length;\par
      this.currentDropIndex_ = this.dragItemIndex_;\par
\par
      // The new tile may change the number of rows, hence the top margin\par
      // will change.\par
      if (!this.withinPageDrag_)\par
        this.updateTopMargin_();\par
\par
      this.doDragOver(e);\par
    \},\par
\par
    /**\par
     * Performs all actions necessary when the user moves the cursor during\par
     * a drag over the tile page.\par
     * @param \{Event\} e A mouseover event for the drag over.\par
     */\par
    doDragOver: function(e) \{\par
      e.preventDefault();\par
\par
      this.setDropEffect(e.dataTransfer);\par
      var newDragIndex = this.getWouldBeIndexForPoint_(e.pageX, e.pageY);\par
      if (newDragIndex < 0 || newDragIndex >= this.tileElements_.length)\par
        newDragIndex = this.dragItemIndex_;\par
      this.updateDropIndicator_(newDragIndex);\par
    \},\par
\par
    /**\par
     * Performs all actions necessary when the user completes a drop.\par
     * @param \{Event\} e A mouseover event for the drag drop.\par
     */\par
    doDrop: function(e) \{\par
      e.stopPropagation();\par
\par
      var index = this.currentDropIndex_;\par
      // Only change data if this was not a 'null drag'.\par
      if (!((index == this.dragItemIndex_) && this.withinPageDrag_)) \{\par
        var adjustedIndex = this.currentDropIndex_ +\par
            (index > this.dragItemIndex_ ? 1 : 0);\par
        if (this.withinPageDrag_) \{\par
          this.tileGrid_.insertBefore(\par
              currentlyDraggingTile,\par
              this.tileElements_[adjustedIndex]);\par
          this.tileMoved(currentlyDraggingTile, this.dragItemIndex_);\par
        \} else \{\par
          var originalPage = currentlyDraggingTile ?\par
              currentlyDraggingTile.tilePage : null;\par
          this.addDragData(e.dataTransfer, adjustedIndex);\par
          if (originalPage)\par
            originalPage.cleanupDrag();\par
        \}\par
\par
        // Dropping the icon may cause topMargin to change, but changing it\par
        // now would cause everything to move (annoying), so we leave it\par
        // alone. The top margin will be re-calculated next time the window is\par
        // resized or the page is selected.\par
      \}\par
\par
      this.classList.remove('animating-tile-page');\par
      this.cleanupDrag();\par
    \},\par
\par
    /**\par
     * Appends the currently dragged tile to the end of the page. Called\par
     * from outside the page, e.g. when dropping on a nav dot.\par
     */\par
    appendDraggingTile: function() \{\par
      var originalPage = currentlyDraggingTile.tilePage;\par
      if (originalPage == this)\par
        return;\par
\par
      this.addDragData(null, this.tileElements_.length);\par
      if (originalPage)\par
        originalPage.cleanupDrag();\par
    \},\par
\par
    /**\par
     * Makes sure all the tiles are in the right place after a drag is over.\par
     */\par
    cleanupDrag: function() \{\par
      this.repositionTiles_(currentlyDraggingTile);\par
      // Remove the drag mask.\par
      this.updateMask_();\par
    \},\par
\par
    /**\par
     * Reposition all the tiles (possibly ignoring one).\par
     * @param \{?Node\} ignoreNode An optional node to ignore.\par
     * @private\par
     */\par
    repositionTiles_: function(ignoreNode) \{\par
      for (var i = 0; i < this.tileElements_.length; i++) \{\par
        if (!ignoreNode || ignoreNode !== this.tileElements_[i])\par
          this.positionTile_(i);\par
      \}\par
    \},\par
\par
    /**\par
     * Updates the visual indicator for the drop location for the active drag.\par
     * @param \{Event\} e A MouseEvent for the drag.\par
     * @private\par
     */\par
    updateDropIndicator_: function(newDragIndex) \{\par
      var oldDragIndex = this.currentDropIndex_;\par
      if (newDragIndex == oldDragIndex)\par
        return;\par
\par
      var repositionStart = Math.min(newDragIndex, oldDragIndex);\par
      var repositionEnd = Math.max(newDragIndex, oldDragIndex);\par
\par
      for (var i = repositionStart; i <= repositionEnd; i++) \{\par
        if (i == this.dragItemIndex_)\par
          continue;\par
        else if (i > this.dragItemIndex_)\par
          var adjustment = i <= newDragIndex ? -1 : 0;\par
        else\par
          var adjustment = i >= newDragIndex ? 1 : 0;\par
\par
        this.positionTile_(i, adjustment);\par
      \}\par
      this.currentDropIndex_ = newDragIndex;\par
    \},\par
\par
    /**\par
     * Checks if a page can accept a drag with the given data.\par
     * @param \{Event\} e The drag event if the drag object. Implementations will\par
     *     likely want to check |e.dataTransfer|.\par
     * @return \{boolean\} True if this page can handle the drag.\par
     */\par
    shouldAcceptDrag: function(e) \{\par
      return false;\par
    \},\par
\par
    /**\par
     * Called to accept a drag drop. Will not be called for in-page drops.\par
     * @param \{Object\} dataTransfer The data transfer object that holds the drop\par
     *     data. This should only be used if currentlyDraggingTile is null.\par
     * @param \{number\} index The tile index at which the drop occurred.\par
     */\par
    addDragData: function(dataTransfer, index) \{\par
      assert(false);\par
    \},\par
\par
    /**\par
     * Called when a tile has been moved (via dragging). Override this to make\par
     * backend updates.\par
     * @param \{Node\} draggedTile The tile that was dropped.\par
     * @param \{number\} prevIndex The previous index of the tile.\par
     */\par
    tileMoved: function(draggedTile, prevIndex) \{\par
    \},\par
\par
    /**\par
     * Sets the drop effect on |dataTransfer| to the desired value (e.g.\par
     * 'copy').\par
     * @param \{Object\} dataTransfer The drag event dataTransfer object.\par
     */\par
    setDropEffect: function(dataTransfer) \{\par
      assert(false);\par
    \},\par
  \};\par
\par
  return \{\par
    getCurrentlyDraggingTile: getCurrentlyDraggingTile,\par
    setCurrentDropEffect: setCurrentDropEffect,\par
    TilePage: TilePage,\par
  \};\par
\});\par
</script>\par
<script>// Copyright (c) 2012 The Chromium Authors. All rights reserved.\par
// Use of this source code is governed by a BSD-style license that can be\par
// found in the LICENSE file.\par
\par
cr.define('ntp4', function() \{\par
  'use strict';\par
\par
  var localStrings = new LocalStrings;\par
\par
  var APP_LAUNCH = \{\par
    // The histogram buckets (keep in sync with extension_constants.h).\par
    NTP_APPS_MAXIMIZED: 0,\par
    NTP_APPS_COLLAPSED: 1,\par
    NTP_APPS_MENU: 2,\par
    NTP_MOST_VISITED: 3,\par
    NTP_RECENTLY_CLOSED: 4,\par
    NTP_APP_RE_ENABLE: 16,\par
    NTP_WEBSTORE_FOOTER: 18,\par
  \};\par
\par
  // Histogram buckets for UMA tracking of where a DnD drop came from.\par
  var DRAG_SOURCE = \{\par
    SAME_APPS_PANE: 0,\par
    OTHER_APPS_PANE: 1,\par
    MOST_VISITED_PANE: 2,\par
    BOOKMARKS_PANE: 3,\par
    OUTSIDE_NTP: 4\par
  \};\par
  var DRAG_SOURCE_LIMIT = DRAG_SOURCE.OUTSIDE_NTP + 1;\par
\par
  /**\par
   * App context menu. The class is designed to be used as a singleton with\par
   * the app that is currently showing a context menu stored in this.app_.\par
   * @constructor\par
   */\par
  function AppContextMenu() \{\par
    this.__proto__ = AppContextMenu.prototype;\par
    this.initialize();\par
  \}\par
  cr.addSingletonGetter(AppContextMenu);\par
\par
  AppContextMenu.prototype = \{\par
    initialize: function() \{\par
      var menu = new cr.ui.Menu;\par
      cr.ui.decorate(menu, cr.ui.Menu);\par
      menu.classList.add('app-context-menu');\par
      this.menu = menu;\par
\par
      this.launch_ = this.appendMenuItem_();\par
      this.launch_.addEventListener('activate', this.onLaunch_.bind(this));\par
\par
      menu.appendChild(cr.ui.MenuItem.createSeparator());\par
      this.launchRegularTab_ = this.appendMenuItem_('applaunchtyperegular');\par
      this.launchPinnedTab_ = this.appendMenuItem_('applaunchtypepinned');\par
      if (!cr.isMac)\par
        this.launchNewWindow_ = this.appendMenuItem_('applaunchtypewindow');\par
      this.launchFullscreen_ = this.appendMenuItem_('applaunchtypefullscreen');\par
\par
      var self = this;\par
      this.forAllLaunchTypes_(function(launchTypeButton, id) \{\par
        launchTypeButton.addEventListener('activate',\par
            self.onLaunchTypeChanged_.bind(self));\par
      \});\par
\par
      menu.appendChild(cr.ui.MenuItem.createSeparator());\par
      this.options_ = this.appendMenuItem_('appoptions');\par
      this.disableNotifications_ =\par
          this.appendMenuItem_('appdisablenotifications');\par
      this.uninstall_ = this.appendMenuItem_('appuninstall');\par
      this.options_.addEventListener('activate',\par
                                     this.onShowOptions_.bind(this));\par
      this.disableNotifications_.addEventListener(\par
          'activate', this.onDisableNotifications_.bind(this));\par
      this.uninstall_.addEventListener('activate',\par
                                       this.onUninstall_.bind(this));\par
\par
      if (!cr.isMac && !cr.isChromeOS) \{\par
        menu.appendChild(cr.ui.MenuItem.createSeparator());\par
        this.createShortcut_ = this.appendMenuItem_('appcreateshortcut');\par
        this.createShortcut_.addEventListener(\par
            'activate', this.onCreateShortcut_.bind(this));\par
      \}\par
\par
      document.body.appendChild(menu);\par
    \},\par
\par
    /**\par
     * Appends a menu item to |this.menu|.\par
     * @param \{?String\} textId If non-null, the ID for the localized string\par
     *     that acts as the item's label.\par
     */\par
    appendMenuItem_: function(textId) \{\par
      var button = cr.doc.createElement('button');\par
      this.menu.appendChild(button);\par
      cr.ui.decorate(button, cr.ui.MenuItem);\par
      if (textId)\par
        button.textContent = localStrings.getString(textId);\par
      return button;\par
    \},\par
\par
    /**\par
     * Iterates over all the launch type menu items.\par
     * @param \{function(cr.ui.MenuItem, number)\} f The function to call for each\par
     *     menu item. The parameters to the function include the menu item and\par
     *     the associated launch ID.\par
     */\par
    forAllLaunchTypes_: function(f) \{\par
      // Order matters: index matches launchType id.\par
      var launchTypes = [ this.launchPinnedTab_,\par
                          this.launchRegularTab_,\par
                          this.launchFullscreen_,\par
                          this.launchNewWindow_ ];\par
\par
      for (var i = 0; i < launchTypes.length; ++i) \{\par
        if (!launchTypes[i])\par
          continue;\par
\par
        f(launchTypes[i], i);\par
      \}\par
    \},\par
\par
    /**\par
     * Does all the necessary setup to show the menu for the given app.\par
     * @param \{App\} app The App object that will be showing a context menu.\par
     */\par
    setupForApp: function(app) \{\par
      this.app_ = app;\par
\par
      this.launch_.textContent = app.appData.title;\par
\par
      this.forAllLaunchTypes_(function(launchTypeButton, id) \{\par
        launchTypeButton.disabled = false;\par
        launchTypeButton.checked = app.appData.launch_type == id;\par
      \});\par
\par
      this.options_.disabled = !app.appData.options_url || !app.appData.enabled;\par
      this.uninstall_.disabled = !app.appData.can_uninstall;\par
\par
      this.disableNotifications_.hidden = true;\par
      var notificationsDisabled = app.appData.notifications_disabled;\par
      if (typeof notificationsDisabled != 'undefined') \{\par
        this.disableNotifications_.hidden = false;\par
        this.disableNotifications_.checked = notificationsDisabled;\par
      \}\par
    \},\par
\par
    /**\par
     * Handlers for menu item activation.\par
     * @param \{Event\} e The activation event.\par
     * @private\par
     */\par
    onLaunch_: function(e) \{\par
      chrome.send('launchApp', [this.app_.appId, APP_LAUNCH.NTP_APPS_MENU]);\par
    \},\par
    onLaunchTypeChanged_: function(e) \{\par
      var pressed = e.currentTarget;\par
      var app = this.app_;\par
      this.forAllLaunchTypes_(function(launchTypeButton, id) \{\par
        if (launchTypeButton == pressed) \{\par
          chrome.send('setLaunchType', [app.appId, id]);\par
          // Manually update the launch type. We will only get\par
          // appsPrefChangeCallback calls after changes to other NTP instances.\par
          app.appData.launch_type = id;\par
        \}\par
      \});\par
    \},\par
    onShowOptions_: function(e) \{\par
      window.location = this.app_.appData.options_url;\par
    \},\par
    onDisableNotifications_: function(e) \{\par
      var app = this.app_;\par
      app.removeBubble();\par
      // Toggle the current disable setting.\par
      var newSetting = !this.disableNotifications_.checked;\par
      app.appData.notifications_disabled = newSetting;\par
      chrome.send('setNotificationsDisabled', [app.appData.id, newSetting]);\par
    \},\par
    onUninstall_: function(e) \{\par
      chrome.send('uninstallApp', [this.app_.appData.id]);\par
    \},\par
    onCreateShortcut_: function(e) \{\par
      chrome.send('createAppShortcut', [this.app_.appData.id]);\par
    \},\par
  \};\par
\par
  /**\par
   * Creates a new App object.\par
   * @param \{Object\} appData The data object that describes the app.\par
   * @constructor\par
   * @extends \{HTMLDivElement\}\par
   */\par
  function App(appData) \{\par
    var el = cr.doc.createElement('div');\par
    el.__proto__ = App.prototype;\par
    el.initialize(appData);\par
\par
    return el;\par
  \}\par
\par
  App.prototype = \{\par
    __proto__: HTMLDivElement.prototype,\par
\par
    /**\par
     * Initialize the app object.\par
     * @param \{Object\} appData The data object that describes the app.\par
     */\par
    initialize: function(appData) \{\par
      this.appData = appData;\par
      assert(this.appData_.id, 'Got an app without an ID');\par
      this.id = this.appData_.id;\par
\par
      this.className = 'app focusable';\par
\par
      if (!this.appData_.icon_big_exists && this.appData_.icon_small_exists)\par
        this.useSmallIcon_ = true;\par
\par
      this.appContents_ = this.useSmallIcon_ ?\par
          $('app-small-icon-template').cloneNode(true) :\par
          $('app-large-icon-template').cloneNode(true);\par
      this.appContents_.id = '';\par
      this.appendChild(this.appContents_);\par
\par
      this.appImgContainer_ = this.querySelector('.app-img-container');\par
      this.appImg_ = this.appImgContainer_.querySelector('img');\par
      this.setIcon();\par
\par
      if (this.useSmallIcon_) \{\par
        this.imgDiv_ = this.querySelector('.app-icon-div');\par
        this.addLaunchClickTarget_(this.imgDiv_);\par
        this.imgDiv_.title = this.appData_.title;\par
        chrome.send('getAppIconDominantColor', [this.id]);\par
      \} else \{\par
        this.addLaunchClickTarget_(this.appImgContainer_);\par
        this.appImgContainer_.title = this.appData_.title;\par
      \}\par
\par
      var appSpan = this.appContents_.querySelector('.title');\par
      appSpan.textContent = appSpan.title = this.appData_.title;\par
      this.addLaunchClickTarget_(appSpan);\par
\par
      var notification = this.appData_.notification;\par
      var hasNotification = typeof notification != 'undefined' &&\par
                            typeof notification['title'] != 'undefined' &&\par
                            typeof notification['body'] != 'undefined' &&\par
                            !this.appData_.notifications_disabled;\par
      if (hasNotification)\par
        this.setupNotification_(notification);\par
\par
      this.addEventListener('keydown', cr.ui.contextMenuHandler);\par
      this.addEventListener('keyup', cr.ui.contextMenuHandler);\par
\par
      // This hack is here so that appContents.contextMenu will be the same as\par
      // this.contextMenu.\par
      var self = this;\par
      this.appContents_.__defineGetter__('contextMenu', function() \{\par
        return self.contextMenu;\par
      \});\par
      this.appContents_.addEventListener('contextmenu',\par
                                         cr.ui.contextMenuHandler);\par
\par
      if (this.appData_.is_webstore)\par
        this.createAppsPromoExtras_();\par
\par
      this.addEventListener('mousedown', this.onMousedown_, true);\par
      this.addEventListener('keydown', this.onKeydown_);\par
      this.addEventListener('blur', this.onBlur_, true);\par
    \},\par
\par
    /**\par
     * Sets the color of the favicon dominant color bar.\par
     * @param \{string\} color The css-parsable value for the color.\par
     */\par
    set stripeColor(color) \{\par
      this.querySelector('.color-stripe').style.backgroundColor = color;\par
    \},\par
\par
    /**\par
     * Removes the app tile from the page. Should be called after the app has\par
     * been uninstalled.\par
     */\par
    remove: function(opt_animate) \{\par
      // Unset the ID immediately, because the app is already gone. But leave\par
      // the tile on the page as it animates out.\par
      this.id = '';\par
      this.tile.doRemove(opt_animate);\par
    \},\par
\par
    /**\par
     * Set the URL of the icon from |appData_|. This won't actually show the\par
     * icon until loadIcon() is called (for performance reasons; we don't want\par
     * to load icons until we have to).\par
     */\par
    setIcon: function() \{\par
      var src = this.useSmallIcon_ ? this.appData_.icon_small :\par
                                     this.appData_.icon_big;\par
      if (!this.appData_.enabled ||\par
          (!this.appData_.offline_enabled && !navigator.onLine)) \{\par
        src += '?grayscale=true';\par
      \}\par
\par
      this.appImgSrc_ = src;\par
      this.classList.add('icon-loading');\par
    \},\par
\par
    /**\par
     * Shows the icon for the app. That is, it causes chrome to load the app\par
     * icon resource.\par
     */\par
    loadIcon: function() \{\par
      if (this.appImgSrc_) \{\par
        this.appImg_.src = this.appImgSrc_;\par
        this.appImg_.classList.remove('invisible');\par
        this.appImgSrc_ = null;\par
      \}\par
      this.classList.remove('icon-loading');\par
    \},\par
\par
    /**\par
     * Creates a bubble node.\par
     * @param \{Object\} notification The notification to show in the bubble.\par
     * @param \{boolean\} full Whether we want the headline or just the content.\par
     * @private\par
     */\par
    createBubbleNode_: function(notification, full) \{\par
      if (!full) \{\par
        var titleItem = this.ownerDocument.createElement('span');\par
        titleItem.textContent = notification['title'];\par
        return titleItem;\par
      \} else \{\par
        var container = this.ownerDocument.createElement('div');\par
\par
        var messageItem = this.ownerDocument.createElement('div');\par
        messageItem.textContent = notification['body'];\par
        container.appendChild(messageItem);\par
\par
        if (notification['linkUrl'] && notification['linkText']) \{\par
          var anchor = this.ownerDocument.createElement('a');\par
          anchor.href = notification['linkUrl'];\par
          anchor.textContent = notification['linkText'];\par
          container.appendChild(anchor);\par
        \}\par
\par
        return container;\par
      \}\par
    \},\par
\par
    /**\par
     * Sets up a notification for the app icon.\par
     * @param \{Object\} notification The notification to show in the bubble.\par
     * @private\par
     */\par
    setupNotification_: function(notification) \{\par
      if (notification) \{\par
        var infoBubble;\par
        if (!this.currentBubbleShowing_) \{\par
          // Create a new bubble.\par
          infoBubble = new cr.ui.ExpandableBubble;\par
          infoBubble.anchorNode = this;\par
          infoBubble.appId = this.appData_.id;\par
          infoBubble.handleCloseEvent = function() \{\par
            chrome.send('closeNotification', [this.appId]);\par
            infoBubble.hide();\par
          \};\par
        \} else \{\par
          // Reuse the old bubble instead of popping up a new bubble over\par
          // the old one.\par
          infoBubble = this.currentBubbleShowing_;\par
          infoBubble.collapseBubble_();\par
        \}\par
        infoBubble.contentTitle = this.createBubbleNode_(notification, false);\par
        infoBubble.content = this.createBubbleNode_(notification, true);\par
        infoBubble.show();\par
        infoBubble.resizeAndReposition();\par
\par
        this.currentBubbleShowing_ = infoBubble;\par
      \}\par
    \},\par
\par
    /**\par
     *  Removes the info bubble if there is one.\par
     */\par
    removeBubble: function() \{\par
      if (this.currentBubbleShowing_) \{\par
        this.currentBubbleShowing_.hide();\par
        this.currentBubbleShowing_ = null;\par
      \}\par
    \},\par
\par
    /**\par
     * Creates the apps-promo section of the app (should only be called for the\par
     * webstore app).\par
     * @private\par
     */\par
    createAppsPromoExtras_: function() \{\par
      this.classList.add('webstore');\par
\par
      this.appsPromoExtras_ = $('apps-promo-extras-template').cloneNode(true);\par
      this.appsPromoExtras_.id = '';\par
      this.appsPromoHeading_ =\par
          this.appsPromoExtras_.querySelector('.apps-promo-heading');\par
      this.appsPromoLink_ =\par
          this.appsPromoExtras_.querySelector('.apps-promo-link');\par
      this.appsPromoLink_.addEventListener('click', this.onClick_.bind(this));\par
\par
      this.appsPromoLogo_ = this.ownerDocument.createElement('img');\par
      this.appsPromoLogo_.className = 'apps-promo-logo';\par
      this.appImgContainer_.appendChild(this.appsPromoLogo_);\par
\par
      this.appendChild(this.appsPromoExtras_);\par
    \},\par
\par
    /**\par
     * Sets the apps promo appearance. If |data| is null, there is no promo. If\par
     * |data| is non-null, it contains strings to be shown for the promo. The\par
     * promo is only shown when the webstore app icon is alone on a page.\par
     * @param \{Object\} data A dictionary that contains apps promo strings.\par
     */\par
    setAppsPromoData: function(data) \{\par
      if (data) \{\par
        this.classList.add('has-promo');\par
      \} else \{\par
        this.classList.remove('has-promo');\par
        return;\par
      \}\par
\par
      this.appsPromoHeading_.textContent = data.promoHeader;\par
      this.appsPromoLink_.href = data.promoLink;\par
      this.appsPromoLink_.textContent = data.promoButton;\par
      this.appsPromoLogo_.src = data.promoLogo;\par
    \},\par
\par
    /**\par
     * Set the size and position of the app tile.\par
     * @param \{number\} size The total size of |this|.\par
     * @param \{number\} x The x-position.\par
     * @param \{number\} y The y-position.\par
     *     animate.\par
     */\par
    setBounds: function(size, x, y) \{\par
      var imgSize = size * APP_IMG_SIZE_FRACTION;\par
      this.appImgContainer_.style.width = this.appImgContainer_.style.height =\par
          this.useSmallIcon_ ? '16px' : imgSize + 'px';\par
      if (this.useSmallIcon_) \{\par
        // 3/4 is the ratio of 96px to 128px (the used height and full height\par
        // of icons in apps).\par
        var iconSize = imgSize * 3/4;\par
        // The -2 is for the div border to improve the visual alignment for the\par
        // icon div.\par
        this.imgDiv_.style.width = this.imgDiv_.style.height =\par
            (iconSize - 2) + 'px';\par
        // Margins set to get the icon placement right and the text to line up.\par
        this.imgDiv_.style.marginTop = this.imgDiv_.style.marginBottom =\par
            ((imgSize - iconSize) / 2) + 'px';\par
      \}\par
\par
      this.style.width = this.style.height = size + 'px';\par
      this.style.left = x + 'px';\par
      this.style.right = x + 'px';\par
      this.style.top = y + 'px';\par
\par
      if (this.currentBubbleShowing_)\par
        this.currentBubbleShowing_.resizeAndReposition();\par
    \},\par
\par
    /**\par
     * Invoked when an app is clicked.\par
     * @param \{Event\} e The click event.\par
     * @private\par
     */\par
    onClick_: function(e) \{\par
      var is_promo = this.appsPromoExtras_ &&\par
          window.getComputedStyle(this.appsPromoExtras_).display != 'none';\par
      var url = !this.appData_.is_webstore ? '' :\par
          is_promo ? this.appsPromoLink_.href :\par
                     appendParam(this.appData_.url,\par
                                 'utm_source',\par
                                 'chrome-ntp-icon');\par
\par
      chrome.send('launchApp',\par
                  [this.appId, APP_LAUNCH.NTP_APPS_MAXIMIZED, url,\par
                   e.button, e.altKey, e.ctrlKey, e.metaKey, e.shiftKey]);\par
\par
      // Don't allow the click to trigger a link or anything\par
      e.preventDefault();\par
    \},\par
\par
    /**\par
     * Invoked when the user presses a key while the app is focused.\par
     * @param \{Event\} e The key event.\par
     * @private\par
     */\par
    onKeydown_: function(e) \{\par
      if (e.keyIdentifier == 'Enter') \{\par
        chrome.send('launchApp',\par
                    [this.appId, APP_LAUNCH.NTP_APPS_MAXIMIZED, '',\par
                     0, e.altKey, e.ctrlKey, e.metaKey, e.shiftKey]);\par
        e.preventDefault();\par
        e.stopPropagation();\par
      \}\par
    \},\par
\par
    /**\par
     * Adds a node to the list of targets that will launch the app. This list\par
     * is also used in onMousedown to determine whether the app contents should\par
     * be shown as active (if we don't do this, then clicking anywhere in\par
     * appContents, even a part that is outside the ideally clickable region,\par
     * will cause the app icon to look active).\par
     * @param \{HTMLElement\} node The node that should be clickable.\par
     */\par
    addLaunchClickTarget_: function(node) \{\par
      node.classList.add('launch-click-target');\par
      node.addEventListener('click', this.onClick_.bind(this));\par
    \},\par
\par
    /**\par
     * Handler for mousedown on the App. Adds a class that allows us to\par
     * not display as :active for right clicks and clicks on app notifications\par
     * (specifically, don't pulse on these occasions). Also, we don't pulse\par
     * for clicks that aren't within the clickable regions.\par
     * @param \{Event\} e The mousedown event.\par
     */\par
    onMousedown_: function(e) \{\par
      if (e.button == 2 ||\par
          !findAncestorByClass(e.target, 'launch-click-target')) \{\par
        this.appContents_.classList.add('suppress-active');\par
      \} else \{\par
        this.appContents_.classList.remove('suppress-active');\par
      \}\par
\par
      // This class is here so we don't show the focus state for apps that\par
      // gain keyboard focus via mouse clicking.\par
      this.classList.add('click-focus');\par
    \},\par
\par
    /**\par
     * This app is losing keyboard focus.\par
     * @param \{Event\} e The event.\par
     */\par
    onBlur_: function(e) \{\par
      this.classList.remove('click-focus');\par
    \},\par
\par
    /**\par
     * Change the appData and update the appearance of the app.\par
     * @param \{Object\} appData The new data object that describes the app.\par
     */\par
    replaceAppData: function(appData) \{\par
      this.appData_ = appData;\par
      this.setIcon();\par
      this.loadIcon();\par
    \},\par
\par
    /**\par
     * The data and preferences for this app.\par
     * @type \{Object\}\par
     */\par
    set appData(data) \{\par
      this.appData_ = data;\par
    \},\par
    get appData() \{\par
      return this.appData_;\par
    \},\par
\par
    get appId() \{\par
      return this.appData_.id;\par
    \},\par
\par
    /**\par
     * Returns a pointer to the context menu for this app. All apps share the\par
     * singleton AppContextMenu. This function is called by the\par
     * ContextMenuHandler in response to the 'contextmenu' event.\par
     * @type \{cr.ui.Menu\}\par
     */\par
    get contextMenu() \{\par
      var menu = AppContextMenu.getInstance();\par
      menu.setupForApp(this);\par
      return menu.menu;\par
    \},\par
\par
    /**\par
     * Returns whether this element can be 'removed' from chrome (i.e. whether\par
     * the user can drag it onto the trash and expect something to happen).\par
     * @return \{boolean\} True if the app can be uninstalled.\par
     */\par
    canBeRemoved: function() \{\par
      return this.appData_.can_uninstall;\par
    \},\par
\par
    /**\par
     * Uninstalls the app after it's been dropped on the trash.\par
     */\par
    removeFromChrome: function() \{\par
      chrome.send('uninstallApp', [this.appData_.id, true]);\par
      this.tile.tilePage.removeTile(this.tile, true);\par
      if (this.currentBubbleShowing_)\par
        currentBubbleShowing_.hide();\par
    \},\par
\par
    /**\par
     * Called when a drag is starting on the tile. Updates dataTransfer with\par
     * data for this tile.\par
     */\par
    setDragData: function(dataTransfer) \{\par
      dataTransfer.setData('Text', this.appData_.title);\par
      dataTransfer.setData('URL', this.appData_.url);\par
    \},\par
  \};\par
\par
  var TilePage = ntp4.TilePage;\par
\par
  // The fraction of the app tile size that the icon uses.\par
  var APP_IMG_SIZE_FRACTION = 4 / 5;\par
\par
  var appsPageGridValues = \{\par
    // The fewest tiles we will show in a row.\par
    minColCount: 3,\par
    // The most tiles we will show in a row.\par
    maxColCount: 6,\par
\par
    // The smallest a tile can be.\par
    minTileWidth: 64 / APP_IMG_SIZE_FRACTION,\par
    // The biggest a tile can be.\par
    maxTileWidth: 128 / APP_IMG_SIZE_FRACTION,\par
\par
    // The padding between tiles, as a fraction of the tile width.\par
    tileSpacingFraction: 1 / 8,\par
  \};\par
  TilePage.initGridValues(appsPageGridValues);\par
\par
  /**\par
   * Creates a new AppsPage object.\par
   * @constructor\par
   * @extends \{TilePage\}\par
   */\par
  function AppsPage() \{\par
    var el = new TilePage(appsPageGridValues);\par
    el.__proto__ = AppsPage.prototype;\par
    el.initialize();\par
\par
    return el;\par
  \}\par
\par
  AppsPage.prototype = \{\par
    __proto__: TilePage.prototype,\par
\par
    initialize: function() \{\par
      this.classList.add('apps-page');\par
\par
      this.addEventListener('cardselected', this.onCardSelected_);\par
      // Add event listeners for two events, so we can temporarily suppress\par
      // the app notification bubbles when the app card slides in and out of\par
      // view.\par
      this.addEventListener('carddeselected', this.onCardDeselected_);\par
      this.addEventListener('cardSlider:card_change_ended',\par
                            this.onCardChangeEnded_);\par
\par
      this.addEventListener('tilePage:tile_added', this.onTileAdded_);\par
\par
      this.content_.addEventListener('scroll', this.onScroll_.bind(this));\par
    \},\par
\par
    /**\par
     * Creates an app DOM element and places it at the last position on the\par
     * page.\par
     * @param \{Object\} appData The data object that describes the app.\par
     * @param \{boolean=\} animate If true, the app tile plays an animation.\par
     */\par
    appendApp: function(appData, animate) \{\par
      if (animate) \{\par
        // Select the page and scroll all the way down so the animation is\par
        // visible.\par
        ntp4.getCardSlider().selectCardByValue(this);\par
        this.content_.scrollTop = this.content_.scrollHeight;\par
      \}\par
      this.appendTile(new App(appData), animate);\par
    \},\par
\par
    /**\par
     * Handler for 'cardselected' event, fired when |this| is selected. The\par
     * first time this is called, we load all the app icons.\par
     * @private\par
     */\par
    onCardSelected_: function(e) \{\par
      var apps = this.querySelectorAll('.app.icon-loading');\par
      for (var i = 0; i < apps.length; i++) \{\par
        apps[i].loadIcon();\par
        if (apps[i].currentBubbleShowing_)\par
          apps[i].currentBubbleShowing_.suppressed = false;\par
      \}\par
    \},\par
\par
    /**\par
     * Handler for tile additions to this page.\par
     * @param \{Event\} e The tilePage:tile_added event.\par
     */\par
    onTileAdded_: function(e) \{\par
      assert(e.currentTarget == this);\par
      assert(e.addedTile.firstChild instanceof App);\par
      if (this.classList.contains('selected-card'))\par
        e.addedTile.firstChild.loadIcon();\par
    \},\par
\par
    /**\par
     * Handler for the when this.cardSlider ends change its card. If animated,\par
     * this happens when the -webkit-transition is done, otherwise happens\par
     * immediately (but after cardSlider:card_changed).\par
     * @private\par
     */\par
    onCardChangeEnded_: function(e) \{\par
      for (var i = 0; i < this.tileElements_.length; i++) \{\par
        var app = this.tileElements_[i].firstChild;\par
        assert(app instanceof App);\par
        if (app.currentBubbleShowing_)\par
          app.currentBubbleShowing_.suppressed = false;\par
      \}\par
    \},\par
\par
    /**\par
     * Handler for the 'carddeselected' event, fired when the user switches\par
     * to another 'card' than the App 'card' on the NTP (|this| gets\par
     * deselected).\par
     * @private\par
     */\par
    onCardDeselected_: function(e) \{\par
      for (var i = 0; i < this.tileElements_.length; i++) \{\par
        var app = this.tileElements_[i].firstChild;\par
        assert(app instanceof App);\par
        if (app.currentBubbleShowing_)\par
          app.currentBubbleShowing_.suppressed = true;\par
      \}\par
    \},\par
\par
    /**\par
     * A handler for when the apps page is scrolled (then we need to reposition\par
     * the bubbles.\par
     * @private\par
     */\par
    onScroll_: function(e) \{\par
      if (!this.selected)\par
        return;\par
      for (var i = 0; i < this.tileElements_.length; i++) \{\par
        var app = this.tileElements_[i].firstChild;\par
        assert(app instanceof App);\par
        if (app.currentBubbleShowing_)\par
          app.currentBubbleShowing_.resizeAndReposition();\par
        \}\par
    \},\par
\par
    /** @inheritdoc */\par
    doDragOver: function(e) \{\par
      var tile = ntp4.getCurrentlyDraggingTile();\par
      if (tile && !tile.querySelector('.app')) \{\par
        e.preventDefault();\par
        this.setDropEffect(e.dataTransfer);\par
      \} else \{\par
        TilePage.prototype.doDragOver.call(this, e);\par
      \}\par
    \},\par
\par
    /** @inheritDoc */\par
    shouldAcceptDrag: function(e) \{\par
      return !!ntp4.getCurrentlyDraggingTile() ||\par
          (e.dataTransfer && e.dataTransfer.types.indexOf('url') != -1);\par
    \},\par
\par
    /** @inheritDoc */\par
    addDragData: function(dataTransfer, index) \{\par
      var sourceId = -1;\par
      var currentlyDraggingTile = ntp4.getCurrentlyDraggingTile();\par
      if (currentlyDraggingTile) \{\par
        var tileContents = currentlyDraggingTile.firstChild;\par
        if (tileContents.classList.contains('app')) \{\par
          var originalPage = currentlyDraggingTile.tilePage;\par
          var samePageDrag = originalPage == this;\par
          sourceId = samePageDrag ? DRAG_SOURCE.SAME_APPS_PANE :\par
                                    DRAG_SOURCE.OTHER_APPS_PANE;\par
          this.tileGrid_.insertBefore(currentlyDraggingTile,\par
                                      this.tileElements_[index]);\par
          this.tileMoved(currentlyDraggingTile);\par
          if (!samePageDrag) \{\par
            originalPage.fireRemovedEvent(currentlyDraggingTile, index, true);\par
            this.fireAddedEvent(currentlyDraggingTile, index, true);\par
          \}\par
        \} else if (currentlyDraggingTile.querySelector('.most-visited')) \{\par
          this.generateAppForLink(tileContents.data);\par
          sourceId = DRAG_SOURCE.MOST_VISITED_PANE;\par
        \}\par
      \} else \{\par
        this.addOutsideData_(dataTransfer);\par
        sourceId = DRAG_SOURCE.OUTSIDE_NTP;\par
      \}\par
\par
      assert(sourceId != -1);\par
      chrome.send('metricsHandler:recordInHistogram',\par
          ['NewTabPage.AppsPageDragSource', sourceId, DRAG_SOURCE_LIMIT]);\par
    \},\par
\par
    /**\par
     * Adds drag data that has been dropped from a source that is not a tile.\par
     * @param \{Object\} dataTransfer The data transfer object that holds drop\par
     *     data.\par
     * @private\par
     */\par
    addOutsideData_: function(dataTransfer) \{\par
      var url = dataTransfer.getData('url');\par
      assert(url);\par
\par
      // If the dataTransfer has html data, use that html's text contents as the\par
      // title of the new link.\par
      var html = dataTransfer.getData('text/html');\par
      var title;\par
      if (html) \{\par
        // It's important that we don't attach this node to the document\par
        // because it might contain scripts.\par
        var node = this.ownerDocument.createElement('div');\par
        node.innerHTML = html;\par
        title = node.textContent;\par
      \}\par
\par
      // Make sure title is >=1 and <=45 characters for Chrome app limits.\par
      if (!title)\par
        title = url;\par
      if (title.length > 45)\par
        title = title.substring(0, 45);\par
      var data = \{url: url, title: title\};\par
\par
      // Synthesize an app.\par
      this.generateAppForLink(data);\par
    \},\par
\par
    /**\par
     * Creates a new crx-less app manifest and installs it.\par
     * @param \{Object\} data The data object describing the link. Must have |url|\par
     *     and |title| members.\par
     */\par
    generateAppForLink: function(data) \{\par
      assert(data.url != undefined);\par
      assert(data.title != undefined);\par
      var pageIndex = ntp4.getAppsPageIndex(this);\par
      chrome.send('generateAppForLink', [data.url, data.title, pageIndex]);\par
    \},\par
\par
    /** @inheritDoc */\par
    tileMoved: function(draggedTile) \{\par
      if (!(draggedTile.firstChild instanceof App))\par
        return;\par
\par
      var pageIndex = ntp4.getAppsPageIndex(this);\par
      chrome.send('setPageIndex', [draggedTile.firstChild.appId, pageIndex]);\par
\par
      var appIds = [];\par
      for (var i = 0; i < this.tileElements_.length; i++) \{\par
        var tileContents = this.tileElements_[i].firstChild;\par
        if (tileContents instanceof App)\par
          appIds.push(tileContents.appId);\par
      \}\par
\par
      chrome.send('reorderApps', [draggedTile.firstChild.appId, appIds]);\par
    \},\par
\par
    /** @inheritDoc */\par
    setDropEffect: function(dataTransfer) \{\par
      var tile = ntp4.getCurrentlyDraggingTile();\par
      if (tile && tile.querySelector('.app'))\par
        ntp4.setCurrentDropEffect(dataTransfer, 'move');\par
      else\par
        ntp4.setCurrentDropEffect(dataTransfer, 'copy');\par
    \},\par
  \};\par
\par
  AppsPage.setPromo = function(data) \{\par
    var store = document.querySelector('.webstore');\par
    if (store)\par
      store.setAppsPromoData(data);\par
  \};\par
\par
  /**\par
   * Launches the specified app using the APP_LAUNCH_NTP_APP_RE_ENABLE\par
   * histogram. This should only be invoked from the AppLauncherHandler.\par
   * @param \{String\} appID The ID of the app.\par
   */\par
  function launchAppAfterEnable(appId) \{\par
    chrome.send('launchApp', [appId, APP_LAUNCH.NTP_APP_RE_ENABLE]);\par
  \}\par
\par
  function appNotificationChanged(id, notification) \{\par
    var app = $(id);\par
    // The app might have been uninstalled, or notifications might be disabled.\par
    if (app && !app.appData.notifications_disabled)\par
      app.setupNotification_(notification);\par
  \}\par
\par
  return \{\par
    APP_LAUNCH: APP_LAUNCH,\par
    appNotificationChanged: appNotificationChanged,\par
    AppsPage: AppsPage,\par
    launchAppAfterEnable: launchAppAfterEnable,\par
  \};\par
\});\par
\par
// TODO(estade): update the content handlers to use ntp namespace instead of\par
// making these global.\par
var appNotificationChanged = ntp4.appNotificationChanged;\par
var launchAppAfterEnable = ntp4.launchAppAfterEnable;\par
</script>\par
<script>// Copyright (c) 2011 The Chromium Authors. All rights reserved.\par
// Use of this source code is governed by a BSD-style license that can be\par
// found in the LICENSE file.\par
\par
/**\par
 * @fileoverview DotList implementation\par
 */\par
\par
cr.define('ntp4', function() \{\par
  'use strict';\par
\par
  /**\par
   * Live list of the navigation dots.\par
   * @type \{!NodeList|undefined\}\par
   */\par
  var navDots;\par
\par
  /**\par
   * Creates a new DotList object.\par
   * @constructor\par
   * @extends \{HTMLUListElement\}\par
   */\par
  var DotList = cr.ui.define('ul');\par
\par
  DotList.prototype = \{\par
    __proto__: HTMLUListElement.prototype,\par
\par
    /** @inheritDoc */\par
    decorate: function() \{\par
      this.addEventListener('keydown', this.onKeyDown_.bind(this));\par
      navDots = this.getElementsByClassName('dot');\par
    \},\par
\par
    /**\par
     * Live list of the navigation dots.\par
     * @type \{!NodeList|undefined\}\par
     */\par
    get dots() \{\par
      return navDots;\par
    \},\par
\par
    /**\par
     * Handler for key events on the dot list. These keys will change the focus\par
     * element.\par
     * @param \{Event\} e The KeyboardEvent.\par
     */\par
    onKeyDown_: function(e) \{\par
      if (e.metaKey || e.shiftKey || e.altKey || e.ctrlKey)\par
        return;\par
\par
      var direction = 0;\par
      if (e.keyIdentifier == 'Left')\par
        direction = -1;\par
      else if (e.keyIdentifier == 'Right')\par
        direction = 1;\par
      else\par
        return;\par
\par
      var focusDot = this.querySelector('.dot:focus');\par
      if (!focusDot)\par
        return;\par
      var focusIndex = Array.prototype.indexOf.call(navDots, focusDot);\par
      var newFocusIndex = focusIndex + direction;\par
      if (focusIndex == newFocusIndex)\par
        return;\par
\par
      newFocusIndex = (newFocusIndex + navDots.length) % navDots.length;\par
      navDots[newFocusIndex].tabIndex = 3;\par
      navDots[newFocusIndex].focus();\par
      focusDot.tabIndex = -1;\par
\par
      e.stopPropagation();\par
      e.preventDefault();\par
    \}\par
  \};\par
\par
  return \{\par
    DotList: DotList\par
  \};\par
\});\par
</script>\par
<script>// Copyright (c) 2012 The Chromium Authors. All rights reserved.\par
// Use of this source code is governed by a BSD-style license that can be\par
// found in the LICENSE file.\par
\par
cr.define('ntp4', function() \{\par
  'use strict';\par
\par
  var TilePage = ntp4.TilePage;\par
\par
  /**\par
   * A counter for generating unique tile IDs.\par
   */\par
  var tileID = 0;\par
\par
  /**\par
   * Creates a new Most Visited object for tiling.\par
   * @constructor\par
   * @extends \{HTMLAnchorElement\}\par
   */\par
  function MostVisited() \{\par
    var el = cr.doc.createElement('a');\par
    el.__proto__ = MostVisited.prototype;\par
    el.initialize();\par
\par
    return el;\par
  \}\par
\par
  MostVisited.prototype = \{\par
    __proto__: HTMLAnchorElement.prototype,\par
\par
    initialize: function() \{\par
      this.reset();\par
\par
      this.addEventListener('click', this.handleClick_);\par
      this.addEventListener('keydown', this.handleKeyDown_);\par
    \},\par
\par
    get index() \{\par
      assert(this.tile);\par
      return this.tile.index;\par
    \},\par
\par
    get data() \{\par
      return this.data_;\par
    \},\par
\par
    /**\par
     * Clears the DOM hierarchy for this node, setting it back to the default\par
     * for a blank thumbnail.\par
     */\par
    reset: function() \{\par
      this.className = 'most-visited filler real';\par
      this.innerHTML =\par
          '<span class="thumbnail-wrapper fills-parent">' +\par
            '<div class="close-button"></div>' +\par
            '<span class="thumbnail fills-parent">' +\par
              // thumbnail-shield provides a gradient fade effect.\par
              '<div class="thumbnail-shield fills-parent"></div>' +\par
            '</span>' +\par
            '<span class="favicon"></span>' +\par
          '</span>' +\par
          '<div class="color-stripe"></div>' +\par
          '<span class="title"></span>';\par
\par
      this.querySelector('.close-button').title =\par
          templateData.removethumbnailtooltip;\par
\par
      this.tabIndex = -1;\par
      this.data_ = null;\par
      this.removeAttribute('id');\par
      this.title = '';\par
    \},\par
\par
    /**\par
     * Update the appearance of this tile according to |data|.\par
     * @param \{Object\} data A dictionary of relevant data for the page.\par
     */\par
    updateForData: function(data) \{\par
      if (this.classList.contains('blacklisted') && data) \{\par
        // Animate appearance of new tile.\par
        this.classList.add('new-tile-contents');\par
      \}\par
      this.classList.remove('blacklisted');\par
\par
      if (!data || data.filler) \{\par
        if (this.data_)\par
          this.reset();\par
        return;\par
      \}\par
\par
      var id = tileID++;\par
      this.id = 'most-visited-tile-' + id;\par
      this.data_ = data;\par
      this.classList.add('focusable');\par
\par
      var faviconDiv = this.querySelector('.favicon');\par
      var faviconUrl = 'chrome://favicon/size/16/' + data.url;\par
      faviconDiv.style.backgroundImage = url(faviconUrl);\par
      chrome.send('getFaviconDominantColor', [faviconUrl, this.id]);\par
\par
      var title = this.querySelector('.title');\par
      title.textContent = data.title;\par
      title.dir = data.direction;\par
\par
      // Sets the tooltip.\par
      this.title = data.title;\par
\par
      var thumbnailUrl = 'chrome://thumb/' + data.url;\par
      this.querySelector('.thumbnail').style.backgroundImage =\par
          url(thumbnailUrl);\par
\par
      this.href = data.url;\par
\par
      this.classList.remove('filler');\par
    \},\par
\par
    /**\par
     * Sets the color of the favicon dominant color bar.\par
     * @param \{string\} color The css-parsable value for the color.\par
     */\par
    set stripeColor(color) \{\par
      this.querySelector('.color-stripe').style.backgroundColor = color;\par
    \},\par
\par
    /**\par
     * Handles a click on the tile.\par
     * @param \{Event\} e The click event.\par
     */\par
    handleClick_: function(e) \{\par
      if (e.target.classList.contains('close-button')) \{\par
        this.blacklist_();\par
        e.preventDefault();\par
      \} else \{\par
        // Records an app launch from the most visited page (Chrome will decide\par
        // whether the url is an app). TODO(estade): this only works for clicks;\par
        // other actions like "open in new tab" from the context menu won't be\par
        // recorded. Can this be fixed?\par
        chrome.send('recordAppLaunchByURL',\par
                    [encodeURIComponent(this.href),\par
                     ntp4.APP_LAUNCH.NTP_MOST_VISITED]);\par
        // Records the index of this tile.\par
        chrome.send('metricsHandler:recordInHistogram',\par
                    ['NTP_MostVisited', this.index, 8]);\par
      \}\par
    \},\par
\par
    /**\par
     * Allow blacklisting most visited site using the keyboard.\par
     */\par
    handleKeyDown_: function(e) \{\par
      if (!cr.isMac && e.keyCode == 46 || // Del\par
          cr.isMac && e.metaKey && e.keyCode == 8) \{ // Cmd + Backspace\par
        this.blacklist_();\par
      \}\par
    \},\par
\par
    /**\par
     * Permanently removes a page from Most Visited.\par
     */\par
    blacklist_: function() \{\par
      this.showUndoNotification_();\par
      chrome.send('blacklistURLFromMostVisited', [this.data_.url]);\par
      this.reset();\par
      chrome.send('getMostVisited');\par
      this.classList.add('blacklisted');\par
    \},\par
\par
    showUndoNotification_: function() \{\par
      var data = this.data_;\par
      var self = this;\par
      var doUndo = function () \{\par
        chrome.send('removeURLsFromMostVisitedBlacklist', [data.url]);\par
        self.updateForData(data);\par
      \}\par
\par
      var undo = \{\par
        action: doUndo,\par
        text: templateData.undothumbnailremove,\par
      \}\par
\par
      var undoAll = \{\par
        action: function() \{\par
          chrome.send('clearMostVisitedURLsBlacklist', []);\par
        \},\par
        text: templateData.restoreThumbnailsShort,\par
      \}\par
\par
      ntp4.showNotification(templateData.thumbnailremovednotification,\par
                            [undo, undoAll]);\par
    \},\par
\par
    /**\par
     * Set the size and position of the most visited tile.\par
     * @param \{number\} size The total size of |this|.\par
     * @param \{number\} x The x-position.\par
     * @param \{number\} y The y-position.\par
     *     animate.\par
     */\par
    setBounds: function(size, x, y) \{\par
      this.style.width = size + 'px';\par
      this.style.height = heightForWidth(size) + 'px';\par
\par
      this.style.left = x + 'px';\par
      this.style.right = x + 'px';\par
      this.style.top = y + 'px';\par
    \},\par
\par
    /**\par
     * Returns whether this element can be 'removed' from chrome (i.e. whether\par
     * the user can drag it onto the trash and expect something to happen).\par
     * @return \{boolean\} True, since most visited pages can always be\par
     *     blacklisted.\par
     */\par
    canBeRemoved: function() \{\par
      return true;\par
    \},\par
\par
    /**\par
     * Removes this element from chrome, i.e. blacklists it.\par
     */\par
    removeFromChrome: function() \{\par
      this.blacklist_();\par
      this.parentNode.classList.add('finishing-drag');\par
    \},\par
\par
    /**\par
     * Called when a drag of this tile has ended (after all animations have\par
     * finished).\par
     */\par
    finalizeDrag: function() \{\par
      this.parentNode.classList.remove('finishing-drag');\par
    \},\par
\par
    /**\par
     * Called when a drag is starting on the tile. Updates dataTransfer with\par
     * data for this tile (for dragging outside of the NTP).\par
     */\par
    setDragData: function(dataTransfer) \{\par
      dataTransfer.setData('Text', this.data_.title);\par
      dataTransfer.setData('URL', this.data_.url);\par
    \},\par
  \};\par
\par
  var mostVisitedPageGridValues = \{\par
    // The fewest tiles we will show in a row.\par
    minColCount: 2,\par
    // The most tiles we will show in a row.\par
    maxColCount: 4,\par
\par
    // The smallest a tile can be.\par
    minTileWidth: 122,\par
    // The biggest a tile can be. 212 (max thumbnail width) + 2.\par
    maxTileWidth: 214,\par
\par
    // The padding between tiles, as a fraction of the tile width.\par
    tileSpacingFraction: 1 / 8,\par
  \};\par
  TilePage.initGridValues(mostVisitedPageGridValues);\par
\par
  /**\par
   * Calculates the height for a Most Visited tile for a given width. The size\par
   * is based on the thumbnail, which should have a 212:132 ratio.\par
   * @return \{number\} The height.\par
   */\par
  function heightForWidth(width) \{\par
    // The 2s are for borders, the 31 is for the title.\par
    return (width - 2) * 132 / 212 + 2 + 31;\par
  \}\par
\par
  var THUMBNAIL_COUNT = 8;\par
\par
  /**\par
   * Creates a new MostVisitedPage object.\par
   * @constructor\par
   * @extends \{TilePage\}\par
   */\par
  function MostVisitedPage() \{\par
    var el = new TilePage(mostVisitedPageGridValues);\par
    el.__proto__ = MostVisitedPage.prototype;\par
    el.initialize();\par
\par
    return el;\par
  \}\par
\par
  MostVisitedPage.prototype = \{\par
    __proto__: TilePage.prototype,\par
\par
    initialize: function() \{\par
      this.classList.add('most-visited-page');\par
      this.data_ = null;\par
      this.mostVisitedTiles_ = this.getElementsByClassName('most-visited real');\par
    \},\par
\par
    /**\par
     * Create blank (filler) tiles.\par
     * @private\par
     */\par
    createTiles_: function() \{\par
      for (var i = 0; i < THUMBNAIL_COUNT; i++) \{\par
        this.appendTile(new MostVisited());\par
      \}\par
    \},\par
\par
    /**\par
     * Update the tiles after a change to |data_|.\par
     */\par
    updateTiles_: function() \{\par
      for (var i = 0; i < THUMBNAIL_COUNT; i++) \{\par
        var page = this.data_[i];\par
        var tile = this.mostVisitedTiles_[i];\par
\par
        if (i >= this.data_.length)\par
          tile.reset();\par
        else\par
          tile.updateForData(page);\par
      \}\par
    \},\par
\par
    /**\par
     * Array of most visited data objects.\par
     * @type \{Array\}\par
     */\par
    get data() \{\par
      return this.data_;\par
    \},\par
    set data(data) \{\par
      var startTime = Date.now();\par
\par
      // The first time data is set, create the tiles.\par
      if (!this.data_) \{\par
        this.createTiles_();\par
        this.data_ = data.slice(0, THUMBNAIL_COUNT);\par
      \} else \{\par
        this.data_ = refreshData(this.data_, data);\par
      \}\par
\par
      this.updateTiles_();\par
      logEvent('mostVisited.layout: ' + (Date.now() - startTime));\par
    \},\par
\par
    /** @inheritDoc */\par
    shouldAcceptDrag: function(e) \{\par
      return false;\par
    \},\par
\par
    /** @inheritDoc */\par
    heightForWidth: heightForWidth,\par
  \};\par
\par
  /**\par
   * We've gotten additional Most Visited data. Update our old data with the\par
   * new data. The ordering of the new data is not important, except when a\par
   * page is pinned. Thus we try to minimize re-ordering.\par
   * @param \{Object\} oldData The current Most Visited page list.\par
   * @param \{Object\} newData The new Most Visited page list.\par
   * @return The merged page list that should replace the current page list.\par
   */\par
  function refreshData(oldData, newData) \{\par
    oldData = oldData.slice(0, THUMBNAIL_COUNT);\par
    newData = newData.slice(0, THUMBNAIL_COUNT);\par
\par
    // Copy over pinned sites directly.\par
    for (var j = 0; j < newData.length; j++) \{\par
      if (newData[j].pinned) \{\par
        oldData[j] = newData[j];\par
        // Mark the entry as 'updated' so we don't try to update again.\par
        oldData[j].updated = true;\par
        // Mark the newData page as 'used' so we don't try to re-use it.\par
        newData[j].used = true;\par
      \}\par
    \}\par
\par
    // Look through old pages; if they exist in the newData list, keep them\par
    // where they are.\par
    for (var i = 0; i < oldData.length; i++) \{\par
      if (!oldData[i] || oldData[i].updated)\par
        continue;\par
\par
      for (var j = 0; j < newData.length; j++) \{\par
        if (newData[j].used)\par
          continue;\par
\par
        if (newData[j].url == oldData[i].url) \{\par
          // The background image and other data may have changed.\par
          oldData[i] = newData[j];\par
          oldData[i].updated = true;\par
          newData[j].used = true;\par
          break;\par
        \}\par
      \}\par
    \}\par
\par
    // Look through old pages that haven't been updated yet; replace them.\par
    for (var i = 0; i < oldData.length; i++) \{\par
      if (oldData[i] && oldData[i].updated)\par
        continue;\par
\par
      for (var j = 0; j < newData.length; j++) \{\par
        if (newData[j].used)\par
          continue;\par
\par
        oldData[i] = newData[j];\par
        oldData[i].updated = true;\par
        newData[j].used = true;\par
        break;\par
      \}\par
\par
      if (oldData[i] && !oldData[i].updated)\par
        oldData[i] = null;\par
    \}\par
\par
    // Clear 'updated' flags so this function will work next time it's called.\par
    for (var i = 0; i < THUMBNAIL_COUNT; i++) \{\par
      if (oldData[i])\par
        oldData[i].updated = false;\par
    \}\par
\par
    return oldData;\par
  \};\par
\par
  return \{\par
    MostVisitedPage: MostVisitedPage,\par
    refreshData: refreshData,\par
  \};\par
\});\par
</script>\par
<script>// Copyright (c) 2011 The Chromium Authors. All rights reserved.\par
// Use of this source code is governed by a BSD-style license that can be\par
// found in the LICENSE file.\par
\par
/**\par
 * @fileoverview Trash\par
 * This is the class for the trash can that appears when dragging an app.\par
 */\par
\par
cr.define('ntp4', function() \{\par
  'use strict';\par
\par
  function Trash(trash) \{\par
    trash.__proto__ = Trash.prototype;\par
    trash.initialize();\par
    return trash;\par
  \}\par
\par
  Trash.prototype = \{\par
    __proto__: HTMLDivElement.prototype,\par
\par
    initialize: function(element) \{\par
      this.dragWrapper_ = new cr.ui.DragWrapper(this, this);\par
    \},\par
\par
    /**\par
     * Determines whether we are interested in the drag data for |e|.\par
     * @param \{Event\} e The event from drag enter.\par
     * @return \{bool\}\par
     */\par
    shouldAcceptDrag: function(e) \{\par
      var tile = ntp4.getCurrentlyDraggingTile();\par
      if (!tile)\par
        return false;\par
\par
      return tile.firstChild.canBeRemoved();\par
    \},\par
\par
    /**\par
     * Drag over handler.\par
     * @param \{Event\} e The drag event.\par
     */\par
    doDragOver: function(e) \{\par
      ntp4.getCurrentlyDraggingTile().dragClone.classList.add(\par
          'hovering-on-trash');\par
      ntp4.setCurrentDropEffect(e.dataTransfer, 'move');\par
      e.preventDefault();\par
    \},\par
\par
    /**\par
     * Drag enter handler.\par
     * @param \{Event\} e The drag event.\par
     */\par
    doDragEnter: function(e) \{\par
      this.doDragOver(e);\par
    \},\par
\par
    /**\par
     * Drop handler.\par
     * @param \{Event\} e The drag event.\par
     */\par
    doDrop: function(e) \{\par
      e.preventDefault();\par
\par
      var tile = ntp4.getCurrentlyDraggingTile();\par
      tile.firstChild.removeFromChrome();\par
      tile.landedOnTrash = true;\par
    \},\par
\par
    /**\par
     * Drag leave handler.\par
     * @param \{Event\} e The drag event.\par
     */\par
    doDragLeave: function(e) \{\par
      ntp4.getCurrentlyDraggingTile().dragClone.classList.remove(\par
          'hovering-on-trash');\par
    \},\par
  \};\par
\par
  return \{\par
    Trash: Trash,\par
  \};\par
\});\par
</script>\par
<script>// Copyright (c) 2012 The Chromium Authors. All rights reserved.\par
// Use of this source code is governed by a BSD-style license that can be\par
// found in the LICENSE file.\par
\par
/**\par
 * @fileoverview PageListView implementation.\par
 * PageListView manages page list, dot list, switcher buttons and handles apps\par
 * pages callbacks from backend.\par
 *\par
 * Note that you need to have AppLauncherHandler in your WebUI to use this code.\par
 */\par
\par
cr.define('ntp4', function() \{\par
  'use strict';\par
\par
  /**\par
   * Object for accessing localized strings.\par
   * @type \{!LocalStrings\}\par
   */\par
  var localStrings = new LocalStrings;\par
\par
  /**\par
   * Creates a PageListView object.\par
   * @constructor\par
   * @extends \{Object\}\par
   */\par
  function PageListView() \{\par
  \}\par
\par
  PageListView.prototype = \{\par
    /**\par
     * The CardSlider object to use for changing app pages.\par
     * @type \{CardSlider|undefined\}\par
     */\par
    cardSlider: undefined,\par
\par
    /**\par
     * The frame div for this.cardSlider.\par
     * @type \{!Element|undefined\}\par
     */\par
    sliderFrame: undefined,\par
\par
    /**\par
     * The 'page-list' element.\par
     * @type \{!Element|undefined\}\par
     */\par
    pageList: undefined,\par
\par
    /**\par
     * A list of all 'tile-page' elements.\par
     * @type \{!NodeList|undefined\}\par
     */\par
    tilePages: undefined,\par
\par
    /**\par
     * A list of all 'apps-page' elements.\par
     * @type \{!NodeList|undefined\}\par
     */\par
    appsPages: undefined,\par
\par
    /**\par
     * The Most Visited page.\par
     * @type \{!Element|undefined\}\par
     */\par
    mostVisitedPage: undefined,\par
\par
    /**\par
     * The 'dots-list' element.\par
     * @type \{!Element|undefined\}\par
     */\par
    dotList: undefined,\par
\par
    /**\par
     * The left and right paging buttons.\par
     * @type \{!Element|undefined\}\par
     */\par
    pageSwitcherStart: undefined,\par
    pageSwitcherEnd: undefined,\par
\par
    /**\par
     * The 'trash' element.  Note that technically this is unnecessary,\par
     * JavaScript creates the object for us based on the id.  But I don't want\par
     * to rely on the ID being the same, and JSCompiler doesn't know about it.\par
     * @type \{!Element|undefined\}\par
     */\par
    trash: undefined,\par
\par
    /**\par
     * The type of page that is currently shown. The value is a numerical ID.\par
     * @type \{number\}\par
     */\par
    shownPage: 0,\par
\par
    /**\par
     * The index of the page that is currently shown, within the page type.\par
     * For example if the third Apps page is showing, this will be 2.\par
     * @type \{number\}\par
     */\par
    shownPageIndex: 0,\par
\par
    /**\par
     * EventTracker for managing event listeners for page events.\par
     * @type \{!EventTracker\}\par
     */\par
    eventTracker: new EventTracker,\par
\par
    /**\par
     * If non-null, this is the ID of the app to highlight to the user the next\par
     * time getAppsCallback runs. "Highlight" in this case means to switch to\par
     * the page and run the new tile animation.\par
     * @type \{String\}\par
     */\par
    highlightAppId: null,\par
\par
    /**\par
     * Initializes page list view.\par
     * @param \{!Element\} pageList A DIV element to host all pages.\par
     * @param \{!Element\} dotList An UL element to host nav dots. Each dot\par
     *     represents a page.\par
     * @param \{!Element\} cardSliderFrame The card slider frame that hosts\par
     *     pageList and switcher buttons.\par
     * @param \{!Element|undefined\} opt_trash Optional trash element.\par
     * @param \{!Element|undefined\} opt_pageSwitcherStart Optional start page\par
     *     switcher button.\par
     * @param \{!Element|undefined\} opt_pageSwitcherEnd Optional end page\par
     *     switcher button.\par
     */\par
    initialize: function(pageList, dotList, cardSliderFrame, opt_trash,\par
                         opt_pageSwitcherStart, opt_pageSwitcherEnd) \{\par
      this.pageList = pageList;\par
\par
      this.dotList = dotList;\par
      cr.ui.decorate(this.dotList, ntp4.DotList);\par
\par
      this.trash = opt_trash;\par
      if (this.trash)\par
        new ntp4.Trash(this.trash);\par
\par
      this.pageSwitcherStart = opt_pageSwitcherStart;\par
      if (this.pageSwitcherStart)\par
        ntp4.initializePageSwitcher(this.pageSwitcherStart);\par
\par
      this.pageSwitcherEnd = opt_pageSwitcherEnd;\par
      if (this.pageSwitcherEnd)\par
        ntp4.initializePageSwitcher(this.pageSwitcherEnd);\par
\par
      this.shownPage = templateData.shown_page_type;\par
      this.shownPageIndex = templateData.shown_page_index;\par
\par
      // Request data on the apps so we can fill them in.\par
      // Note that this is kicked off asynchronously.  'getAppsCallback' will be\par
      // invoked at some point after this function returns.\par
      chrome.send('getApps');\par
\par
      document.addEventListener('keydown', this.onDocKeyDown_.bind(this));\par
      // Prevent touch events from triggering any sort of native scrolling\par
      document.addEventListener('touchmove', function(e) \{\par
        e.preventDefault();\par
      \}, true);\par
\par
      this.tilePages = this.pageList.getElementsByClassName('tile-page');\par
      this.appsPages = this.pageList.getElementsByClassName('apps-page');\par
\par
      // Initialize the cardSlider without any cards at the moment\par
      this.sliderFrame = cardSliderFrame;\par
      this.cardSlider = new cr.ui.CardSlider(this.sliderFrame, this.pageList,\par
          this.sliderFrame.offsetWidth);\par
      this.cardSlider.initialize();\par
\par
      // Handle events from the card slider.\par
      this.pageList.addEventListener('cardSlider:card_changed',\par
                                     this.onCardChanged_.bind(this));\par
      this.pageList.addEventListener('cardSlider:card_added',\par
                                     this.onCardAdded_.bind(this));\par
      this.pageList.addEventListener('cardSlider:card_removed',\par
                                     this.onCardRemoved_.bind(this));\par
\par
      // Ensure the slider is resized appropriately with the window\par
      window.addEventListener('resize', this.onWindowResize_.bind(this));\par
\par
      // Update apps when online state changes.\par
      window.addEventListener('online',\par
          this.updateOfflineEnabledApps_.bind(this));\par
      window.addEventListener('offline',\par
          this.updateOfflineEnabledApps_.bind(this));\par
    \},\par
\par
    /**\par
     * Appends a tile page.\par
     *\par
     * @param \{TilePage\} page The page element.\par
     * @param \{string\} title The title of the tile page.\par
     * @param \{bool\} titleIsEditable If true, the title can be changed.\par
     * @param \{TilePage\} opt_refNode Optional reference node to insert in front\par
     *     of.\par
     * When opt_refNode is falsey, |page| will just be appended to the end of\par
     * the page list.\par
     */\par
    appendTilePage: function(page, title, titleIsEditable, opt_refNode) \{\par
      if (opt_refNode) \{\par
        var refIndex = this.getTilePageIndex(opt_refNode);\par
        this.cardSlider.insertCardAtIndex(page, refIndex);\par
      \} else \{\par
        this.cardSlider.appendCard(page);\par
      \}\par
\par
      // Remember special MostVisitedPage.\par
      if (typeof ntp4.MostVisitedPage != 'undefined' &&\par
          page instanceof ntp4.MostVisitedPage) \{\par
        assert(this.tilePages.length == 1,\par
               'MostVisitedPage should be added as first tile page');\par
        this.mostVisitedPage = page;\par
      \}\par
\par
      // If we're appending an AppsPage and it's a temporary page, animate it.\par
      var animate = page instanceof ntp4.AppsPage &&\par
                    page.classList.contains('temporary');\par
      // Make a deep copy of the dot template to add a new one.\par
      var newDot = new ntp4.NavDot(page, title, titleIsEditable, animate);\par
      page.navigationDot = newDot;\par
      this.dotList.insertBefore(newDot, opt_refNode ? opt_refNode.navigationDot\par
                                                    : null);\par
      // Set a tab index on the first dot.\par
      if (this.dotList.dots.length == 1)\par
        newDot.tabIndex = 3;\par
\par
      this.eventTracker.add(page, 'pagelayout', this.onPageLayout_.bind(this));\par
    \},\par
\par
    /**\par
     * Called by chrome when an existing app has been disabled or\par
     * removed/uninstalled from chrome.\par
     * @param \{Object\} appData A data structure full of relevant information for\par
     *     the app.\par
     * @param \{boolean\} isUninstall True if the app is being uninstalled;\par
     *     false if the app is being disabled.\par
     * @param \{boolean\} fromPage True if the removal was from the current page.\par
     */\par
    appRemoved: function(appData, isUninstall, fromPage) \{\par
      var app = $(appData.id);\par
      assert(app, 'trying to remove an app that doesn\\'t exist');\par
\par
      if (!isUninstall)\par
        app.replaceAppData(appData);\par
      else\par
        app.remove(!!fromPage);\par
    \},\par
\par
    /**\par
     * @return \{boolean\} If the page is still starting up.\par
     * @private\par
     */\par
    isStartingUp_: function() \{\par
      return document.documentElement.classList.contains('starting-up');\par
    \},\par
\par
    /**\par
     * Callback invoked by chrome with the apps available.\par
     *\par
     * Note that calls to this function can occur at any time, not just in\par
     * response to a getApps request. For example, when a user\par
     * installs/uninstalls an app on another synchronized devices.\par
     * @param \{Object\} data An object with all the data on available\par
     *        applications.\par
     */\par
    getAppsCallback: function(data) \{\par
      var startTime = Date.now();\par
\par
      // Remember this to select the correct card when done rebuilding.\par
      var prevCurrentCard = this.cardSlider.currentCard;\par
\par
      // Make removal of pages and dots as quick as possible with less DOM\par
      // operations, reflows, or repaints. We set currentCard = 0 and remove\par
      // from the end to not encounter any auto-magic card selections in the\par
      // process and we hide the card slider throughout.\par
      this.cardSlider.currentCard = 0;\par
\par
      // Clear any existing apps pages and dots.\par
      // TODO(rbyers): It might be nice to preserve animation of dots after an\par
      // uninstall. Could we re-use the existing page and dot elements?  It\par
      // seems unfortunate to have Chrome send us the entire apps list after an\par
      // uninstall.\par
      while (this.appsPages.length > 0)\par
        this.removeTilePageAndDot_(this.appsPages[this.appsPages.length - 1]);\par
\par
      // Get the array of apps and add any special synthesized entries\par
      var apps = data.apps;\par
\par
      // Get a list of page names\par
      var pageNames = data.appPageNames;\par
\par
      function stringListIsEmpty(list) \{\par
        for (var i = 0; i < list.length; i++) \{\par
          if (list[i])\par
            return false;\par
        \}\par
        return true;\par
      \}\par
\par
      // Sort by launch ordinal\par
      apps.sort(function(a, b) \{\par
        return a.app_launch_ordinal > b.app_launch_ordinal ? 1 :\par
          a.app_launch_ordinal < b.app_launch_ordinal ? -1 : 0;\par
      \});\par
\par
      // An app to animate (in case it was just installed).\par
      var highlightApp;\par
\par
      // Add the apps, creating pages as necessary\par
      for (var i = 0; i < apps.length; i++) \{\par
        var app = apps[i];\par
        var pageIndex = app.page_index || 0;\par
        while (pageIndex >= this.appsPages.length) \{\par
          var pageName = localStrings.getString('appDefaultPageName');\par
          if (this.appsPages.length < pageNames.length)\par
            pageName = pageNames[this.appsPages.length];\par
\par
          var origPageCount = this.appsPages.length;\par
          this.appendTilePage(new ntp4.AppsPage(), pageName, true);\par
          // Confirm that appsPages is a live object, updated when a new page is\par
          // added (otherwise we'd have an infinite loop)\par
          assert(this.appsPages.length == origPageCount + 1,\par
                 'expected new page');\par
        \}\par
\par
        if (app.id == this.highlightAppId)\par
          highlightApp = app;\par
        else\par
          this.appsPages[pageIndex].appendApp(app);\par
      \}\par
\par
      ntp4.AppsPage.setPromo(data.showPromo ? data : null);\par
\par
      this.cardSlider.currentCard = prevCurrentCard;\par
\par
      // Tell the slider about the pages.\par
      this.updateSliderCards();\par
\par
      if (highlightApp)\par
        this.appAdded(highlightApp, true);\par
\par
      // Mark the current page.\par
      this.cardSlider.currentCardValue.navigationDot.classList.add('selected');\par
      logEvent('apps.layout: ' + (Date.now() - startTime));\par
\par
      document.documentElement.classList.remove('starting-up');\par
    \},\par
\par
    /**\par
     * Called by chrome when a new app has been added to chrome or has been\par
     * enabled if previously disabled.\par
     * @param \{Object\} appData A data structure full of relevant information for\par
     *     the app.\par
     */\par
    appAdded: function(appData, opt_highlight) \{\par
      if (appData.id == this.highlightAppId) \{\par
        opt_highlight = true;\par
        this.highlightAppId = null;\par
      \}\par
\par
      var pageIndex = appData.page_index || 0;\par
\par
      if (pageIndex >= this.appsPages.length) \{\par
        while (pageIndex >= this.appsPages.length) \{\par
          this.appendTilePage(new ntp4.AppsPage(),\par
                              localStrings.getString('appDefaultPageName'),\par
                              true);\par
        \}\par
        this.updateSliderCards();\par
      \}\par
\par
      var page = this.appsPages[pageIndex];\par
      var app = $(appData.id);\par
      if (app)\par
        app.replaceAppData(appData);\par
      else\par
        page.appendApp(appData, opt_highlight);\par
    \},\par
\par
    /**\par
     * Callback invoked by chrome whenever an app preference changes.\par
     * @param \{Object\} data An object with all the data on available\par
     *     applications.\par
     */\par
    appsPrefChangedCallback: function(data) \{\par
      for (var i = 0; i < data.apps.length; ++i) \{\par
        $(data.apps[i].id).appData = data.apps[i];\par
      \}\par
\par
      // Set the App dot names. Skip the first dot (Most Visited).\par
      var dots = this.dotList.getElementsByClassName('dot');\par
      var start = this.mostVisitedPage ? 1 : 0;\par
      for (var i = start; i < dots.length; ++i) \{\par
        dots[i].displayTitle = data.appPageNames[i - start] || '';\par
      \}\par
    \},\par
\par
    /**\par
     * Invoked whenever the pages in apps-page-list have changed so that\par
     * the Slider knows about the new elements.\par
     */\par
    updateSliderCards: function() \{\par
      var pageNo = Math.max(0, Math.min(this.cardSlider.currentCard,\par
                                        this.tilePages.length - 1));\par
      this.cardSlider.setCards(Array.prototype.slice.call(this.tilePages),\par
                               pageNo);\par
      switch (this.shownPage) \{\par
        case templateData['apps_page_id']:\par
          this.cardSlider.selectCardByValue(\par
              this.appsPages[Math.min(this.shownPageIndex,\par
                                      this.appsPages.length - 1)]);\par
          break;\par
        case templateData['most_visited_page_id']:\par
          if (this.mostVisitedPage)\par
            this.cardSlider.selectCardByValue(this.mostVisitedPage);\par
          break;\par
      \}\par
    \},\par
\par
    /**\par
     * Called whenever tiles should be re-arranging themselves out of the way\par
     * of a moving or insert tile.\par
     */\par
    enterRearrangeMode: function() \{\par
      var tempPage = new ntp4.AppsPage();\par
      tempPage.classList.add('temporary');\par
      var pageName = localStrings.getString('appDefaultPageName');\par
      this.appendTilePage(tempPage, pageName, true);\par
\par
      if (ntp4.getCurrentlyDraggingTile().firstChild.canBeRemoved())\par
        $('footer').classList.add('showing-trash-mode');\par
    \},\par
\par
    /**\par
     * Invoked whenever some app is released\par
     */\par
    leaveRearrangeMode: function() \{\par
      var tempPage = document.querySelector('.tile-page.temporary');\par
      var dot = tempPage.navigationDot;\par
      if (!tempPage.tileCount && tempPage != this.cardSlider.currentCardValue) \{\par
        this.removeTilePageAndDot_(tempPage, true);\par
      \} else \{\par
        tempPage.classList.remove('temporary');\par
        this.saveAppPageName(tempPage,\par
                             localStrings.getString('appDefaultPageName'));\par
      \}\par
\par
      $('footer').classList.remove('showing-trash-mode');\par
    \},\par
\par
    /**\par
     * Callback for the 'pagelayout' event.\par
     * @param \{Event\} e The event.\par
     */\par
    onPageLayout_: function(e) \{\par
      if (Array.prototype.indexOf.call(this.tilePages, e.currentTarget) !=\par
          this.cardSlider.currentCard) \{\par
        return;\par
      \}\par
\par
      this.updatePageSwitchers();\par
    \},\par
\par
    /**\par
     * Adjusts the size and position of the page switchers according to the\par
     * layout of the current card.\par
     */\par
    updatePageSwitchers: function() \{\par
      if (!this.pageSwitcherStart || !this.pageSwitcherEnd)\par
        return;\par
\par
      var page = this.cardSlider.currentCardValue;\par
\par
      this.pageSwitcherStart.hidden = !page ||\par
          (this.cardSlider.currentCard == 0);\par
      this.pageSwitcherEnd.hidden = !page ||\par
          (this.cardSlider.currentCard == this.cardSlider.cardCount - 1);\par
\par
      if (!page)\par
        return;\par
\par
      var pageSwitcherLeft = isRTL() ? this.pageSwitcherEnd\par
                                     : this.pageSwitcherStart;\par
      var pageSwitcherRight = isRTL() ? this.pageSwitcherStart\par
                                      : this.pageSwitcherEnd;\par
      var scrollbarWidth = page.scrollbarWidth;\par
      pageSwitcherLeft.style.width =\par
          (page.sideMargin + 13) + 'px';\par
      pageSwitcherLeft.style.left = '0';\par
      pageSwitcherRight.style.width =\par
          (page.sideMargin - scrollbarWidth + 13) + 'px';\par
      pageSwitcherRight.style.right = scrollbarWidth + 'px';\par
\par
      var offsetTop = page.querySelector('.tile-page-content').offsetTop + 'px';\par
      pageSwitcherLeft.style.top = offsetTop;\par
      pageSwitcherRight.style.top = offsetTop;\par
      pageSwitcherLeft.style.paddingBottom = offsetTop;\par
      pageSwitcherRight.style.paddingBottom = offsetTop;\par
    \},\par
\par
    /**\par
     * Returns the index of the given apps page.\par
     * @param \{AppsPage\} page The AppsPage we wish to find.\par
     * @return \{number\} The index of |page| or -1 if it is not in the\par
     *    collection.\par
     */\par
    getAppsPageIndex: function(page) \{\par
      return Array.prototype.indexOf.call(this.appsPages, page);\par
    \},\par
\par
    /**\par
     * Handler for cardSlider:card_changed events from this.cardSlider.\par
     * @param \{Event\} e The cardSlider:card_changed event.\par
     * @private\par
     */\par
    onCardChanged_: function(e) \{\par
      var page = e.cardSlider.currentCardValue;\par
\par
      // Don't change shownPage until startup is done (and page changes actually\par
      // reflect user actions).\par
      if (!this.isStartingUp_()) \{\par
        if (page.classList.contains('apps-page')) \{\par
          this.shownPage = templateData.apps_page_id;\par
          this.shownPageIndex = this.getAppsPageIndex(page);\par
        \} else if (page.classList.contains('most-visited-page')) \{\par
          this.shownPage = templateData.most_visited_page_id;\par
          this.shownPageIndex = 0;\par
        \} else \{\par
          console.error('unknown page selected');\par
        \}\par
        chrome.send('pageSelected', [this.shownPage, this.shownPageIndex]);\par
      \}\par
\par
      // Update the active dot\par
      var curDot = this.dotList.getElementsByClassName('selected')[0];\par
      if (curDot)\par
        curDot.classList.remove('selected');\par
      page.navigationDot.classList.add('selected');\par
      this.updatePageSwitchers();\par
    \},\par
\par
    /**\par
     * Listen for card additions to update the page switchers or the current\par
     * card accordingly.\par
     * @param \{Event\} e A card removed or added event.\par
     */\par
    onCardAdded_: function(e) \{\par
      // When the second arg passed to insertBefore is falsey, it acts just like\par
      // appendChild.\par
      this.pageList.insertBefore(e.addedCard, this.tilePages[e.addedIndex]);\par
      if (!this.isStartingUp_())\par
        this.updatePageSwitchers();\par
    \},\par
\par
    /**\par
     * Listen for card removals to update the page switchers or the current card\par
     * accordingly.\par
     * @param \{Event\} e A card removed or added event.\par
     */\par
    onCardRemoved_: function(e) \{\par
      e.removedCard.parentNode.removeChild(e.removedCard);\par
      if (!this.isStartingUp_())\par
        this.updatePageSwitchers();\par
    \},\par
\par
    /**\par
     * Save the name of an apps page.\par
     * Store the apps page name into the preferences store.\par
     * @param \{AppsPage\} appsPage The app page for which we wish to save.\par
     * @param \{string\} name The name of the page.\par
     */\par
    saveAppPageName: function(appPage, name) \{\par
      var index = this.getAppsPageIndex(appPage);\par
      assert(index != -1);\par
      chrome.send('saveAppPageName', [name, index]);\par
    \},\par
\par
    /**\par
     * Window resize handler.\par
     * @private\par
     */\par
    onWindowResize_: function(e) \{\par
      this.cardSlider.resize(this.sliderFrame.offsetWidth);\par
      this.updatePageSwitchers();\par
    \},\par
\par
    /**\par
     * Listener for offline status change events. Updates apps that are\par
     * not offline-enabled to be grayscale if the browser is offline.\par
     * @private\par
     */\par
    updateOfflineEnabledApps_: function() \{\par
      var apps = document.querySelectorAll('.app');\par
      for (var i = 0; i < apps.length; ++i) \{\par
        if (apps[i].appData.enabled && !apps[i].appData.offline_enabled) \{\par
          apps[i].setIcon();\par
          apps[i].loadIcon();\par
        \}\par
      \}\par
    \},\par
\par
    /**\par
     * Handler for key events on the page. Ctrl-Arrow will switch the visible\par
     * page.\par
     * @param \{Event\} e The KeyboardEvent.\par
     * @private\par
     */\par
    onDocKeyDown_: function(e) \{\par
      if (!e.ctrlKey || e.altKey || e.metaKey || e.shiftKey)\par
        return;\par
\par
      var direction = 0;\par
      if (e.keyIdentifier == 'Left')\par
        direction = -1;\par
      else if (e.keyIdentifier == 'Right')\par
        direction = 1;\par
      else\par
        return;\par
\par
      var cardIndex =\par
          (this.cardSlider.currentCard + direction +\par
           this.cardSlider.cardCount) % this.cardSlider.cardCount;\par
      this.cardSlider.selectCard(cardIndex, true);\par
\par
      e.stopPropagation();\par
    \},\par
\par
    /**\par
     * Returns the index of a given tile page.\par
     * @param \{TilePage\} page The TilePage we wish to find.\par
     * @return \{number\} The index of |page| or -1 if it is not in the\par
     *    collection.\par
     */\par
    getTilePageIndex: function(page) \{\par
      return Array.prototype.indexOf.call(this.tilePages, page);\par
    \},\par
\par
    /**\par
     * Removes a page and navigation dot (if the navdot exists).\par
     * @param \{TilePage\} page The page to be removed.\par
     * @param \{boolean=\} opt_animate If the removal should be animated.\par
     */\par
    removeTilePageAndDot_: function(page, opt_animate) \{\par
      if (page.navigationDot)\par
        page.navigationDot.remove(opt_animate);\par
      this.cardSlider.removeCard(page);\par
    \},\par
  \};\par
\par
  return \{\par
    PageListView: PageListView\par
  \};\par
\});\par
</script>\par
<script>// Copyright (c) 2012 The Chromium Authors. All rights reserved.\par
// Use of this source code is governed by a BSD-style license that can be\par
// found in the LICENSE file.\par
\par
/**\par
 * @fileoverview Page switcher\par
 * This is the class for the left and right navigation arrows that switch\par
 * between pages.\par
 */\par
cr.define('ntp4', function() \{\par
\par
  function PageSwitcher() \{\par
  \}\par
\par
  PageSwitcher.template = \{\par
    __proto__: HTMLButtonElement.prototype,\par
\par
    decorate: function(el) \{\par
      el.__proto__ = PageSwitcher.template;\par
\par
      el.addEventListener('click', el.activate_);\par
      el.addEventListener('mousewheel', el.onMouseWheel_);\par
\par
      el.direction_ = el.id == 'page-switcher-start' ? -1 : 1;\par
\par
      el.dragWrapper_ = new cr.ui.DragWrapper(el, el);\par
    \},\par
\par
    /**\par
     * Activate the switcher (go to the next card).\par
     * @private\par
     */\par
    activate_: function() \{\par
      var cardSlider = ntp4.getCardSlider();\par
      var index = cardSlider.currentCard + this.direction_;\par
      var numCards = cardSlider.cardCount - 1;\par
      cardSlider.selectCard(Math.max(0, Math.min(index, numCards)), true);\par
    \},\par
\par
    /**\par
     * Handler for the mousewheel event on a pager. We pass through the scroll\par
     * to the page. This is necssary because the page is our sibling in the DOM\par
     * hierarchy, so the event won't naturally pass through to it.\par
     * @param \{Event\} e The mousewheel event.\par
     * @private\par
     */\par
    onMouseWheel_: function(e) \{\par
      var page = ntp4.getCardSlider().currentCardValue;\par
      page.handleMouseWheel(e);\par
    \},\par
\par
    shouldAcceptDrag: function(e) \{\par
      // We allow all drags to trigger the page switching effect.\par
      return true;\par
    \},\par
\par
    doDragEnter: function(e) \{\par
      this.scheduleDelayedSwitch_();\par
      this.doDragOver(e);\par
    \},\par
\par
    doDragLeave: function(e) \{\par
      this.cancelDelayedSwitch_();\par
    \},\par
\par
    doDragOver: function(e) \{\par
      e.preventDefault();\par
      var targetPage = ntp4.getCardSlider().currentCardValue;\par
      if (targetPage.shouldAcceptDrag(e))\par
        targetPage.setDropEffect(e.dataTransfer);\par
    \},\par
\par
    doDrop: function(e) \{\par
      e.stopPropagation();\par
      this.cancelDelayedSwitch_();\par
\par
      var tile = ntp4.getCurrentlyDraggingTile();\par
      if (!tile)\par
        return;\par
\par
      var sourcePage = tile.tilePage;\par
      var targetPage = ntp4.getCardSlider().currentCardValue;\par
      if (targetPage == sourcePage || !targetPage.shouldAcceptDrag(e))\par
        return;\par
\par
      targetPage.appendDraggingTile();\par
    \},\par
\par
    /**\par
     * Starts a timer to activate the switcher. The timer repeats until\par
     * cancelled by cancelDelayedSwitch_.\par
     * @private\par
     */\par
    scheduleDelayedSwitch_: function() \{\par
      var self = this;\par
      function navPageClearTimeout() \{\par
        self.activate_();\par
        self.dragNavTimeout_ = null;\par
        self.scheduleDelayedSwitch_();\par
      \}\par
      this.dragNavTimeout_ = window.setTimeout(navPageClearTimeout, 500);\par
    \},\par
\par
    /**\par
     * Cancels the timer that activates the switcher while dragging.\par
     * @private\par
     */\par
    cancelDelayedSwitch_: function() \{\par
      if (this.dragNavTimeout_) \{\par
        window.clearTimeout(this.dragNavTimeout_);\par
        this.dragNavTimeout_ = null;\par
      \}\par
    \},\par
\par
  \};\par
\par
  return \{\par
    initializePageSwitcher: PageSwitcher.template.decorate\par
  \}\par
\});\par
</script>\par
\par
<script>// Copyright (c) 2012 The Chromium Authors. All rights reserved.\par
// Use of this source code is governed by a BSD-style license that can be\par
// found in the LICENSE file.\par
\par
/**\par
 * @fileoverview Nav dot\par
 * This is the class for the navigation controls that appear along the bottom\par
 * of the NTP.\par
 */\par
\par
cr.define('ntp4', function() \{\par
  'use strict';\par
\par
  /**\par
   * Creates a new navigation dot.\par
   * @param \{TilePage\} page The associated TilePage.\par
   * @param \{string\} title The title of the navigation dot.\par
   * @param \{bool\} titleIsEditable If true, the title can be changed.\par
   * @param \{bool\} animate If true, animates into existence.\par
   * @constructor\par
   * @extends \{HTMLLIElement\}\par
   */\par
  function NavDot(page, title, titleIsEditable, animate) \{\par
    var dot = cr.doc.createElement('li');\par
    dot.__proto__ = NavDot.prototype;\par
    dot.initialize(page, title, titleIsEditable, animate);\par
\par
    return dot;\par
  \}\par
\par
  NavDot.prototype = \{\par
    __proto__: HTMLLIElement.prototype,\par
\par
    initialize: function(page, title, titleIsEditable, animate) \{\par
      this.className = 'dot';\par
      this.setAttribute('role', 'button');\par
\par
      this.page_ = page;\par
\par
      var selectionBar = this.ownerDocument.createElement('div');\par
      selectionBar.className = 'selection-bar';\par
      this.appendChild(selectionBar);\par
\par
      // TODO(estade): should there be some limit to the number of characters?\par
      this.input_ = this.ownerDocument.createElement('input');\par
      this.input_.setAttribute('spellcheck', false);\par
      this.input_.value = title;\par
      // Take the input out of the tab-traversal focus order.\par
      this.input_.disabled = true;\par
      this.appendChild(this.input_);\par
\par
      this.displayTitle = title;\par
      this.titleIsEditable_ = titleIsEditable;\par
\par
      this.addEventListener('keydown', this.onKeyDown_);\par
      this.addEventListener('click', this.onClick_);\par
      this.addEventListener('dblclick', this.onDoubleClick_);\par
      this.dragWrapper_ = new cr.ui.DragWrapper(this, this);\par
      this.addEventListener('webkitTransitionEnd', this.onTransitionEnd_);\par
\par
      this.input_.addEventListener('blur', this.onInputBlur_.bind(this));\par
      this.input_.addEventListener('mousedown',\par
                                   this.onInputMouseDown_.bind(this));\par
      this.input_.addEventListener('keydown', this.onInputKeyDown_.bind(this));\par
\par
      if (animate) \{\par
        this.classList.add('small');\par
        var self = this;\par
        window.setTimeout(function() \{\par
          self.classList.remove('small');\par
        \}, 0);\par
      \}\par
    \},\par
\par
    /**\par
     * Gets the associated TilePage.\par
     * @return \{TilePage\}\par
     */\par
    get page() \{\par
      return this.page_;\par
    \},\par
\par
    /**\par
     * Sets/gets the display title.\par
     * @type \{String\} title The display name for this nav dot.\par
     */\par
    get displayTitle() \{\par
      return this.title;\par
    \},\par
    set displayTitle(title) \{\par
      this.title = this.input_.value = title;\par
    \},\par
\par
    /**\par
     * Removes the dot from the page. If |opt_animate| is truthy, we first\par
     * transition the element to 0 width.\par
     * @param \{boolean=\} opt_animate Whether to animate the removal or not.\par
     */\par
    remove: function(opt_animate) \{\par
      if (opt_animate)\par
        this.classList.add('small');\par
      else\par
        this.parentNode.removeChild(this);\par
    \},\par
\par
    /**\par
     * Navigates the card slider to the page for this dot.\par
     */\par
    switchToPage: function() \{\par
      ntp4.getCardSlider().selectCardByValue(this.page_, true);\par
    \},\par
\par
    /**\par
     * Handler for keydown event on the dot.\par
     * @param \{Event\} e The KeyboardEvent.\par
     */\par
    onKeyDown_: function(e) \{\par
      if (e.keyIdentifier == 'Enter') \{\par
        this.onClick_(e);\par
        e.stopPropagation();\par
      \}\par
    \},\par
\par
    /**\par
     * Clicking causes the associated page to show.\par
     * @param \{Event\} e The click event.\par
     * @private\par
     */\par
    onClick_: function(e) \{\par
      this.switchToPage();\par
      // The explicit focus call is necessary because of overriding the default\par
      // handling in onInputMouseDown_.\par
      if (this.ownerDocument.activeElement != this.input_)\par
        this.focus();\par
\par
      chrome.send('introMessageDismissed');\par
      e.stopPropagation();\par
    \},\par
\par
    /**\par
     * Double clicks allow the user to edit the page title.\par
     * @param \{Event\} e The click event.\par
     * @private\par
     */\par
    onDoubleClick_: function(e) \{\par
      if (this.titleIsEditable_) \{\par
        this.input_.disabled = false;\par
        this.input_.focus();\par
        this.input_.select();\par
      \}\par
    \},\par
\par
    /**\par
     * Prevent mouse down on the input from selecting it.\par
     * @param \{Event\} e The click event.\par
     * @private\par
     */\par
    onInputMouseDown_: function(e) \{\par
      if (this.ownerDocument.activeElement != this.input_)\par
        e.preventDefault();\par
    \},\par
\par
    /**\par
     * Handle keypresses on the input.\par
     * @param \{Event\} e The click event.\par
     * @private\par
     */\par
    onInputKeyDown_: function(e) \{\par
      switch (e.keyIdentifier) \{\par
        case 'U+001B':  // Escape cancels edits.\par
          this.input_.value = this.displayTitle;\par
        case 'Enter':  // Fall through.\par
          this.input_.blur();\par
          break;\par
      \}\par
    \},\par
\par
    /**\par
     * When the input blurs, commit the edited changes.\par
     * @param \{Event\} e The blur event.\par
     * @private\par
     */\par
    onInputBlur_: function(e) \{\par
      window.getSelection().removeAllRanges();\par
      this.displayTitle = this.input_.value;\par
      ntp4.saveAppPageName(this.page_, this.displayTitle);\par
      this.input_.disabled = true;\par
    \},\par
\par
    shouldAcceptDrag: function(e) \{\par
      return this.page_.shouldAcceptDrag(e);\par
    \},\par
\par
    /**\par
     * A drag has entered the navigation dot. If the user hovers long enough,\par
     * we will navigate to the relevant page.\par
     * @param \{Event\} e The MouseOver event for the drag.\par
     * @private\par
     */\par
    doDragEnter: function(e) \{\par
      var self = this;\par
      function navPageClearTimeout() \{\par
        self.switchToPage();\par
        self.dragNavTimeout = null;\par
      \}\par
      this.dragNavTimeout = window.setTimeout(navPageClearTimeout, 500);\par
\par
      this.doDragOver(e);\par
    \},\par
\par
    /**\par
     * A dragged element has moved over the navigation dot. Show the correct\par
     * indicator and prevent default handling so the <input> won't act as a drag\par
     * target.\par
     * @param \{Event\} e The MouseOver event for the drag.\par
     * @private\par
     */\par
    doDragOver: function(e) \{\par
      e.preventDefault();\par
\par
      if (!this.dragWrapper_.isCurrentDragTarget)\par
        ntp4.setCurrentDropEffect(e.dataTransfer, 'none');\par
      else\par
        this.page_.setDropEffect(e.dataTransfer);\par
    \},\par
\par
    /**\par
     * A dragged element has been dropped on the navigation dot. Tell the page\par
     * to append it.\par
     * @param \{Event\} e The MouseOver event for the drag.\par
     * @private\par
     */\par
    doDrop: function(e) \{\par
      e.stopPropagation();\par
      var tile = ntp4.getCurrentlyDraggingTile();\par
      if (tile && tile.tilePage != this.page_)\par
        this.page_.appendDraggingTile();\par
      // TODO(estade): handle non-tile drags.\par
\par
      this.cancelDelayedSwitch_();\par
    \},\par
\par
    /**\par
     * The drag has left the navigation dot.\par
     * @param \{Event\} e The MouseOver event for the drag.\par
     * @private\par
     */\par
    doDragLeave: function(e) \{\par
      this.cancelDelayedSwitch_();\par
    \},\par
\par
    /**\par
     * Cancels the timer for page switching.\par
     * @private\par
     */\par
    cancelDelayedSwitch_: function() \{\par
      if (this.dragNavTimeout) \{\par
        window.clearTimeout(this.dragNavTimeout);\par
        this.dragNavTimeout = null;\par
      \}\par
    \},\par
\par
    /**\par
     * A transition has ended.\par
     * @param \{Event\} e The transition end event.\par
     * @private\par
     */\par
    onTransitionEnd_: function(e) \{\par
      if (e.propertyName === 'max-width' && this.classList.contains('small'))\par
        this.parentNode.removeChild(this);\par
    \},\par
  \};\par
\par
  return \{\par
    NavDot: NavDot,\par
  \};\par
\});\par
</script>\par
<script>// Copyright (c) 2012 The Chromium Authors. All rights reserved.\par
// Use of this source code is governed by a BSD-style license that can be\par
// found in the LICENSE file.\par
\par
/**\par
 * @fileoverview New tab page\par
 * This is the main code for the new tab page used by touch-enabled Chrome\par
 * browsers.  For now this is still a prototype.\par
 */\par
\par
// Use an anonymous function to enable strict mode just for this file (which\par
// will be concatenated with other files when embedded in Chrome\par
cr.define('ntp4', function() \{\par
  'use strict';\par
\par
  /**\par
   * NewTabView instance.\par
   * @type \{!Object|undefined\}\par
   */\par
  var newTabView;\par
\par
  /**\par
   * The 'notification-container' element.\par
   * @type \{!Element|undefined\}\par
   */\par
  var notificationContainer;\par
\par
  /**\par
   * Object for accessing localized strings.\par
   * @type \{!LocalStrings\}\par
   */\par
  var localStrings = new LocalStrings;\par
\par
  /**\par
   * If non-null, an info bubble for showing messages to the user. It points at\par
   * the Most Visited label, and is used to draw more attention to the\par
   * navigation dot UI.\par
   * @type \{!Element|undefined\}\par
   */\par
  var infoBubble;\par
\par
  /**\par
   * If non-null, an bubble confirming that the user has signed into sync. It\par
   * points at the login status at the top of the page.\par
   * @type \{!Element|undefined\}\par
   */\par
  var loginBubble;\par
\par
  /**\par
   * true if |loginBubble| should be shown.\par
   * @type \{Boolean\}\par
   */\par
  var shouldShowLoginBubble = false;\par
\par
  /**\par
   * The time in milliseconds for most transitions.  This should match what's\par
   * in new_tab.css.  Unfortunately there's no better way to try to time\par
   * something to occur until after a transition has completed.\par
   * @type \{number\}\par
   * @const\par
   */\par
  var DEFAULT_TRANSITION_TIME = 500;\par
\par
  /**\par
   * Creates a NewTabView object. NewTabView extends PageListView with\par
   * new tab UI specific logics.\par
   * @constructor\par
   * @extends \{PageListView\}\par
   */\par
  function NewTabView() \{\par
    this.initialize(getRequiredElement('page-list'),\par
                    getRequiredElement('dot-list'),\par
                    getRequiredElement('card-slider-frame'),\par
                    getRequiredElement('trash'),\par
                    getRequiredElement('page-switcher-start'),\par
                    getRequiredElement('page-switcher-end'));\par
  \}\par
\par
  NewTabView.prototype = \{\par
    __proto__: ntp4.PageListView.prototype,\par
\par
    /** @inheritDoc */\par
    appendTilePage: function(page, title, titleIsEditable, opt_refNode) \{\par
      ntp4.PageListView.prototype.appendTilePage.apply(this, arguments);\par
\par
      if (infoBubble)\par
        window.setTimeout(infoBubble.reposition.bind(infoBubble), 0);\par
    \}\par
  \};\par
\par
  /**\par
   * Invoked at startup once the DOM is available to initialize the app.\par
   */\par
  function onLoad() \{\par
    cr.enablePlatformSpecificCSSRules();\par
\par
    measureNavDots();\par
\par
    // Load the current theme colors.\par
    themeChanged();\par
\par
    newTabView = new NewTabView();\par
\par
    notificationContainer = getRequiredElement('notification-container');\par
    notificationContainer.addEventListener(\par
        'webkitTransitionEnd', onNotificationTransitionEnd);\par
\par
    cr.ui.decorate($('recently-closed-menu-button'), ntp4.RecentMenuButton);\par
    chrome.send('getRecentlyClosedTabs');\par
\par
    newTabView.appendTilePage(new ntp4.MostVisitedPage(),\par
                              localStrings.getString('mostvisited'),\par
                              false);\par
    chrome.send('getMostVisited');\par
\par
    if (templateData.isWebStoreExperimentEnabled) \{\par
      var webstoreLink = localStrings.getString('webStoreLink');\par
      var url = appendParam(webstoreLink, 'utm_source', 'chrome-ntp-launcher');\par
      $('chrome-web-store-href').href = url;\par
\par
      $('chrome-web-store-href').addEventListener('click',\par
          onChromeWebStoreButtonClick);\par
\par
      $('footer-content').classList.add('enable-cws-experiment');\par
    \}\par
\par
    if (localStrings.getString('login_status_message')) \{\par
      loginBubble = new cr.ui.Bubble;\par
      loginBubble.anchorNode = $('login-container');\par
      loginBubble.setArrowLocation(cr.ui.ArrowLocation.TOP_END);\par
      loginBubble.bubbleAlignment =\par
          cr.ui.BubbleAlignment.BUBBLE_EDGE_TO_ANCHOR_EDGE;\par
      loginBubble.deactivateToDismissDelay = 2000;\par
      loginBubble.setCloseButtonVisible(false);\par
\par
      $('login-status-learn-more').href =\par
          localStrings.getString('login_status_url');\par
      $('login-status-advanced').onclick = function() \{\par
        chrome.send('showAdvancedLoginUI');\par
      \}\par
      $('login-status-dismiss').onclick = loginBubble.hide.bind(loginBubble);\par
\par
      var bubbleContent = $('login-status-bubble-contents');\par
      loginBubble.content = bubbleContent;\par
\par
      // The anchor node won't be updated until updateLogin is called so don't\par
      // show the bubble yet.\par
      shouldShowLoginBubble = true;\par
    \} else if (localStrings.getString('ntp4_intro_message')) \{\par
      infoBubble = new cr.ui.Bubble;\par
      infoBubble.anchorNode = newTabView.mostVisitedPage.navigationDot;\par
      infoBubble.setArrowLocation(cr.ui.ArrowLocation.BOTTOM_START);\par
      infoBubble.handleCloseEvent = function() \{\par
        this.hide();\par
        chrome.send('introMessageDismissed');\par
      \}\par
\par
      var bubbleContent = $('ntp4-intro-bubble-contents');\par
      infoBubble.content = bubbleContent;\par
\par
      var learnMoreLink = infoBubble.querySelector('a');\par
      learnMoreLink.href = localStrings.getString('ntp4_intro_url');\par
      learnMoreLink.onclick = infoBubble.hide.bind(infoBubble);\par
\par
      infoBubble.show();\par
      chrome.send('introMessageSeen');\par
    \}\par
\par
    var serverpromo = localStrings.getString('serverpromo');\par
    if (serverpromo) \{\par
      showNotification(parseHtmlSubset(serverpromo), [], function() \{\par
        chrome.send('closeNotificationPromo');\par
      \}, 60000);\par
      chrome.send('notificationPromoViewed');\par
    \}\par
\par
    var loginContainer = getRequiredElement('login-container');\par
    loginContainer.addEventListener('click', function() \{\par
      var rect = loginContainer.getBoundingClientRect();\par
      chrome.send('showSyncLoginUI',\par
                  [rect.left, rect.top, rect.width, rect.height]);\par
    \});\par
    chrome.send('initializeSyncLogin');\par
  \}\par
\par
  /**\par
   * Launches the chrome web store app with the chrome-ntp-launcher\par
   * source.\par
   * @param \{Event\} e The click event.\par
   */\par
  function onChromeWebStoreButtonClick(e) \{\par
    chrome.send('recordAppLaunchByURL',\par
                [encodeURIComponent(this.href),\par
                 ntp4.APP_LAUNCH.NTP_WEBSTORE_FOOTER]);\par
  \}\par
\par
  /**\par
   * Fills in an invisible div with the 'Most Visited' string so that\par
   * its length may be measured and the nav dots sized accordingly.\par
   */\par
  function measureNavDots() \{\par
    var measuringDiv = $('fontMeasuringDiv');\par
    measuringDiv.textContent = localStrings.getString('mostvisited');\par
    var pxWidth = Math.max(measuringDiv.clientWidth * 1.15, 80);\par
\par
    var styleElement = document.createElement('style');\par
    styleElement.type = 'text/css';\par
    // max-width is used because if we run out of space, the nav dots will be\par
    // shrunk.\par
    styleElement.textContent = '.dot \{ max-width: ' + pxWidth + 'px; \}';\par
    document.querySelector('head').appendChild(styleElement);\par
  \}\par
\par
  // TODO(estade): rename newtab.css to new_tab_theme.css\par
  function themeChanged(hasAttribution) \{\par
    $('themecss').href = 'chrome://theme/css/newtab.css?' + Date.now();\par
    if (typeof hasAttribution != 'undefined')\par
      document.documentElement.setAttribute('hasattribution', hasAttribution);\par
    updateLogo();\par
    updateAttribution();\par
  \}\par
\par
  /**\par
   * Sets the proper image for the logo at the bottom left.\par
   */\par
  function updateLogo() \{\par
    var imageId = 'IDR_PRODUCT_LOGO';\par
    if (document.documentElement.getAttribute('customlogo') == 'true')\par
      imageId = 'IDR_CUSTOM_PRODUCT_LOGO';\par
\par
    $('logo-img').src = 'chrome://theme/' + imageId + '?' + Date.now();\par
  \}\par
\par
  /**\par
   * Attributes the attribution image at the bottom left.\par
   */\par
  function updateAttribution() \{\par
    var attribution = $('attribution');\par
    if (document.documentElement.getAttribute('hasattribution') == 'true') \{\par
      $('attribution-img').src =\par
          'chrome://theme/IDR_THEME_NTP_ATTRIBUTION?' + Date.now();\par
      attribution.hidden = false;\par
    \} else \{\par
      attribution.hidden = true;\par
    \}\par
  \}\par
\par
  /**\par
   * Timeout ID.\par
   * @type \{number\}\par
   */\par
  var notificationTimeout_ = 0;\par
\par
  /**\par
   * Shows the notification bubble.\par
   * @param \{string|Node\} message The notification message or node to use as\par
   *     message.\par
   * @param \{Array.<\{text: string, action: function()\}>\} links An array of\par
   *     records describing the links in the notification. Each record should\par
   *     have a 'text' attribute (the display string) and an 'action' attribute\par
   *     (a function to run when the link is activated).\par
   * @param \{Function\} opt_closeHandler The callback invoked if the user\par
   *     manually dismisses the notification.\par
   */\par
  function showNotification(message, links, opt_closeHandler, opt_timeout) \{\par
    window.clearTimeout(notificationTimeout_);\par
\par
    var span = document.querySelector('#notification > span');\par
    if (typeof message == 'string') \{\par
      span.textContent = message;\par
    \} else \{\par
      span.textContent = '';  // Remove all children.\par
      span.appendChild(message);\par
    \}\par
\par
    var linksBin = $('notificationLinks');\par
    linksBin.textContent = '';\par
    for (var i = 0; i < links.length; i++) \{\par
      var link = linksBin.ownerDocument.createElement('div');\par
      link.textContent = links[i].text;\par
      link.action = links[i].action;\par
      link.onclick = function() \{\par
        this.action();\par
        hideNotification();\par
      \}\par
      link.setAttribute('role', 'button');\par
      link.setAttribute('tabindex', 0);\par
      link.className = 'linkButton';\par
      linksBin.appendChild(link);\par
    \}\par
\par
    document.querySelector('#notification button').onclick = function(e) \{\par
      if (opt_closeHandler)\par
        opt_closeHandler();\par
      hideNotification();\par
    \};\par
\par
    var timeout = opt_timeout || 10000;\par
    notificationContainer.hidden = false;\par
    notificationContainer.classList.remove('inactive');\par
    notificationTimeout_ = window.setTimeout(hideNotification, timeout);\par
  \}\par
\par
  /**\par
   * Hide the notification bubble.\par
   */\par
  function hideNotification() \{\par
    notificationContainer.classList.add('inactive');\par
  \}\par
\par
  /**\par
   * When done fading out, set hidden to true so the notification can't be\par
   * tabbed to or clicked.\par
   */\par
  function onNotificationTransitionEnd(e) \{\par
    if (notificationContainer.classList.contains('inactive'));\par
      notificationContainer.hidden = true;\par
  \}\par
\par
  function setRecentlyClosedTabs(dataItems) \{\par
    $('recently-closed-menu-button').dataItems = dataItems;\par
  \}\par
\par
  function setMostVisitedPages(data, hasBlacklistedUrls) \{\par
    newTabView.mostVisitedPage.data = data;\par
  \}\par
\par
  /**\par
   * Set the dominant color for a node. This will be called in response to\par
   * getFaviconDominantColor. The node represented by |id| better have a setter\par
   * for stripeColor.\par
   * @param \{string\} id The ID of a node.\par
   * @param \{string\} color The color represented as a CSS string.\par
   */\par
  function setStripeColor(id, color) \{\par
    var node = $(id);\par
    if (node)\par
      node.stripeColor = color;\par
  \}\par
\par
  /**\par
   * Updates the text displayed in the login container. If there is no text then\par
   * the login container is hidden.\par
   * @param \{string\} loginHeader The first line of text.\par
   * @param \{string\} loginSubHeader The second line of text.\par
   * @param \{string\} iconURL The url for the login status icon. If this is null\par
        then the login status icon is hidden.\par
   */\par
  function updateLogin(loginHeader, loginSubHeader, iconURL) \{\par
    if (loginHeader || loginSubHeader) \{\par
      $('login-container').hidden = false;\par
      $('login-status-header').innerHTML = loginHeader;\par
      $('login-status-sub-header').innerHTML = loginSubHeader;\par
      $('card-slider-frame').classList.add('showing-login-area');\par
\par
      if (iconURL) \{\par
        $('login-status-header-container').style.backgroundImage = url(iconURL);\par
        $('login-status-header-container').classList.add('login-status-icon');\par
      \} else \{\par
        $('login-status-header-container').style.backgroundImage = 'none';\par
        $('login-status-header-container').classList.remove(\par
            'login-status-icon');\par
      \}\par
    \} else \{\par
      $('login-container').hidden = true;\par
      $('card-slider-frame').classList.remove('showing-login-area');\par
    \}\par
    if (shouldShowLoginBubble) \{\par
      window.setTimeout(loginBubble.show.bind(loginBubble), 0);\par
      chrome.send('loginMessageSeen');\par
      shouldShowLoginBubble = false;\par
    \} else if (loginBubble) \{\par
      loginBubble.reposition();\par
    \}\par
  \}\par
\par
  /**\par
   * Wrappers to forward the callback to corresponding PageListView member.\par
   */\par
  function appAdded() \{\par
    return newTabView.appAdded.apply(newTabView, arguments);\par
  \}\par
\par
  function appRemoved() \{\par
    return newTabView.appRemoved.apply(newTabView, arguments);\par
  \}\par
\par
  function appsPrefChangeCallback() \{\par
    return newTabView.appsPrefChangedCallback.apply(newTabView, arguments);\par
  \}\par
\par
  function appsReordered() \{\par
    return newTabView.appsReordered.apply(newTabView, arguments);\par
  \}\par
\par
  function enterRearrangeMode() \{\par
    return newTabView.enterRearrangeMode.apply(newTabView, arguments);\par
  \}\par
\par
  function getAppsCallback() \{\par
    return newTabView.getAppsCallback.apply(newTabView, arguments);\par
  \}\par
\par
  function getAppsPageIndex() \{\par
    return newTabView.getAppsPageIndex.apply(newTabView, arguments);\par
  \}\par
\par
  function getCardSlider() \{\par
    return newTabView.cardSlider;\par
  \}\par
\par
  function leaveRearrangeMode() \{\par
    return newTabView.leaveRearrangeMode.apply(newTabView, arguments);\par
  \}\par
\par
  function saveAppPageName() \{\par
    return newTabView.saveAppPageName.apply(newTabView, arguments);\par
  \}\par
\par
  function setAppToBeHighlighted(appId) \{\par
    newTabView.highlightAppId = appId;\par
  \}\par
\par
  // Return an object with all the exports\par
  return \{\par
    appAdded: appAdded,\par
    appRemoved: appRemoved,\par
    appsPrefChangeCallback: appsPrefChangeCallback,\par
    enterRearrangeMode: enterRearrangeMode,\par
    getAppsCallback: getAppsCallback,\par
    getAppsPageIndex: getAppsPageIndex,\par
    getCardSlider: getCardSlider,\par
    onLoad: onLoad,\par
    leaveRearrangeMode: leaveRearrangeMode,\par
    saveAppPageName: saveAppPageName,\par
    setAppToBeHighlighted: setAppToBeHighlighted,\par
    setMostVisitedPages: setMostVisitedPages,\par
    setRecentlyClosedTabs: setRecentlyClosedTabs,\par
    setStripeColor: setStripeColor,\par
    showNotification: showNotification,\par
    themeChanged: themeChanged,\par
    updateLogin: updateLogin\par
  \};\par
\});\par
\par
// publish ntp globals\par
// TODO(estade): update the content handlers to use ntp namespace instead of\par
// making these global.\par
var getAppsCallback = ntp4.getAppsCallback;\par
var appsPrefChangeCallback = ntp4.appsPrefChangeCallback;\par
var themeChanged = ntp4.themeChanged;\par
var recentlyClosedTabs = ntp4.setRecentlyClosedTabs;\par
var setMostVisitedPages = ntp4.setMostVisitedPages;\par
var updateLogin = ntp4.updateLogin;\par
\par
document.addEventListener('DOMContentLoaded', ntp4.onLoad);\par
</script>\par
<script>// Copyright (c) 2011 The Chromium Authors. All rights reserved.\par
// Use of this source code is governed by a BSD-style license that can be\par
// found in the LICENSE file.\par
\par
/**\par
 * @fileoverview The recently closed menu: button, model data, and menu.\par
 */\par
\par
cr.define('ntp4', function() \{\par
  'use strict';\par
\par
  var localStrings = new LocalStrings();\par
\par
  /**\par
   * Returns the text used for a recently closed window.\par
   * @param \{number\} numTabs Number of tabs in the window.\par
   * @return \{string\} The text to use.\par
   */\par
  function formatTabsText(numTabs) \{\par
    if (numTabs == 1)\par
      return localStrings.getString('closedwindowsingle');\par
    return localStrings.getStringF('closedwindowmultiple', numTabs);\par
  \}\par
\par
  var Menu = cr.ui.Menu;\par
  var MenuItem = cr.ui.MenuItem;\par
  var MenuButton = cr.ui.MenuButton;\par
  var RecentMenuButton = cr.ui.define('button');\par
\par
  RecentMenuButton.prototype = \{\par
    __proto__: MenuButton.prototype,\par
\par
    decorate: function() \{\par
      MenuButton.prototype.decorate.call(this);\par
      this.menu = new Menu;\par
      cr.ui.decorate(this.menu, Menu);\par
      this.menu.classList.add('recent-menu');\par
      document.body.appendChild(this.menu);\par
\par
      this.needsRebuild_ = true;\par
      this.classList.add('invisible');\par
      this.anchorType = cr.ui.AnchorType.ABOVE;\par
      this.invertLeftRight = true;\par
    \},\par
\par
    /**\par
     * Shows the menu, first rebuilding it if necessary.\par
     * TODO(estade): the right of the menu should align with the right of the\par
     * button.\par
     * @override\par
     */\par
    showMenu: function() \{\par
      if (this.needsRebuild_) \{\par
        this.menu.textContent = '';\par
        this.dataItems_.forEach(this.addItem_, this);\par
        this.needsRebuild_ = false;\par
      \}\par
\par
      MenuButton.prototype.showMenu.call(this);\par
    \},\par
\par
    /**\par
     * Sets the menu model data.\par
     * @param \{Array\} dataItems Array of objects that describe the apps.\par
     */\par
    set dataItems(dataItems) \{\par
      this.dataItems_ = dataItems;\par
      this.needsRebuild_ = true;\par
      if (dataItems.length)\par
        this.classList.remove('invisible');\par
      else\par
        this.classList.add('invisible');\par
    \},\par
\par
    /**\par
     * Adds an app to the menu.\par
     * @param \{Object\} data An object encapsulating all data about the app.\par
     * @private\par
     */\par
    addItem_: function(data) \{\par
      var isWindow = data.type == 'window';\par
      var a = this.ownerDocument.createElement('a');\par
      a.className = 'recent-menu-item';\par
      if (isWindow) \{\par
        a.href = '';\par
        a.classList.add('recent-window');\par
        a.textContent = formatTabsText(data.tabs.length);\par
      \} else \{\par
        a.href = data.url;\par
        a.style.backgroundImage = 'url(chrome://favicon/' + data.url + ')';\par
        a.textContent = data.title;\par
      \}\par
\par
      function onClick(e) \{\par
        chrome.send('recordAppLaunchByURL',\par
                    [encodeURIComponent(data.url),\par
                     ntp4.APP_LAUNCH.NTP_RECENTLY_CLOSED]);\par
        var index = Array.prototype.indexOf.call(a.parentNode.children, a);\par
        chrome.send('reopenTab', [data.sessionId, index,\par
            e.button, e.altKey, e.ctrlKey, e.metaKey, e.shiftKey]);\par
        // We are likely deleted by this point!\par
\par
        e.preventDefault();\par
      \}\par
      a.addEventListener('click', onClick);\par
\par
      this.menu.appendChild(a);\par
      cr.ui.decorate(a, MenuItem);\par
    \},\par
  \};\par
\par
  return \{\par
    RecentMenuButton: RecentMenuButton,\par
  \};\par
\});\par
</script>\par
<style type="text/css">.dot \{ max-width: 80px; \}</style><style type="text/css"></style></head>\par
\par
<body>\par
  <button id="login-container" class="custom-appearance" hidden="">\par
    <div id="login-status-header-container" class="login-status-row">\par
      <div id="login-status-header"></div>\par
    </div>\par
    <div id="login-status-sub-header"></div>\par
  </button>\par
\par
  <div id="notification-container" class="inactive" hidden="">\par
    <div id="notification">\par
      <span></span>\par
      <div id="notificationLinks"></div>\par
      <button class="close-button custom-appearance">\par
      </button>\par
    </div>\par
  </div>\par
\par
  <div id="card-slider-frame">\par
    <button id="page-switcher-start" class="page-switcher custom-appearance" tabindex="2" style="width: 32.5px; left: 0px; top: 0px; padding-bottom: 0px; ">\'8b\f1\par
    </button>\par
    <div id="page-list" style="-webkit-transform: translate3d(-485px, 0px, 0px); "><div class="tile-page most-visited-page animating-tile-page" style="width: 485px; " tabindex="-1"><div class="tile-page-scrollbar" style="top: 0px; height: 0px; "></div><div class="tile-page-content"><div class="top-margin" style="margin-bottom: 0px; margin-top: 0px; "></div><div class="tile-grid" style="min-width: 259.25px; min-height: 3px; height: 491.8679245283019px; "><div class="tile real" style="left: 128.25px; right: 128.25px; top: 0px; "><a class="most-visited real focusable" tabindex="-1" title="Welcome to Google Chrome" style="width: 122px; height: 107.71698113207547px; left: -108.375px; right: -108.375px; top: 0px; " id="most-visited-tile-104" href="{{\field{\*\fldinst{HYPERLINK http://www.google.com/chrome/intl/en/welcome.html }}{\fldrslt{http://www.google.com/chrome/intl/en/welcome.html\ul0\cf0}}}}\f1\fs22 "><span class="thumbnail-wrapper fills-parent"><div class="close-button" title="Don't show on this page"></div><span class="thumbnail fills-parent" style="background-image: url(chrome://thumb/http://www.google.com/chrome/intl/en/welcome.html); "><div class="thumbnail-shield fills-parent"></div></span><span class="favicon" style="background-image: url(chrome://favicon/size/16/http://www.google.com/chrome/intl/en/welcome.html); "></span></span><div class="color-stripe" style="background-color: rgb(0, 147, 60); "></div><span class="title" dir="ltr">Welcome to Google Chrome</span></a></div><div class="tile real" style="left: 265.5px; right: 265.5px; top: 0px; "><a class="most-visited real focusable" tabindex="-1" title="Chrome Web Store" style="width: 122px; height: 107.71698113207547px; left: -108.375px; right: -108.375px; top: 0px; " id="most-visited-tile-105" href="{{\field{\*\fldinst{HYPERLINK https://chrome.google.com/webstore?hl=en }}{\fldrslt{https://chrome.google.com/webstore?hl=en\ul0\cf0}}}}\f1\fs22 "><span class="thumbnail-wrapper fills-parent"><div class="close-button" title="Don't show on this page"></div><span class="thumbnail fills-parent" style="background-image: url(chrome://thumb/https://chrome.google.com/webstore?hl=en); "><div class="thumbnail-shield fills-parent"></div></span><span class="favicon" style="background-image: url(chrome://favicon/size/16/https://chrome.google.com/webstore?hl=en); "></span></span><div class="color-stripe" style="background-color: rgb(63, 132, 197); "></div><span class="title" dir="ltr">Chrome Web Store</span></a></div><div class="tile real" style="left: 128.25px; right: 128.25px; top: 122.96698113207547px; "><a class="most-visited filler real" tabindex="-1" title="" style="width: 122px; height: 107.71698113207547px; left: -108.375px; right: -108.375px; top: 0px; "><span class="thumbnail-wrapper fills-parent"><div class="close-button" title="Don't show on this page"></div><span class="thumbnail fills-parent"><div class="thumbnail-shield fills-parent"></div></span><span class="favicon"></span></span><div class="color-stripe"></div><span class="title"></span></a></div><div class="tile real" style="left: 265.5px; right: 265.5px; top: 122.96698113207547px; "><a class="most-visited filler real" tabindex="-1" title="" style="width: 122px; height: 107.71698113207547px; left: -108.375px; right: -108.375px; top: 0px; "><span class="thumbnail-wrapper fills-parent"><div class="close-button" title="Don't show on this page"></div><span class="thumbnail fills-parent"><div class="thumbnail-shield fills-parent"></div></span><span class="favicon"></span></span><div class="color-stripe"></div><span class="title"></span></a></div><div class="tile real" style="left: 128.25px; right: 128.25px; top: 245.93396226415095px; "><a class="most-visited filler real" tabindex="-1" title="" style="width: 122px; height: 107.71698113207547px; left: -108.375px; right: -108.375px; top: 0px; "><span class="thumbnail-wrapper fills-parent"><div class="close-button" title="Don't show on this page"></div><span class="thumbnail fills-parent"><div class="thumbnail-shield fills-parent"></div></span><span class="favicon"></span></span><div class="color-stripe"></div><span class="title"></span></a></div><div class="tile real" style="left: 265.5px; right: 265.5px; top: 245.93396226415095px; "><a class="most-visited filler real" tabindex="-1" title="" style="width: 122px; height: 107.71698113207547px; left: -108.375px; right: -108.375px; top: 0px; "><span class="thumbnail-wrapper fills-parent"><div class="close-button" title="Don't show on this page"></div><span class="thumbnail fills-parent"><div class="thumbnail-shield fills-parent"></div></span><span class="favicon"></span></span><div class="color-stripe"></div><span class="title"></span></a></div><div class="tile real" style="left: 128.25px; right: 128.25px; top: 368.9009433962264px; "><a class="most-visited filler real" tabindex="-1" title="" style="width: 122px; height: 107.71698113207547px; left: -108.375px; right: -108.375px; top: 0px; "><span class="thumbnail-wrapper fills-parent"><div class="close-button" title="Don't show on this page"></div><span class="thumbnail fills-parent"><div class="thumbnail-shield fills-parent"></div></span><span class="favicon"></span></span><div class="color-stripe"></div><span class="title"></span></a></div><div class="tile real" style="left: 265.5px; right: 265.5px; top: 368.9009433962264px; "><a class="most-visited filler real" tabindex="-1" title="" style="width: 122px; height: 107.71698113207547px; left: -108.375px; right: -108.375px; top: 0px; "><span class="thumbnail-wrapper fills-parent"><div class="close-button" title="Don't show on this page"></div><span class="thumbnail fills-parent"><div class="thumbnail-shield fills-parent"></div></span><span class="favicon"></span></span><div class="color-stripe"></div><span class="title"></span></a></div></div></div></div><div class="tile-page apps-page selected-card animating-tile-page" style="width: 485px; " tabindex="1"><div class="tile-page-scrollbar" style="top: 0px; height: 0px; "></div><div class="tile-page-content"><div class="top-margin" style="margin-bottom: 4.603773584905667px; margin-top: -4.603773584905667px; "></div><div class="tile-grid" style="min-width: 260px; min-height: 3px; height: 180px; "><div class="tile real" style="left: 126px; right: 126px; top: 0px; "><div id="ahfgeienlihckogmohjhadlkjgocpleb" class="app focusable webstore" style="height: 80px; width: 80px; left: -106.5px; right: -106.5px; top: 0px; "><div id="" class="app-contents">\par
  <div class="app-img-container launch-click-target" title="Chrome Web Store" style="height: 64px; width: 64px; ">\par
    <img class="" src="chrome://extension-icon/ahfgeienlihckogmohjhadlkjgocpleb/128/0">\par
  <img class="apps-promo-logo"></div>\par
  <span class="title launch-click-target" title="Chrome Web Store">Chrome Web Store</span>\par
</div><div id="" class="apps-promo-extras">\par
  <h3 class="apps-promo-heading"></h3>\par
  <a class="apps-promo-link g-button-basic"></a>\par
</div></div></div><div class="tile real" style="left: 216px; right: 216px; top: 0px; "><div id="blpcfgokakmgnkcojhhkbfbldkacnbeo" class="app focusable" style="height: 80px; width: 80px; left: -106.5px; right: -106.5px; top: 0px; "><div id="" class="app-contents">\par
  <div class="app-img-container launch-click-target" title="YouTube" style="height: 64px; width: 64px; ">\par
    <img class="" src="chrome://extension-icon/blpcfgokakmgnkcojhhkbfbldkacnbeo/128/0">\par
  </div>\par
  <span class="title launch-click-target" title="YouTube">YouTube</span>\par
</div></div></div><div class="tile real" style="left: 306px; right: 306px; top: 0px; "><div id="coobgpohoikkiipiblmjeljniedjpjpf" class="app focusable" style="height: 80px; width: 80px; left: -106.5px; right: -106.5px; top: 0px; "><div id="" class="app-contents">\par
  <div class="app-img-container launch-click-target" title="Google Search" style="height: 64px; width: 64px; ">\par
    <img class="" src="chrome://extension-icon/coobgpohoikkiipiblmjeljniedjpjpf/128/0">\par
  </div>\par
  <span class="title launch-click-target" title="Google Search">Google Search</span>\par
</div></div></div><div class="tile real" style="left: 126px; right: 126px; top: 90px; "><div id="pjkljhegncpnkpknbcohdijeoejaedia" class="app focusable" style="height: 80px; width: 80px; left: -106.5px; right: -106.5px; top: 0px; "><div id="" class="app-contents">\par
  <div class="app-img-container launch-click-target" title="Gmail" style="height: 64px; width: 64px; ">\par
    <img class="" src="chrome://extension-icon/pjkljhegncpnkpknbcohdijeoejaedia/128/0">\par
  </div>\par
  <span class="title launch-click-target" title="Gmail">Gmail</span>\par
</div></div></div></div></div></div></div>\par
\f0     <button id="page-switcher-end" class="page-switcher custom-appearance" tabindex="2" style="width: 19.5px; right: 13px; top: 0px; padding-bottom: 0px; " hidden="">\'9b\f1\par
    </button>\par
    <div id="attribution" hidden="">\par
      <span i18n-content="attributionintro">Theme created by</span>\par
      <img id="attribution-img">\par
    </div>\par
  </div>\par
\par
  <div id="footer">\par
    <div id="footer-border"></div>\par
    <div id="footer-content">\par
      <img id="logo-img" src="chrome://theme/IDR_PRODUCT_LOGO?1455578975328">\par
\par
      <ul id="dot-list">\par
      <li class="dot" role="button" title="Most visited" tabindex="3"><div class="selection-bar"></div><input spellcheck="false" disabled=""></li><li class="dot selected" role="button" title="Apps"><div class="selection-bar"></div><input spellcheck="false" disabled=""></li></ul>\par
\par
      <button id="recently-closed-menu-button" class="custom-appearance" menu-shown="">\par
        <span i18n-content="recentlyclosed">Recently closed</span>\par
        <div class="disclosure-triangle"></div>\par
        <div id="vertical-separator"></div>\par
      </button>\par
\par
      <a id="chrome-web-store-href">\par
        <span id="chrome-web-store-title" i18n-content="webStoreTitle">Chrome Web Store</span>\par
      </a>\par
\par
      <div id="trash" class="trash">\par
        <span class="lid"></span>\par
        <span class="can"></span>\par
        <span class="trash-text" i18n-content="appuninstall">Remove from Chrome</span>\par
      </div>\par
    </div>\par
  </div>\par
\par
\par
<!-- A div to hold all the templates, and in the darkness bind them. -->\par
<div hidden="">\par
\par
<!-- NTP4 intro bubble -->\par
<div id="ntp4-intro-bubble-contents">\par
  <div i18n-content="ntp4_intro_message">undefined</div>\par
  <a i18n-content="learn_more" target="_blank">undefined</a>\par
</div>\par
\par
<!-- Login status bubble -->\par
<div id="login-status-bubble-contents">\par
  <div id="login-status-message-container">\par
    <span i18n-content="login_status_message">undefined</span>\par
    <a id="login-status-learn-more" i18n-content="login_status_learn_more" target="_blank">undefined</a>\par
  </div>\par
  <div class="login-status-row">\par
    <div id="login-status-advanced-container">\par
      <a id="login-status-advanced" i18n-content="login_status_advanced" href="#">undefined</a>\par
    </div>\par
    <button id="login-status-dismiss" i18n-content="login_status_dismiss">undefined</button>\par
  </div>\par
</div>\par
\par
<!-- Apps promo. -->\par
<div id="apps-promo-extras-template" class="apps-promo-extras">\par
  <h3 class="apps-promo-heading"></h3>\par
  <a class="apps-promo-link g-button-basic"></a>\par
</div>\par
\par
<!-- App Contents w/ Large Icon -->\par
<div id="app-large-icon-template" class="app-contents">\par
  <div class="app-img-container">\par
    <img class="invisible">\par
  </div>\par
  <span class="title"></span>\par
</div>\par
\par
<!-- App Contents w/ Small Icon -->\par
<div id="app-small-icon-template" class="app-contents">\par
  <div class="app-icon-div">\par
    <div class="app-img-container">\par
      <img class="invisible">\par
    </div>\par
    <div class="color-stripe"></div>\par
  </div>\par
  <span class="title"></span>\par
</div>\par
\par
</div>\par
\par
<!-- This is used to measure text in the current locale. It is not visible. -->\par
<div id="fontMeasuringDiv">Most visited</div>\par
\par
\par
<script>var templateData = \{"anim":"true","appDefaultPageName":"Apps","appcreateshortcut":"Create shortcut","appdisablenotifications":"Disable notifications","applaunchtypefullscreen":"Open full screen","applaunchtypepinned":"Open as pinned tab","applaunchtyperegular":"Open as regular tab","applaunchtypewindow":"Open as window","appoptions":"Options","apps_page_id":2048,"appuninstall":"Remove from Chrome","attributionintro":"Theme created by","bookmarkbarattached":"false","closedwindowmultiple":"$1 Tabs","closedwindowsingle":"1 Tab","customlogo":"false","fontfamily":"Arial, sans-serif","fontsize":"84%","hasattribution":"false","isWebStoreExperimentEnabled":false,"most_visited_page_id":1024,"mostvisited":"Most visited","recentlyclosed":"Recently closed","removethumbnailtooltip":"Don't show on this page","restoreThumbnailsShort":"Restore all","shown_page_index":0,"shown_page_type":2048,"syncLinkText":"Advanced settings","syncispresent":"true","syncpromotext":"Sign in to $1","textdirection":"ltr","themegravity":"","thumbnailremovednotification":"Thumbnail removed.","title":"New Tab","undothumbnailremove":"Undo","webStoreLink":"{{\field{\*\fldinst{HYPERLINK https://chrome.google.com/webstore?hl=en-US }}{\fldrslt{https://chrome.google.com/webstore?hl=en-US\ul0\cf0}}}}\f1\fs22 ","webStoreTitle":"Chrome Web Store"\};</script><script>// Copyright (c) 2010 The Chromium Authors. All rights reserved.\par
// Use of this source code is governed by a BSD-style license that can be\par
// found in the LICENSE file.\par
\par
/**\par
 * @fileoverview This is a simple template engine inspired by JsTemplates\par
 * optimized for i18n.\par
 *\par
 * It currently supports two handlers:\par
 *\par
 *   * i18n-content which sets the textContent of the element\par
 *\par
 *     <span i18n-content="myContent"></span>\par
 *     i18nTemplate.process(element, \{'myContent': 'Content'\});\par
 *\par
 *   * i18n-values is a list of attribute-value or property-value pairs.\par
 *     Properties are prefixed with a '.' and can contain nested properties.\par
 *\par
 *     <span i18n-values="title:myTitle;.style.fontSize:fontSize"></span>\par
 *     i18nTemplate.process(element, \{\par
 *       'myTitle': 'Title',\par
 *       'fontSize': '13px'\par
 *     \});\par
 */\par
\par
var i18nTemplate = (function() \{\par
  /**\par
   * This provides the handlers for the templating engine. The key is used as\par
   * the attribute name and the value is the function that gets called for every\par
   * single node that has this attribute.\par
   * @type \{Object\}\par
   */\par
  var handlers = \{\par
    /**\par
     * This handler sets the textContent of the element.\par
     */\par
    'i18n-content': function(element, attributeValue, obj) \{\par
      element.textContent = obj[attributeValue];\par
    \},\par
\par
    /**\par
     * This handler adds options to a select element.\par
     */\par
    'i18n-options': function(element, attributeValue, obj) \{\par
      var options = obj[attributeValue];\par
      options.forEach(function(values) \{\par
        var option = typeof values == 'string' ? new Option(values) :\par
            new Option(values[1], values[0]);\par
        element.appendChild(option);\par
      \});\par
    \},\par
\par
    /**\par
     * This is used to set HTML attributes and DOM properties,. The syntax is:\par
     *   attributename:key;\par
     *   .domProperty:key;\par
     *   .nested.dom.property:key\par
     */\par
    'i18n-values': function(element, attributeValue, obj) \{\par
      var parts = attributeValue.replace(/\\s/g, '').split(/;/);\par
      for (var j = 0; j < parts.length; j++) \{\par
        var a = parts[j].match(/^([^:]+):(.+)$/);\par
        if (a) \{\par
          var propName = a[1];\par
          var propExpr = a[2];\par
\par
          // Ignore missing properties\par
          if (propExpr in obj) \{\par
            var value = obj[propExpr];\par
            if (propName.charAt(0) == '.') \{\par
              var path = propName.slice(1).split('.');\par
              var object = element;\par
              while (object && path.length > 1) \{\par
                object = object[path.shift()];\par
              \}\par
              if (object) \{\par
                object[path] = value;\par
                // In case we set innerHTML (ignoring others) we need to\par
                // recursively check the content\par
                if (path == 'innerHTML') \{\par
                  process(element, obj);\par
                \}\par
              \}\par
            \} else \{\par
              element.setAttribute(propName, value);\par
            \}\par
          \} else \{\par
            console.warn('i18n-values: Missing value for "' + propExpr + '"');\par
          \}\par
        \}\par
      \}\par
    \}\par
  \};\par
\par
  var attributeNames = [];\par
  for (var key in handlers) \{\par
    attributeNames.push(key);\par
  \}\par
  var selector = '[' + attributeNames.join('],[') + ']';\par
\par
  /**\par
   * Processes a DOM tree with the \{@code obj\} map.\par
   */\par
  function process(node, obj) \{\par
    var elements = node.querySelectorAll(selector);\par
    for (var element, i = 0; element = elements[i]; i++) \{\par
      for (var j = 0; j < attributeNames.length; j++) \{\par
        var name = attributeNames[j];\par
        var att = element.getAttribute(name);\par
        if (att != null) \{\par
          handlers[name](element, att, obj);\par
        \}\par
      \}\par
    \}\par
  \}\par
\par
  return \{\par
    process: process\par
  \};\par
\})();\par
</script><script>// Copyright (c) 2010 The Chromium Authors. All rights reserved.\par
// Use of this source code is governed by a BSD-style license that can be\par
// found in the LICENSE file.\par
\par
// Invoke the template engine previously loaded from i18n_template.js\par
i18nTemplate.process(document, templateData);\par
</script><menu class="recent-menu" style="display: block; top: auto; left: auto; bottom: 49px; right: 0px; "><a class="recent-menu-item custom-appearance" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAkAAAAJCAYAAADgkQYQAAAAJUlEQVQYV2NgoDuYSQSGK/RB0+yDrACbQqwKkBUW41OArJB0AAACXws0ERupuAAAAABJRU5ErkJggg==" style="background-image: url(chrome://favicon/data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAkAAAAJCAYAAADgkQYQAAAAJUlEQVQYV2NgoDuYSQSGK/RB0+yDrACbQqwKkBUW41OArJB0AAACXws0ERupuAAAAABJRU5ErkJggg==); ">png (9\f0\'d79)</a><a class="recent-menu-item custom-appearance" href="chrome://theme/IDR_THEME_NTP_BACKGROUND?" style="background-image: url(chrome://favicon/chrome://theme/IDR_THEME_NTP_BACKGROUND?); ">IDR_THEME_NTP_BACKGROUND (42\'d742)</a><a class="recent-menu-item custom-appearance" href="chrome://theme/IDR_PRODUCT_LOGO?1455578975328" style="background-image: url(chrome://favicon/chrome://theme/IDR_PRODUCT_LOGO?1455578975328); ">IDR_PRODUCT_LOGO (171\'d732)</a><a class="recent-menu-item custom-appearance" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAQAAAC1+jfqAAAAiElEQVR42r2RsQrDMAxEBRdl8SDcX8lQPGg1GBI6lvz/h7QyRRXV0qUULwfvwZ1tenw5PxToRPWMC52eA9+WDnlh3HFQ/xBQl86NFYJqeGflkiogrOvVlIFhqURFVho3x1moGAa3deMs+LS30CAhBN5nNxeT5hbJ1zwmji2k+aF6NENIPf/hs54f0sZFUVAMigAAAABJRU5ErkJggg==" style="background-image: url(chrome://favicon/data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAQAAAC1+jfqAAAAiElEQVR42r2RsQrDMAxEBRdl8SDcX8lQPGg1GBI6lvz/h7QyRRXV0qUULwfvwZ1tenw5PxToRPWMC52eA9+WDnlh3HFQ/xBQl86NFYJqeGflkiogrOvVlIFhqURFVho3x1moGAa3deMs+LS30CAhBN5nNxeT5hbJ1zwmji2k+aF6NENIPf/hs54f0sZFUVAMigAAAABJRU5ErkJggg==); ">png (16\'d716)</a><a class="recent-menu-item custom-appearance" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAkAAAAJCAYAAADgkQYQAAAAJUlEQVQYV2NgoDuYSQSGK/RB0+yDrACbQqwKkBUW41OArJB0AAACXws0ERupuAAAAABJRU5ErkJggg==" style="background-image: url(chrome://favicon/data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAkAAAAJCAYAAADgkQYQAAAAJUlEQVQYV2NgoDuYSQSGK/RB0+yDrACbQqwKkBUW41OArJB0AAACXws0ERupuAAAAABJRU5ErkJggg==); ">png (9\'d79)</a><a class="recent-menu-item custom-appearance" href="chrome://theme/IDR_PRODUCT_LOGO?1455578975328" style="background-image: url(chrome://favicon/chrome://theme/IDR_PRODUCT_LOGO?1455578975328); ">IDR_PRODUCT_LOGO (171\'d732)</a><a class="recent-menu-item custom-appearance" href="chrome://extension-icon/blpcfgokakmgnkcojhhkbfbldkacnbeo/128/0" style="background-image: url(chrome://favicon/chrome://extension-icon/blpcfgokakmgnkcojhhkbfbldkacnbeo/128/0); ">0 (128\'d7128)</a><a class="recent-menu-item custom-appearance" href="chrome://theme/IDR_PRODUCT_LOGO?1455578975328" style="background-image: url(chrome://favicon/chrome://theme/IDR_PRODUCT_LOGO?1455578975328); ">IDR_PRODUCT_LOGO (171\'d732)</a><a class="recent-menu-item custom-appearance" href="{{\field{\*\fldinst{HYPERLINK https://www.google.co.th/?source=search_app&amp;gws_rd=cr,ssl&amp;ei=PV_CVr6ECtKUuATeqJngCA }}{\fldrslt{https://www.google.co.th/?source=search_app&amp;gws_rd=cr,ssl&amp;ei=PV_CVr6ECtKUuATeqJngCA\ul0\cf0}}}}\f0\fs22 " style="background-image: url(chrome://favicon/https://www.google.co.th/?source=search_app&amp;gws_rd=cr,ssl&amp;ei=PV_CVr6ECtKUuATeqJngCA); ">Google</a></menu></body></html>\par
<head>\par
<meta charset="utf-8">\par
<title i18n-content="title">New Tab</title>\par
<!-- Don't scale the viewport in either portrait or landscape mode.\par
     Note that this means apps will be reflowed when rotated (like iPad).\par
     If we wanted to maintain position we could remove 'maximum-scale' so\par
     that we'd zoom out in portrait mode, but then there would be a bunch\par
     of unusable space at the bottom.\par
-->\par
<meta name="viewport" content="user-scalable=no, width=device-width, maximum-scale=1.0">\par
\par
<!-- It's important that this be the first script loaded. -->\par
<script>// Copyright (c) 2011 The Chromium Authors. All rights reserved.\par
// Use of this source code is governed by a BSD-style license that can be\par
// found in the LICENSE file.\par
\par
/**\par
 * @fileOverview\par
 * Logging info for benchmarking purposes. Should be the first js file included.\par
 */\par
\par
/* Stack of events that has been logged. */\par
var eventLog = [];\par
\par
/**\par
 * Logs an event.\par
 * @param \{String\} name The name of the event (can be any string).\par
 * @param \{boolean\} shouldLogTime If true, the event is used for benchmarking\par
 *     and the time is logged. Otherwise, just push the event on the event\par
 *     stack.\par
 */\par
function logEvent(name, shouldLogTime) \{\par
  if (shouldLogTime)\par
    chrome.send('metricsHandler:logEventTime', [name]);\par
  eventLog.push([name, Date.now()]);\par
\}\par
\par
logEvent('Tab.NewTabScriptStart', true);\par
window.addEventListener('load', function(e) \{\par
  logEvent('Tab.NewTabOnload', true);\par
\});\par
document.addEventListener('DOMContentLoaded', function(e) \{\par
  logEvent('Tab.NewTabDOMContentLoaded', true);\par
\});\par
</script>\par
\par
<style>/* Copyright (c) 2012 The Chromium Authors. All rights reserved.\par
 * Use of this source code is governed by a BSD-style license that can be\par
 * found in the LICENSE file.\par
 */\par
\par
button:not(.custom-appearance),\par
input[type='button']:not(.custom-appearance),\par
input[type='submit']:not(.custom-appearance) \{\par
  -webkit-border-radius: 3px;\par
  -webkit-box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);\par
  -webkit-user-select: none;\par
  background: -webkit-linear-gradient(#fafafa, #f4f4f4 40%, #e5e5e5);\par
  border: 1px solid #aaa;\par
  color: #444;\par
  font-size: inherit;\par
  margin-bottom: 0;\par
  min-width: 4em;\par
  padding: 3px 12px;\par
\}\par
\par
button:not(.custom-appearance):hover,\par
input[type='button']:not(.custom-appearance):hover,\par
input[type='submit']:not(.custom-appearance):hover \{\par
  -webkit-box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2);\par
  background: #ebebeb -webkit-linear-gradient(#fefefe, #f8f8f8 40%, #e9e9e9);\par
  border-color: #999;\par
  color: #222;\par
\}\par
\par
button:not(.custom-appearance):active,\par
input[type='button']:not(.custom-appearance):active,\par
input[type='submit']:not(.custom-appearance):active \{\par
  -webkit-box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.2);\par
  background: #ebebeb -webkit-linear-gradient(#f4f4f4, #efefef 40%, #dcdcdc);\par
  color: #333;\par
\}\par
\par
button[disabled]:not(.custom-appearance),\par
input[type='button'][disabled]:not(.custom-appearance),\par
input[type='submit'][disabled]:not(.custom-appearance),\par
button[disabled]:not(.custom-appearance):hover,\par
input[type='button'][disabled]:not(.custom-appearance):hover,\par
input[type='submit'][disabled]:not(.custom-appearance):hover \{\par
  -webkit-box-shadow: none;\par
  background: -webkit-linear-gradient(#fafafa, #f4f4f4 40%, #e5e5e5);\par
  border-color: #aaa;\par
  color: #888;\par
\}\par
\par
button:not(.custom-appearance):focus,\par
input[type='submit']:not(.custom-appearance):focus,\par
input[type='text']:not(.custom-appearance):focus,\par
select:not(.custom-appearance):focus \{\par
  -webkit-box-shadow: inset 0 1px 2px white,\par
      0 1px 2px rgba(0, 0, 0, .2),\par
      0 0 1px #c0c0c0,\par
      0 0 1px #c0c0c0,\par
      0 0 1px #c0c0c0;\par
  -webkit-transition: border-color 200ms;\par
  /* We use border color because it follows the border radius (unlike outline).\par
   * This is particularly noticeable on mac. */\par
  border-color: rgb(64, 128, 250);\par
  outline: none;\par
\}\par
\par
/* Search boxes use an outline because it follows the contours of the box. */\par
input[type='search']:not(.custom-appearance):focus \{\par
  outline-color: rgb(64, 128, 250);\par
\}\par
\par
/* TODO(jhawkins): Refactor button styling and remove !important here. This is\par
 * currently necessary because individual page button element selectors have\par
 * higher specificity.\par
 */\par
.link-button,\par
.link-button:focus \{\par
  -webkit-box-shadow: none !important;\par
  background: transparent none !important;\par
  border: none !important;\par
  color: rgb(17, 85, 204) !important;\par
  cursor: pointer;\par
  /* Input elements have -webkit-small-control which overrides the body font.\par
   * Resolve this by using 'inherit'. */\par
  font-family: inherit;\par
  margin: 0;\par
  padding: 0 4px !important;\par
\}\par
\par
.link-button:hover \{\par
  text-decoration: underline;\par
\}\par
\par
.link-button:active \{\par
  color: rgb(5, 37, 119) !important;\par
  text-decoration: underline;\par
\}\par
</style>\par
<style>/* Copyright (c) 2012 The Chromium Authors. All rights reserved.\par
 * Use of this source code is governed by a BSD-style license that can be\par
 * found in the LICENSE file.\par
 */\par
\par
.bubble \{\par
  position: absolute;\par
  /* Height is dynamic, width fixed. */\par
  width: 300px;\par
  z-index: 9999;\par
\}\par
\par
.bubble-contents \{\par
  color: black;\par
  left: 1px;\par
  line-height: 150%;\par
  padding: 8px 11px 12px;\par
  position: relative;\par
  right: 1px;\par
  top: 1px;\par
  width: 298px;\par
  z-index: 3;\par
\}\par
\par
.bubble-close \{\par
  background-image: no-repeat 50% 50%;  \par
  height: 16px;\par
  position: absolute;\par
  right: 6px;\par
  top: 6px;\par
  width: 16px;\par
  z-index: 4;\par
\}\par
\par
html[dir='rtl'] .bubble-close \{\par
  left: 6px;\par
  right: auto;\par
\}\par
\par
.bubble-close \{\par
  background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAQAAAC1+jfqAAAAiElEQVR42r2RsQrDMAxEBRdl8SDcX8lQPGg1GBI6lvz/h7QyRRXV0qUULwfvwZ1tenw5PxToRPWMC52eA9+WDnlh3HFQ/xBQl86NFYJqeGflkiogrOvVlIFhqURFVho3x1moGAa3deMs+LS30CAhBN5nNxeT5hbJ1zwmji2k+aF6NENIPf/hs54f0sZFUVAMigAAAABJRU5ErkJggg==");\par
\}\par
\par
.bubble-close:hover \{\par
  background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAQAAAC1+jfqAAAAqklEQVR4XqWRMQ6DMAxF/1Fyilyj2SmIBUG5QcTCyJA5Z8jGhlBPgRi4TmoDraVmKFJlWYrlp/g5QfwRlwEVNWVa4WzfH9jK6kCkEkBjwxOhLghheMWMELUAqqwQ4OCbnE4LJnhr5IYdqQt4DJQjhe9u4vBBmnxHHNzRFkDGjHDo0VuTAqy2vAG4NkvXXDHxbGsIGlj3e835VFNtdugma/Jk0eXq0lP//5svi4PtO01oFfYAAAAASUVORK5CYII=");\par
\}\par
\par
.bubble-close:active \{\par
  background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAQAAAC1+jfqAAAARElEQVQoz2P4z4AfMlBLAYMdwxkghgEwD1XBGTC0g0sDIaYJECVwFqoChBK4WegKkJWArSJZAQErCDqSKG/iCyhaRhYA9LDIbULDzlIAAAAASUVORK5CYII=");\par
\}\par
\par
.bubble-shadow \{\par
  bottom: -2px;\par
  left: 0;\par
  position: absolute;\par
  right: 0;\par
  top: 0;\par
  z-index: 1;\par
\}\par
\par
.bubble-arrow \{\par
  /* The tip of the arrow.  */\par
  border-bottom-right-radius: 1px;\par
  /* No border on the right or top (inner sides of the rotated square) because\par
   * it would overlap/darken the content shadow. */\par
  border-right: none;\par
  border-top: none;\par
  bottom: -9px;\par
  height: 15px;\par
  left: 22px;\par
  position: absolute;\par
  right: 22px;\par
  width: 15px;\par
  z-index: 2;\par
  -webkit-transform: rotate(45deg);\par
\}\par
\par
.bubble-contents,\par
.bubble-arrow \{\par
  background: white;\par
\}\par
\par
.bubble-arrow[is-right='true'] \{\par
  left: auto;\par
\}\par
\par
.bubble-arrow[is-right='false'] \{\par
  right: auto;\par
\}\par
\par
.bubble-arrow[is-top='true'] \{\par
  bottom: auto;\par
  top: -8px;\par
\}\par
\par
.bubble-shadow,\par
.bubble-arrow \{\par
  border: 1px solid rgba(0, 0, 0, 0.3);\par
  -webkit-box-shadow: 0 2px 6px rgba(0, 0, 0, 0.15);\par
\}\par
\par
.bubble-shadow,\par
.bubble-contents \{\par
  border-radius: 6px;\par
  box-sizing: border-box;\par
\}\par
</style>\par
<style>/* Copyright (c) 2012 The Chromium Authors. All rights reserved.\par
 * Use of this source code is governed by a BSD-style license that can be\par
 * found in the LICENSE file.\par
 */\par
\par
.expandable-bubble \{\par
  -webkit-border-image: url('chrome://theme/IDR_APP_NOTIFICATION_SMALL_BUBBLE')\par
                        5 5 7 6 stretch;\par
  -webkit-box-sizing: border-box;\par
  -webkit-user-select: none;\par
  border-width: 5px 5px 7px 6px;\par
  color: #444;\par
  cursor: pointer;\par
  display: inline-block;\par
  font-size: 12px;\par
  position: absolute;\par
  z-index: 1;\par
\}\par
\par
.expandable-bubble::after \{\par
  bottom: -1px;\par
  content: url('chrome://theme/IDR_APP_NOTIFICATION_NUB');\par
  display: block;\par
  height: 7px;\par
  position: absolute;\par
  right: 5px;  /* TODO(finnur): Need to handle RTL properly. */\par
  width: 9px;\par
\}\par
\par
.expandable-bubble > .expandable-bubble-contents > .expandable-bubble-title \{\par
  display: inline-block;\par
  margin-left: 1px;\par
  margin-top : -3px;\par
  overflow: hidden;\par
  white-space: nowrap;\par
\}\par
\par
.expandable-bubble[masked] > .expandable-bubble-contents >\par
    .expandable-bubble-title::after \{\par
  content: url('chrome://theme/IDR_APP_NOTIFICATION_NUB_MASK');\par
  display: block;\par
  height: 15px;\par
  overflow: hidden;\par
  position: absolute;\par
  right: 0;\par
  top: 0;\par
  width: 12px;\par
\}\par
\par
.expandable-bubble[expanded] > .expandable-bubble-contents >\par
    .expandable-bubble-title \{\par
  font-size: 13px;\par
  margin-left: 0;\par
  margin-bottom: 3px;\par
\}\par
\par
.expandable-bubble-close \{\par
  background-image: no-repeat 50% 50%;\par
  height: 16px;\par
  position: absolute;\par
  right: 0;\par
  top: 0;\par
  width: 16px;\par
  z-index: 2;\par
\}\par
\par
.expandable-bubble[expanded] \{\par
  padding: 3px;\par
  z-index: 3;  /* One higher then the close button on an unexpanded bubble. */\par
\}\par
\par
.expandable-bubble[expanded] > .expandable-bubble-close \{\par
  z-index: 4;\par
\}\par
\par
.expandable-bubble-close \{\par
  background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAQAAAC1+jfqAAAAiElEQVR42r2RsQrDMAxEBRdl8SDcX8lQPGg1GBI6lvz/h7QyRRXV0qUULwfvwZ1tenw5PxToRPWMC52eA9+WDnlh3HFQ/xBQl86NFYJqeGflkiogrOvVlIFhqURFVho3x1moGAa3deMs+LS30CAhBN5nNxeT5hbJ1zwmji2k+aF6NENIPf/hs54f0sZFUVAMigAAAABJRU5ErkJggg==");\par
\}\par
\par
.expandable-bubble-close:hover \{\par
  background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAQAAAC1+jfqAAAAqklEQVR4XqWRMQ6DMAxF/1Fyilyj2SmIBUG5QcTCyJA5Z8jGhlBPgRi4TmoDraVmKFJlWYrlp/g5QfwRlwEVNWVa4WzfH9jK6kCkEkBjwxOhLghheMWMELUAqqwQ4OCbnE4LJnhr5IYdqQt4DJQjhe9u4vBBmnxHHNzRFkDGjHDo0VuTAqy2vAG4NkvXXDHxbGsIGlj3e835VFNtdugma/Jk0eXq0lP//5svi4PtO01oFfYAAAAASUVORK5CYII=");\par
\}\par
\par
.expandable-bubble-close:active \{\par
  background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAQAAAC1+jfqAAAARElEQVQoz2P4z4AfMlBLAYMdwxkghgEwD1XBGTC0g0sDIaYJECVwFqoChBK4WegKkJWArSJZAQErCDqSKG/iCyhaRhYA9LDIbULDzlIAAAAASUVORK5CYII=");\par
\}\par
</style>\par
<style>/* Copyright (c) 2012 The Chromium Authors. All rights reserved.\par
 * Use of this source code is governed by a BSD-style license that can be\par
 * found in the LICENSE file.\par
 */\par
\par
menu \{\par
  -webkit-box-shadow: 0 2px 4px rgba(0, 0, 0, .50);\par
  background: white;\par
  color: black;\par
  cursor: default;\par
  display: none;\par
  left: 0;\par
  margin: 0;\par
  outline: 1px solid rgba(0, 0, 0, 0.2);\par
  padding: 8px 0;\par
  position: fixed;\par
  white-space: nowrap;\par
  z-index: 3;\par
\}\par
\par
menu > * \{\par
  box-sizing: border-box;\par
  display: block;\par
  margin: 0;\par
  width: 100%;\par
  text-align: start;\par
\}\par
\par
menu > :not(hr) \{\par
  -webkit-appearance: none;\par
  background: transparent;\par
  border: 0;\par
  font: inherit;\par
  line-height: 18px;\par
  overflow: hidden;\par
  padding: 0 19px;\par
  text-overflow: ellipsis;\par
\}\par
\par
menu > hr \{\par
  background: -webkit-linear-gradient(left,\par
                                      rgba(0, 0, 0, .10),\par
                                      rgba(0, 0, 0, .02) 96%);\par
  border: 0;\par
  height: 1px;\par
  margin: 8px 0;\par
\}\par
\par
menu > [disabled] \{\par
  color: rgba(0, 0, 0, .3);\par
\}\par
\par
/* Text alpha doesn't work on Linux/GTK and ChromeOs/views.\par
 * TODO(estade): {{\field{\*\fldinst{HYPERLINK http://crbug.com/88688 }}{\fldrslt{http://crbug.com/88688\ul0\cf0}}}}\f0\fs22 . */\par
html[toolkit=gtk] menu > [disabled],\par
html[os=chromeos] menu > [disabled] \{\par
  color: #969696;\par
\}\par
\par
menu > [hidden] \{\par
  display: none;\par
\}\par
\par
menu > :not(hr)[selected] \{\par
  background-color: #dce5fa;\par
\}\par
\par
menu > :not(hr)[selected]:active \{\par
  background-color: #426dc9;\par
  color: #fff;\par
\}\par
\par
menu > [checked]:before \{\par
  content: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAkAAAAJCAYAAADgkQYQAAAARklEQVQYlWNgwA+MgViQkIJ3QKzEAFVpjEPBf5giJaiAMRYF72DWKSEJlKMpgNsgiCTxH5sCbG7AqgBZ4V2sCv7//08QAwAUfjKKBs+BFgAAAABJRU5ErkJggg==");\par
  display: inline-block;\par
  height: 9px;\par
  margin: 0 5px;\par
  vertical-align: 50%;\par
  width: 9px;\par
\}\par
\par
menu > [checked] \{\par
  -webkit-padding-start: 0;\par
\}\par
\par
menu > [selected][checked]:active:before \{\par
  content: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAkAAAAJCAYAAADgkQYQAAAATElEQVR42oXNyw0AIAgDUFdwBVZgOKd1BVeokNhgiJ9DL+WRFgCvqKX+wLBIcenFBYBIVqEHMDgnW9ECxCPneEAGRDGRQEaEnSCjbyYFHgnBSWvSHgAAAABJRU5ErkJggg==");\par
\}\par
</style>\par
<style>/* Copyright (c) 2012 The Chromium Authors. All rights reserved.\par
 * Use of this source code is governed by a BSD-style license that can be\par
 * found in the LICENSE file.\par
 */\par
\par
.trash \{\par
  cursor: pointer;\par
  display: inline-block;\par
  outline: none;\par
  position: relative;\par
  width: 30px;\par
\}\par
\par
.trash > span \{\par
  display: inline-block;\par
\}\par
\par
.trash > .can,\par
.trash > .lid \{\par
  background: url('chrome://resources/images/trash.png') 0 0 no-repeat;\par
  left: 8px;\par
  position: absolute;\par
  right: 8px;\par
  top: 2px;\par
\}\par
\par
.trash > .lid \{\par
  -webkit-transition: -webkit-transform 150ms;\par
  -webkit-transform-origin: -7% 100%;\par
  height: 6px;\par
  width: 14px;\par
\}\par
\par
html[dir='rtl'] .trash > .lid \{\par
  -webkit-transform-origin: 107% 100%;\par
\}\par
\par
.trash:focus > .lid,\par
.trash:hover > .lid \{\par
  -webkit-transition: -webkit-transform 250ms;\par
  -webkit-transform: rotate(-45deg);\par
\}\par
\par
html[dir='rtl'] .trash:focus > .lid,\par
html[dir='rtl'] .trash:hover > .lid \{\par
  -webkit-transform: rotate(45deg);\par
\}\par
\par
.trash > .can \{\par
  background-position: -1px -4px;\par
  height: 12px;\par
  /* The margins match the background position offsets. */\par
  margin-left: 1px;\par
  /* The right margin is one greater due to a shadow on the trash image. */\par
  margin-right: 2px;\par
  margin-top: 4px;\par
  width: 11px;\par
\}\par
</style>\par
<style>/* Copyright (c) 2012 The Chromium Authors. All rights reserved.\par
 * Use of this source code is governed by a BSD-style license that can be\par
 * found in the LICENSE file. */\par
\par
.app \{\par
  outline: none;\par
  position: absolute;\par
  text-align: center;\par
\}\par
\par
.app-contents \{\par
  -webkit-transition: -webkit-transform 100ms;\par
\}\par
\par
.app-contents:active:not(.suppress-active),\par
.app:not(.click-focus):focus .app-contents:not(.suppress-active),\par
.drag-representation:not(.placing) .app-contents \{\par
  -webkit-transform: scale(1.1);\par
\}\par
\par
/* Don't animate the initial scaling.  */\par
.app-contents:active:not(.suppress-active),\par
/* Active gets applied right before .suppress-active, so to avoid flicker\par
 * we need to make the scale go back to normal without an animation. */\par
.app-contents.suppress-active \{\par
  -webkit-transition-duration: 0;\par
\}\par
\par
.app-contents > span \{\par
  display: block;\par
  overflow: hidden;\par
  text-decoration: none;\par
  text-overflow: ellipsis;\par
  white-space: nowrap;\par
\}\par
\par
.app-img-container \{\par
  margin-left: auto;\par
  margin-right: auto;\par
  /* -webkit-mask-image set by JavaScript to the image source */\par
  -webkit-mask-size: 100% 100%;\par
\}\par
\par
.app-img-container > * \{\par
  height: 100%;\par
  width: 100%;\par
\}\par
\par
.app-icon-div \{\par
  background-color: white;\par
  border: 1px solid #d5d5d5;\par
  border-radius: 5px;\par
  display: -webkit-box;\par
  margin-left: auto;\par
  margin-right: auto;\par
  position: relative;\par
  vertical-align: middle;\par
  z-index: 0;\par
  -webkit-box-align: center;\par
  -webkit-box-pack: center;\par
\}\par
\par
.app-icon-div .app-img-container \{\par
  bottom: 10px;\par
  left: 10px;\par
  position: absolute;\par
\}\par
\par
.app-icon-div .color-stripe \{\par
  border-bottom-left-radius: 5px 5px;\par
  border-bottom-right-radius: 5px 5px;\par
  bottom: 0;\par
  height: 3px;\par
  opacity: 1.0;\par
  position: absolute;\par
  width: 100%;\par
  z-index: 100;\par
\}\par
\par
.app-context-menu > button:first-child \{\par
  font-weight: bold;\par
\}\par
\par
.app-context-menu \{\par
  z-index: 1000;\par
\}\par
\par
.launch-click-target \{\par
  cursor: pointer;\par
\}\par
\par
/* Notifications */\par
\par
.app-notification \{\par
  color: #999999;  \par
  display: block;\par
  font-size: 11px;\par
  white-space: nowrap;\par
  -webkit-transition: color 150ms linear;\par
\}\par
\par
.app-notification:hover \{\par
  text-decoration: underline;\par
\}\par
\par
/* Promo */\par
/* Show the promo if the webstore has a promo and is the only app on the page.\par
 */\par
.tile:only-of-type > .has-promo > .app-contents > span \{\par
  display: none;\par
\}\par
\par
.tile:only-of-type > .has-promo .app-img-container > .apps-promo-logo \{\par
  display: block;\par
\}\par
\par
.apps-promo-logo \{\par
  display: none;\par
  height: 128px;\par
  width: 128px;\par
\}\par
\par
.tile:only-of-type > .has-promo .app-img-container > img:first-child \{\par
  display: none;\par
\}\par
\par
.app-img-container > img:first-child \{\par
  display: block;\par
\}\par
\par
/* TODO(estade): animation? */\par
.tile:only-of-type > .has-promo > .apps-promo-extras \{\par
  display: block;\par
\}\par
\par
.apps-promo-extras \{\par
  display: none;\par
  /* 128 * 5/4 */\par
  left: 160px;\par
  position: absolute;\par
  text-align: left;\par
  top: 0;\par
\}\par
\par
html[dir="rtl"] .apps-promo-extras \{\par
  left: auto;\par
  right: 160px;\par
\}\par
\par
.apps-promo-heading \{\par
  font-weight: bold;\par
  margin-bottom: 5px;\par
  -webkit-margin-start: 3px;\par
\}\par
\par
.g-button-basic \{\par
  border-width: 6px 10px 12px 6px;\par
  color: #fff !important;\par
  display: inline-block;\par
  font-size: 1.3em;\par
  font-weight: bold;\par
  padding: 2px 10px;\par
  text-align: center;\par
  text-decoration: none;\par
  white-space: nowrap;\par
  -webkit-border-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAD4AAABHCAYAAABf7PRNAAAEzUlEQVR4Xu2YP4gkRRTGf9Xdszu79088BMVEAw+8UBMREzURQ3MDMRQEQ8FE0Fi4TDQ4wcRAMLtLTA4EUzVYFUUP1vPk7tyb3fnX3VXf0x0ezcDC9qQ1Ox981LzhVfDr1/2oesHMALj2zc/2+Y09/r4/IcnIX/yF2ReqR5+Obr67DxiAryzAr779tT1/5SovPPcE54ZD2hSIMixD/nkLR3Nj/96En379g99+/4X2cP+Zw2/fvw3IwVV9+OWPC+hXX3yaqggOYEiGhUBuMhl1I+q0zZOXH6E+epQ/2+k7wAdABBJAdf3mHm+98TqTuTg3LDr4oiiQRG5KEoczMT28x2x0l0uDSCiHbwIfAzXQAFaNJg3TxuAo0STYGQRmrTGrRY4aTcX9gynTgzvMxw8g1hDCZeCcpwhQBTCepf/N4gHsboXjdfFfm8hOR3MxHd2lnvxLamYYhus8kIAIxApgOo8MBpU/gEXMtCFLxWZKnI9JscEssaQdYAZUQFEBC8hdIlDhMZLIUUoJSZgSkrGkITAAyg68shrYBqBt4yKuVZKjTGJhMzAHJwBUOPSxC8/3RAHGmqpwd08BmZFixIIoTABgIk8JMMwM6xhKltWBm9F9F4HQvQEZyoEN3Es6CQ54IhAMWcge3N0PTggQus25g/f2qsqzceo1AHceoxf8JKR/H9mSr/qqd0ldYxMY+YLj7gPHhFQQQuGh5cvN6s0NKUEoSGlpu/JEXz610Q9uhEKkZLjIuORgvtgqzc0MJYFvMCnvikuATgd3EXzUJBOG5f2N91f8pEwp+67u6+ngwYQkCCUAIesDjNz9XR3MkARW4DGW+QEGVunqXnVTwmPIGtxXOB08GQwwLCU8PiO3MzMIYXn32biPB8nHb+Bxxic3W2pu6qm4EljArMDjjL9xrd7cTAkTmEq6mJDvqw6rTmAEhlfcYwXylEDC1Qce3C5C7ncUzOip+EllP2XtJjB9FZeEFJCJACj/ru7uv48j+QaP12quHvpfdZIAyBy8W1cHlzzI/pJC/8ktCQoZMlwh74qz4pE1CkoZ0np09e7IivrO6hEoSKoIAIpgyv/ISk/FSyKEEsl8b5v1XB1stQNMsAQGKAGgmDCFbKesyMAE0N/cQjSK0AIgy3uubu6eintSMkIV85+rm47tEPSA+wRmWcZZGD11WoJf+ylrj9Z3rr5+5O7TO3TBWdMGPFdtwDfgG/AN+AZ8A74BrwBSEkWAVAYAlIRJ6w9e1y11A/O6QIIYa0yJHJWaCbGdIyVMfVPW+ggpUi+SW5SabK+lqZ0tbClinA7e1NODLYs1SsduMUvgw4nspISZcGGhAEvzk+BK303a+ctVM8IUfdP6qB3soPloD7AlU6kdf3Y4uPjyhfohpRLrpFRuMd55nPb2rRtABBIOH4DdS69de6/cvvhRmWaUqVkb6FTu0Pzzw/Xx9598BRwAD4ARMAnAENipLl95bPupV14Kw0vPkpptUxxgKoGQJfjh/p3m9q09zQ9GwNiBHwJHwCwAW8A2sAtcAM777yEwAEKG8OZugTkwdeCx/64rQHiCAyag9gdSAkWm4HKWxtlmvrZAqpYTfEP0hAoo3GQEb77KHR22waEBqwDDg6XE0h0yf9WdbdkIsP8ABZhTTDj3evgAAAAASUVORK5CYII=") 6 10 12 6;\par
\}\par
\par
.app .invisible \{\par
  visibility: hidden;\par
\}\par
</style>\par
<style>/* Copyright (c) 2012 The Chromium Authors. All rights reserved.\par
 * Use of this source code is governed by a BSD-style license that can be\par
 * found in the LICENSE file.\par
 */\par
\par
.most-visited \{\par
  position: absolute;\par
  z-index: 0;\par
\}\par
\par
.most-visited \{\par
  display: -webkit-box;\par
  position: absolute;\par
  text-decoration: none;\par
  -webkit-box-orient: vertical;\par
\}\par
\par
.most-visited:focus \{\par
  outline: none;\par
\}\par
\par
.fills-parent \{\par
  bottom: 0;\par
  display: -webkit-box;\par
  left: 0;\par
  position: absolute;\par
  right: 0;\par
  top: 0;\par
\}\par
\par
/* filler mode: hide everything except the thumbnail --- leave a grey rectangle\par
 * in its place. */\par
.filler * \{\par
  visibility: hidden;\par
\}\par
\par
.filler \{\par
  pointer-events: none;\par
\}\par
\par
.most-visited .close-button \{\par
  opacity: 0;\par
  position: absolute;\par
  right: 0;\par
  top: 0;\par
  z-index: 5;\par
  -webkit-transition: opacity 150ms;\par
\}\par
\par
html[dir=rtl] .most-visited .close-button \{\par
  left: 0;\par
  right: auto;\par
\}\par
\par
.most-visited:hover .close-button \{\par
  opacity: 1;\par
  -webkit-transition-delay: 500ms;\par
\}\par
\par
.most-visited .close-button:hover \{\par
  -webkit-transition: none;\par
\}\par
\par
.most-visited .favicon \{\par
  -webkit-margin-start: 5px;\par
  background: no-repeat left 50%;\par
  bottom: 7px;\par
  box-sizing: border-box;\par
  display: block;\par
  height: 16px;\par
  position: absolute;\par
  width: 16px;\par
\}\par
\par
html[dir='rtl'] .most-visited .favicon \{\par
  background-position-x: right;\par
\}\par
\par
.most-visited .color-stripe \{\par
  border-bottom-left-radius: 3px 3px;\par
  border-bottom-right-radius: 3px 3px;\par
  /* Matches height of title.  */\par
  bottom: 23px;\par
  height: 3px;\par
  /* Matches padding-top of the title. */\par
  margin-bottom: 8px;\par
  position: absolute;\par
  width: 100%;\par
  z-index: 10;\par
\}\par
\par
.most-visited .title \{\par
  display: block;\par
  height: 23px;\par
  overflow: hidden;\par
  padding-top: 8px;\par
  text-align: center;\par
  text-overflow: ellipsis;\par
  white-space: nowrap;\par
\}\par
\par
.thumbnail \{\par
  background: no-repeat;\par
  /* This shows for missing thumbnails. */\par
  background-color: #eee;\par
  background-size: 100%;\par
  border-radius: 3px;\par
  /* These max dimensions are not necessary, as the sizing logic in the .js\par
   * should be sufficient, but they're here for extra insurance. We never want\par
   * to scale a thumbnail larger than this size. */\par
  max-height: 132px;\par
  max-width: 212px;\par
  -webkit-transition: opacity 150ms;\par
\}\par
\par
.filler .thumbnail \{\par
  /* TODO(estade): there seems to be a webkit bug where this border is not\par
   * always removed when it should be. Investigate. */\par
  border: 1px solid;\par
  visibility: visible;\par
\}\par
\par
.thumbnail-shield \{\par
  border-radius: 3px;\par
  background: -webkit-linear-gradient(rgba(255, 255, 255, 0),\par
                                      rgba(255, 255, 255, 0) 50%,\par
                                      rgba(255, 255, 255, 0.9));\par
\}\par
\par
/* TODO(dbeam): Remove this when printing of -webkit-linear-gradient() works. */\par
@media print \{\par
  .thumbnail-shield \{\par
    background: none;\par
  \}\par
\}\par
\par
.most-visited:focus .thumbnail,\par
.most-visited:hover .thumbnail \{\par
  opacity: 0.95;\par
\}\par
\par
.most-visited:focus .thumbnail-shield,\par
.most-visited:hover .thumbnail-shield,\par
.most-visited:active .thumbnail-shield \{\par
  background: -webkit-linear-gradient(rgba(255, 255, 255, 0),\par
                                      rgba(255, 255, 255, 0) 80%,\par
                                      rgba(255, 255, 255, 0.9));\par
\}\par
\par
/* The thumbnail gets lighter when clicked, but not when the click is on the\par
 * close button. */\par
.most-visited:active .close-button:not(:active) + .thumbnail \{\par
  opacity: 0.9;\par
\}\par
\par
/* The thumbnail gets a shadow when clicked, but not when the click is on the\par
 * close button. */\par
.most-visited:active .close-button:not(:active) + .thumbnail .thumbnail-shield \{\par
  -webkit-box-shadow: inset 0 1px 10px rgba(0, 0, 0, 0.2);\par
\}\par
\par
.thumbnail-wrapper \{\par
  border: 1px solid transparent;\par
  border-radius: 3px;\par
  display: block;\par
  position: relative;\par
  z-index: 5;\par
  -webkit-box-flex: 1;\par
  -webkit-transition: background-color 150ms;\par
\}\par
\par
.filler .thumbnail-wrapper \{\par
  visibility: visible;\par
\}\par
\par
/* 'finishing-drag' is the state we are in after dropping on the trash can.\par
 * Override opacity of the tile to 1, so that the new tile animation\par
 * occurs simultaneously with the trash animation. */\par
.tile.dragging.finishing-drag \{\par
  opacity: 1;\par
\}\par
\par
/* Don't display the new tile until there's something to show.  */\par
.blacklisted \{\par
  opacity: 0;\par
\}\par
</style>\par
<style>/* Copyright (c) 2012 The Chromium Authors. All rights reserved.\par
 * Use of this source code is governed by a BSD-style license that can be\par
 * found in the LICENSE file.\par
 */\par
\par
/* TODO(estade): handle overflow better? I tried overflow-x: hidden and\par
   overflow-y: visible (for the new dot animation), but this makes a scroll\par
   bar appear */\par
#dot-list \{\par
  display: -webkit-box;\par
  height: 100%;\par
  list-style-type: none;\par
  margin: 0;\par
  padding: 0;\par
  /* Expand to take up all available horizontal space.  */\par
  -webkit-box-flex: 1;\par
  /* Center child dots. */\par
  -webkit-box-pack: center;\par
\}\par
\par
html.starting-up #dot-list \{\par
  display: none;\par
\}\par
\par
.dot \{\par
  box-sizing: border-box;\par
  cursor: pointer;\par
  /* max-width: Set in new_tab.js. See measureNavDots() */\par
  outline: none;\par
  text-align: left;\par
  -webkit-box-flex: 1;\par
  -webkit-margin-end: 10px;\par
  -webkit-padding-start: 2px;\par
  -webkit-transition: max-width 250ms, -webkit-margin-end 250ms;\par
\}\par
\par
.dot:last-child \{\par
  -webkit-margin-end: 0;\par
\}\par
\par
.dot.small \{\par
  max-width: 0;\par
  -webkit-margin-end: 0;\par
\}\par
\par
.dot .selection-bar \{\par
  border-bottom: 5px solid;\par
  border-color: rgba(0, 0, 0, 0.1);\par
  height: 10px;\par
  -webkit-transition: border-color 200ms;\par
\}\par
\par
.dot input \{\par
  background-color: transparent;\par
  cursor: inherit;\par
  /* TODO(estade): the font needs tweaking. */\par
  font-size: 8pt;\par
  font-weight: bold;\par
  padding-top: 0;\par
  width: 90%;\par
  -webkit-appearance: caret;\par
  -webkit-transition: color 200ms;\par
\}\par
\par
.dot input:focus \{\par
  cursor: auto;\par
\}\par
\par
/* Everything below here should be themed but we don't have appropriate colors\par
 * yet.\par
 */\par
.dot input \{\par
  color: #b2b2b2;\par
\}\par
\par
.dot:focus input, .dot:hover input, .dot.selected input \{\par
  color: #7f7f7f;\par
\}\par
\par
.dot:focus .selection-bar,\par
.dot:hover .selection-bar,\par
.dot.drag-target .selection-bar \{\par
  border-color: #b2b2b2;\par
\}\par
\par
.dot.selected .selection-bar \{\par
  border-color: #7f7f7f;\par
\}\par
</style>\par
<style>/* Copyright (c) 2012 The Chromium Authors. All rights reserved.\par
 * Use of this source code is governed by a BSD-style license that can be\par
 * found in the LICENSE file.\par
 */\par
\par
html \{\par
  font-family: segoe ui, arial, helvetica, sans-serif;\par
  font-size: 14px;\par
  /* It's necessary to put this here instead of in body in order to get the\par
     background-size of 100% to work properly */\par
  height: 100%;\par
  overflow: hidden;\par
\}\par
\par
body \{\par
  /* Don't highlight links when they're tapped.  Safari has bugs here that\par
     show up as flicker when dragging in some situations */\par
  -webkit-tap-highlight-color: transparent;\par
  /* Don't allow selecting text - can occur when dragging */\par
  -webkit-user-select: none;\par
  background-size: auto 100%;\par
  margin: 0;\par
\}\par
\par
/* [hidden] does display:none, but its priority is too low in some cases. */\par
[hidden] \{\par
  display: none !important;\par
\}\par
\par
#notification-container \{\par
  -webkit-transition-duration: 100ms;\par
  -webkit-transition-property: opacity;\par
  display: block;\par
  margin-top: 2px;\par
  position: relative;\par
  text-align: center;\par
  z-index: 15;\par
\}\par
\par
#notification-container.inactive \{\par
  -webkit-transition-duration: 200ms;\par
  opacity: 0;\par
\}\par
\par
#notification \{\par
  background-color: #FFF199;\par
  border: 1px solid lightGrey;\par
  border-radius: 6px;\par
  color: black;\par
  display: inline-block;\par
  font-weight: bold;\par
  padding: 7px 15px;\par
\}\par
\par
#notification > div > div,\par
#notification > div \{\par
  display: inline-block;\par
\}\par
\par
#notification .close-button \{\par
  -webkit-margin-start: 0.5em;\par
  vertical-align: middle;\par
\}\par
\par
.close-button \{\par
  background: no-repeat;\par
  background-color: transparent;\par
  /* TODO(estade): this should animate between states. */\par
  background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAQAAAC1+jfqAAAAiElEQVR42r2RsQrDMAxEBRdl8SDcX8lQPGg1GBI6lvz/h7QyRRXV0qUULwfvwZ1tenw5PxToRPWMC52eA9+WDnlh3HFQ/xBQl86NFYJqeGflkiogrOvVlIFhqURFVho3x1moGAa3deMs+LS30CAhBN5nNxeT5hbJ1zwmji2k+aF6NENIPf/hs54f0sZFUVAMigAAAABJRU5ErkJggg==");\par
  border: 0;\par
  cursor: default;\par
  display: inline-block;\par
  height: 16px;\par
  padding: 0;\par
  width: 16px;\par
\}\par
\par
.close-button:hover,\par
.close-button:focus \{\par
  background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAQAAAC1+jfqAAAAqklEQVR4XqWRMQ6DMAxF/1Fyilyj2SmIBUG5QcTCyJA5Z8jGhlBPgRi4TmoDraVmKFJlWYrlp/g5QfwRlwEVNWVa4WzfH9jK6kCkEkBjwxOhLghheMWMELUAqqwQ4OCbnE4LJnhr5IYdqQt4DJQjhe9u4vBBmnxHHNzRFkDGjHDo0VuTAqy2vAG4NkvXXDHxbGsIGlj3e835VFNtdugma/Jk0eXq0lP//5svi4PtO01oFfYAAAAASUVORK5CYII=");\par
\}\par
\par
.close-button:active \{\par
  background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAQAAAC1+jfqAAAARElEQVQoz2P4z4AfMlBLAYMdwxkghgEwD1XBGTC0g0sDIaYJECVwFqoChBK4WegKkJWArSJZAQErCDqSKG/iCyhaRhYA9LDIbULDzlIAAAAASUVORK5CYII=");\par
\}\par
\par
.linkButton \{\par
  -webkit-margin-start: 0.5em;\par
  color: #06C;\par
  cursor: pointer;\par
  display: inline-block;\par
  text-decoration: underline;\par
\}\par
\par
#card-slider-frame \{\par
  /* Must match #footer height. */\par
  bottom: 50px;\par
  overflow: hidden;\par
  /* We want this to fill the window except for the region used\par
     by footer */\par
  position: fixed;\par
  top: 0;\par
  width: 100%;\par
\}\par
\par
#page-list \{\par
  /* fill the apps-frame */\par
  height: 100%;\par
  display: -webkit-box;\par
\}\par
\par
#attribution \{\par
  bottom: 0;\par
  left: auto;\par
  margin-left: 8px;\par
  /* Leave room for the scrollbar. */\par
  margin-right: 13px;\par
  position: absolute;\par
  right: 0;\par
  text-align: left;\par
  z-index: -5;\par
\}\par
\par
/* For themes that right-align their images, we flip the attribution to the\par
 * left to avoid conflicts.  */\par
html[themegravity='right'] #attribution,\par
html[dir='rtl'] #attribution \{\par
  left: 0;\par
  right: auto;\par
  text-align: right;\par
\}\par
\par
#attribution > span \{\par
  display: block;\par
  font-size: 84%;\par
\}\par
\par
#footer \{\par
  background-image: -webkit-linear-gradient(\par
      rgba(242, 242, 242, 0.9), rgba(222, 222, 222, 0.9));\par
  bottom: 0;\par
  position: fixed;\par
  width: 100%;\par
  z-index: 5;\par
\}\par
\par
/* TODO(estade): remove this border hack and replace with a webkit-gradient\par
 * border-image on #footer once WebKit supports border-image-slice.\par
 * See {{\field{\*\fldinst{HYPERLINK https://bugs.webkit.org/show_bug.cgi?id=20127 }}{\fldrslt{https://bugs.webkit.org/show_bug.cgi?id=20127\ul0\cf0}}}}\f0\fs22  */\par
#footer-border \{\par
  height: 1px;\par
\}\par
\par
#footer-content \{\par
  -webkit-box-align: center;\par
  display: -webkit-box;\par
  height: 49px;\par
\}\par
\par
#footer-content > * \{\par
  margin: 0 9px;\par
\}\par
\par
#logo-img \{\par
  margin-top: 4px;\par
\}\par
\par
.starting-up * \{\par
  -webkit-transition: none !important;\par
\}\par
\par
/* Login Status. **************************************************************/\par
\par
#login-container \{\par
  -webkit-box-shadow: none;\par
  background: transparent none;\par
  border: none;\par
  cursor: pointer;\par
  font-size: 13px;\par
  /* Leave room for the scrollbar. */\par
  margin-left: 13px;\par
  margin-right: 13px;\par
  margin-top: 5px;\par
  padding: 0;\par
  position: fixed;\par
  right: 0;\par
  text-align: right;\par
  top: 0;\par
  z-index: 10;\par
\}\par
\par
html[dir='rtl'] #login-container \{\par
  left: 0;\par
  right: auto;\par
\}\par
\par
.login-status-icon \{\par
  -webkit-padding-end: 37px;\par
  background-position: right center;\par
  background-repeat: no-repeat;\par
  min-height: 27px;\par
\}\par
\par
html[dir='rtl'] .login-status-icon \{\par
  background-position-x: left;\par
\}\par
\par
.profile-name:hover \{\par
  text-decoration: underline;\par
\}\par
\par
.link-span \{\par
  text-decoration: underline;\par
\}\par
\par
#login-status-bubble-contents \{\par
  font-size: 13px;\par
\}\par
\par
#login-status-message-container \{\par
  margin-bottom: 13px;\par
\}\par
\par
#login-status-learn-more \{\par
  display: inline-block;\par
\}\par
\par
.login-status-row \{\par
  -webkit-box-align: center;\par
  -webkit-box-orient: horizontal;\par
  -webkit-box-pack: end;\par
  display: -webkit-box;\par
\}\par
\par
#login-status-advanced-container \{\par
  -webkit-box-flex: 1;\par
\}\par
\par
#login-status-dismiss \{\par
  min-width: 6em;\par
\}\par
\par
/* Trash. *********************************************************************/\par
\par
#trash \{\par
  -webkit-transition: top 200ms, opacity 0;\par
  -webkit-transition-delay: 0, 200ms;\par
  color: #222;\par
  height: 100%;\par
  position: absolute;\par
  opacity: 0;\par
  right: 0;\par
  top: 50px;\par
  width: auto;\par
\}\par
\par
html[dir='rtl'] #trash \{\par
  left: 0;\par
  right: auto;\par
\}\par
\par
#footer.showing-trash-mode #trash \{\par
  -webkit-transition-delay: 0, 0;\par
  -webkit-transition-duration: 0, 200ms;\par
  opacity: 0.75;\par
  top: 0;\par
\}\par
\par
#footer.showing-trash-mode #trash.drag-target \{\par
  opacity: 1;\par
\}\par
\par
#trash > .trash-text \{\par
  -webkit-padding-end: 7px;\par
  -webkit-padding-start: 30px;\par
  border: 1px dashed #7f7f7f;\par
  border-radius: 4px;\par
  display: inline-block;\par
  font-size: 84%;\par
  padding-bottom: 9px;\par
  padding-top: 10px;\par
  position: relative;\par
  top: 7px;\par
\}\par
\par
#trash > .lid,\par
#trash > .can \{\par
  top: 18px;\par
\}\par
\par
#footer.showing-trash-mode #trash.drag-target .lid \{\par
  -webkit-transform: rotate(-45deg);\par
\}\par
\par
html[dir='rtl'] #footer.showing-trash-mode #trash.drag-target .lid \{\par
  -webkit-transform: rotate(45deg);\par
\}\par
\par
#fontMeasuringDiv \{\par
  /* The font attributes match the nav inputs. */\par
  font-size: 8pt;\par
  font-weight: bold;\par
  pointer-events: none;\par
  position: absolute;\par
  visibility: hidden;\par
\}\par
\par
/* Page switcher buttons. *****************************************************/\par
\par
.page-switcher \{\par
  -webkit-transition: width 150ms, right 150ms, background-color 150ms;\par
  background-color: transparent;\par
  border: none;\par
  bottom: 0;\par
  font-size: 40px;\par
  padding: 0;\par
  position: absolute;\par
  margin: 0;\par
  max-width: 150px;\par
  min-width: 90px;\par
  outline: none;\par
  top: 0;\par
  z-index: 5;\par
\}\par
\par
#chrome-web-store-href \{\par
  -webkit-padding-end: 12px;\par
  /* Match transition delay of recently closed button. */\par
  -webkit-transition-delay: 100ms;\par
  color: #7F7F7F;\par
  cursor: pointer;\par
  display: none;\par
  margin: 0;\par
  text-decoration: none;\par
\}\par
\par
#chrome-web-store-title \{\par
  -webkit-padding-end: 26px;\par
  -webkit-padding-start: 16px;\par
  background: url('chrome://theme/IDR_WEBSTORE_ICON_24') right 50% no-repeat;\par
  display: inline-block;\par
  font-weight: bold;\par
  font-size: 9pt;\par
  line-height: 49px;\par
\}\par
\par
#chrome-web-store-href:hover \{\par
  color: #666;\par
\}\par
\par
html[dir='rtl'] #chrome-web-store-title \{\par
  background-position-x: left;\par
\}\par
\par
/* Show the chrome-web-store button when the experiment is turned on. */\par
.enable-cws-experiment #chrome-web-store-href \{\par
  display: inline-block;\par
\}\par
\par
/* Reserve space for the menu button even when it's hidden. */\par
#footer.showing-trash-mode #chrome-web-store-href \{\par
  visibility: hidden;\par
\}\par
\par
#footer.showing-trash-mode #chrome-web-store-href \{\par
  -webkit-transition-delay: 0;\par
  opacity: 0;\par
\}\par
</style>\par
<style>/* Copyright (c) 2012 The Chromium Authors. All rights reserved.\par
 * Use of this source code is governed by a BSD-style license that can be\par
 * found in the LICENSE file. */\par
\par
#recently-closed-menu-button \{\par
  -webkit-appearance: none;\par
  -webkit-padding-end: 15px;\par
  -webkit-padding-start: 9px;\par
  -webkit-transition: opacity 200ms;\par
  -webkit-transition-delay: 100ms;\par
  background: none;\par
  border: 0;\par
  color: #7F7F7F;\par
  cursor: pointer;\par
  display: block;\par
  margin: 0;\par
  font-size: 9pt;\par
  font-weight: bold;\par
  height: 100%;\par
  /* The padding increases the clickable area. */\par
  padding-bottom: 0;\par
  padding-top: 0;\par
\}\par
\par
.enable-cws-experiment #recently-closed-menu-button \{\par
  position: relative;\par
  -webkit-margin-end: 0;\par
  -webkit-padding-end: 16px;\par
\}\par
\par
#recently-closed-menu-button:hover:not([menu-shown]) \{\par
  color: #666;\par
\}\par
\par
#recently-closed-menu-button:hover:not([menu-shown]) .disclosure-triangle \{\par
  background-color: #666;\par
\}\par
\par
#recently-closed-menu-button[menu-shown] \{\par
  color: #555;\par
\}\par
\par
#recently-closed-menu-button[menu-shown] .disclosure-triangle \{\par
  background-color: #555;\par
\}\par
\par
/* Reserve space for the menu button even when it's hidden. */\par
#recently-closed-menu-button.invisible,\par
#footer.showing-trash-mode #recently-closed-menu-button \{\par
  visibility: hidden;\par
\}\par
\par
#footer.showing-trash-mode #recently-closed-menu-button \{\par
  opacity: 0;\par
  -webkit-transition-delay: 0;\par
\}\par
\par
#recently-closed-menu-button > * \{\par
  vertical-align: middle;\par
\}\par
\par
.recent-menu \{\par
  padding: 6px 8px;\par
  /* Needs to be above #footer. */\par
  z-index: 10;\par
\}\par
\par
.recent-menu-item \{\par
  background: no-repeat 0 50%;\par
  background-color: transparent !important;\par
  background-size: 16px 16px;\par
  box-sizing: border-box;\par
  display: block;\par
  font-size: 100%;\par
  line-height: 20px;\par
  margin: 8px;\par
  max-width: 450px;\par
  overflow: hidden;\par
  text-overflow: ellipsis;\par
  white-space: nowrap;\par
  -webkit-margin-start: 0;\par
  -webkit-padding-end: 0;\par
  -webkit-padding-start: 22px;\par
\}\par
\par
.recent-menu-item:not(:hover) \{\par
  text-decoration: none;\par
\}\par
\par
.recent-menu-item:first-of-type \{\par
  margin-top: 4px;\par
\}\par
\par
.recent-menu-item:last-of-type \{\par
  margin-bottom: 4px;\par
\}\par
\par
html[dir='rtl'] .recent-menu-item \{\par
  background: no-repeat 100% 50%;\par
\}\par
\par
.recent-window \{\par
  background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAA0UlEQVR42s2OSwsBYRSGz1+Uv6CQyTUsLFzKlFtmMWUQvkSJxIgfYGVrZWFjr9jY2L3mzJSUoo6NxdPbWTxPhwCQWq+gNisMmDWv7a5yVvHtYrsoZuPBLvXsOfzWVURvOQdZ0wna2xt2++OT5uIAX+vyFWs2AZnjoSudzvdXOPL1A3M0BBn9jie9w+GPGP0uqNYyPUFA1XFJNxrigG7UQYWKLg4UK2VQrpQXB9j9g0A2lxUHMo5LqUxCHEilk6BYXBMHoo5LES0oDrBL4VAAv/AAQoVZHAc9DoAAAAAASUVORK5CYII=");\par
\}\par
\par
/* TODO(estade): find a better color for active. */\par
.recent-menu-item:active,\par
.recent-menu-item:visited,\par
.recent-menu-item:link \{\par
  color: hsl(213, 90%, 24%) !important;\par
\}\par
\par
.disclosure-triangle \{\par
  background-color: #7F7F7F;\par
  display: inline-block;\par
  height: 9px;\par
  width: 9px;\par
  -webkit-margin-start: 2px;\par
  -webkit-mask-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAkAAAAJCAYAAADgkQYQAAAAJUlEQVQYV2NgoDuYSQSGK/RB0+yDrACbQqwKkBUW41OArJB0AAACXws0ERupuAAAAABJRU5ErkJggg==");\par
\}\par
\par
#vertical-separator \{\par
  background-color: #B2B2B2;\par
  display: none;\par
  height: 20px;\par
  left: 15px;\par
  position: relative;\par
  right: 15px;\par
  width: 1px;\par
\}\par
\par
.enable-cws-experiment #vertical-separator \{\par
  display: inline-block;\par
\}\par
</style>\par
<style>/* Copyright (c) 2011 The Chromium Authors. All rights reserved.\par
 * Use of this source code is governed by a BSD-style license that can be\par
 * found in the LICENSE file.\par
 */\par
\par
.tile-page \{\par
  display: -webkit-box;\par
  height: 100%;\par
  position: relative;\par
  width: 100%;\par
  -webkit-box-orient: vertical;\par
\}\par
\par
.tile-page-scrollbar \{\par
  margin: 0 4px;\par
  pointer-events: none;\par
  position: absolute;\par
  right: 0;\par
  width: 5px;\par
  z-index: 5;\par
  -webkit-box-sizing: border-box;\par
\}\par
\par
.tile-page-content \{\par
  overflow-y: scroll;\par
  /* This value is mirrored in TilePage.updateTopMargin_ */\par
  padding-top: 60px;\par
  position: relative;\par
  text-align: center;\par
  width: 100%;\par
  /* TODO(estade): this mask is disabled for technical reasons. It negatively\par
   * impacts performance of page switching, also it causes problems with Mac\par
   * text: {{\field{\*\fldinst{HYPERLINK http://crbug.com/86955 }}{\fldrslt{http://crbug.com/86955\ul0\cf0}}}}\f0\fs22\par
  -webkit-mask-image: -webkit-linear-gradient(bottom, transparent, black 30px);\par
  */\par
  /* The following four properties are necessary so that the mask won't clip\par
   * the scrollbar. */\par
  box-sizing: border-box;\par
  /* Scrollbar width(13px) + balance right padding.  */\par
  padding-left: 93px;\par
  padding-right: 80px;\par
  -webkit-box-flex: 1;\par
  /* Don't apply clip mask to padding. */\par
  -webkit-mask-clip: content-box;\par
\}\par
\par
.tile-grid \{\par
  position: relative;\par
  width: 100%;\par
\}\par
\par
.tile \{\par
  display: inline-block;\par
  position: absolute;\par
  -webkit-print-color-adjust: exact;\par
  /* Don't offer the context menu on long-press. */\par
  -webkit-touch-callout: none;\par
  -webkit-user-drag: element;\par
\}\par
\par
/* I don't know why this is necessary. -webkit-user-drag: element on .tile\par
 * should be enough. If we don't do this, we get 2 drag representations for\par
 * the image. */\par
.tile img \{\par
  -webkit-user-drag: none;\par
\}\par
\par
.doppleganger \{\par
  left: 0 !important;\par
  right: 0 !important;\par
  top: 0 !important;\par
\}\par
\par
.tile.dragging \{\par
  opacity: 0;\par
\}\par
\par
.tile.drag-representation \{\par
  pointer-events: none;\par
  position: fixed;\par
  z-index: 3;\par
  -webkit-transition: opacity 200ms;\par
\}\par
\par
.tile.drag-representation.placing > * \{\par
  -webkit-transition: -webkit-transform 200ms;\par
\}\par
\par
/* When a drag finishes while we're not showing the page where the tile\par
 * belongs, the tile shrinks to a dot. */\par
.tile.drag-representation.dropped-on-other-page > * \{\par
   -webkit-transform: scale(0) rotate(0);\par
\}\par
\par
.tile.drag-representation.deleting > * \{\par
  -webkit-transform: scale(0) rotate(360deg);\par
  -webkit-transition: -webkit-transform 600ms;\par
\}\par
\par
.animating-tile-page .tile,\par
.tile.drag-representation.placing \{\par
  -webkit-transition: left 200ms, right 200ms, top 200ms;\par
\}\par
\par
.hovering-on-trash \{\par
  opacity: 0.6;\par
\}\par
\par
.animating-tile-page .top-margin \{\par
  -webkit-transition: margin-bottom 200ms;\par
\}\par
\par
@-webkit-keyframes bounce \{\par
  0% \{\par
    -webkit-transform: scale(0, 0);\par
  \}\par
\par
  60% \{\par
    -webkit-transform: scale(1.2, 1.2);\par
  \}\par
\par
  100% \{\par
    -webkit-transform: scale(1, 1);\par
  \}\par
\}\par
\par
.tile > .new-tile-contents \{\par
  -webkit-animation: bounce 500ms ease-in-out;\par
\}\par
\par
@-webkit-keyframes blipout \{\par
  0% \{\par
    -webkit-transform: scale(1, 1);\par
  \}\par
\par
  60% \{\par
    opacity: 1;\par
    -webkit-animation-timing-function: ease-in;\par
    -webkit-transform: scale(1.3, 0.02);\par
  \}\par
\par
  90% \{\par
    opacity: 0.7;\par
    -webkit-animation-timing-function: default;\par
    -webkit-transform: scale(0.3, 0.02);\par
  \}\par
\par
  100% \{\par
    opacity: 0;\par
    -webkit-animation-timing-function: linear;\par
    -webkit-transform: scale(0.3, 0.02);\par
  \}\par
\}\par
\par
.tile > .removing-tile-contents \{\par
  pointer-events: none;\par
  -webkit-animation: blipout 300ms;\par
\}\par
\par
.tile-page:not(.selected-card) * \{\par
  -webkit-transition: none !important;\par
\}\par
\par
/** Scrollbars ****************************************************************/\par
\par
.tile-page-content::-webkit-scrollbar \{\par
  width: 13px;\par
\}\par
\par
.tile-page-content::-webkit-scrollbar-button \{\par
  display: none;\par
\}\par
</style>\par
<link id="themecss" rel="stylesheet" href="chrome://theme/css/newtab.css?1455578975327">\par
\par
<script>// Copyright (c) 2011 The Chromium Authors. All rights reserved.\par
// Use of this source code is governed by a BSD-style license that can be\par
// found in the LICENSE file.\par
\par
/** @fileoverview EventTracker is a simple class that manages the addition and\par
 *  removal of DOM event listeners. In particular, it keeps track of all\par
 *  listeners that have been added and makes it easy to remove some or all of\par
 *  them without requiring all the information again. This is particularly\par
 *  handy when the listener is a generated function such as a lambda or the\par
 *  result of calling Function.bind.\par
 */\par
\par
// Use an anonymous function to enable strict mode just for this file (which\par
// will be concatenated with other files when embedded in Chrome)\par
var EventTracker = (function() \{\par
  'use strict';\par
\par
  /**\par
   *  Create an EventTracker to track a set of events.\par
   *  EventTracker instances are typically tied 1:1 with other objects or\par
   *  DOM elements whose listeners should be removed when the object is disposed\par
   *  or the corresponding elements are removed from the DOM.\par
   *  @constructor\par
   */\par
  function EventTracker() \{\par
    /**\par
     *  @type \{Array.<EventTracker.Entry>\}\par
     *  @private\par
     */\par
    this.listeners_ = [];\par
  \}\par
\par
  /**\par
   * The type of the internal tracking entry.\par
   *  @typedef \{\{node: !Node,\par
   *            eventType: string,\par
   *            listener: Function,\par
   *            capture: boolean\}\}\par
   */\par
  EventTracker.Entry;\par
\par
  EventTracker.prototype = \{\par
    /**\par
     * Add an event listener - replacement for Node.addEventListener.\par
     * @param \{!Node\} node The DOM node to add a listener to.\par
     * @param \{string\} eventType The type of event to subscribe to.\par
     * @param \{Function\} listener The listener to add.\par
     * @param \{boolean\} capture Whether to invoke during the capture phase.\par
     */\par
    add: function(node, eventType, listener, capture) \{\par
      var h = \{\par
        node: node,\par
        eventType: eventType,\par
        listener: listener,\par
        capture: capture\par
      \};\par
      this.listeners_.push(h);\par
      node.addEventListener(eventType, listener, capture);\par
    \},\par
\par
    /**\par
     * Remove any specified event listeners added with this EventTracker.\par
     * @param \{!Node\} node The DOM node to remove a listener from.\par
     * @param \{?string\} eventType The type of event to remove.\par
     */\par
    remove: function(node, eventType) \{\par
      this.listeners_ = this.listeners_.filter(function(h) \{\par
        if (h.node == node && (!eventType || (h.eventType == eventType))) \{\par
          EventTracker.removeEventListener_(h);\par
          return false;\par
        \}\par
        return true;\par
      \});\par
    \},\par
\par
    /**\par
     * Remove all event listeners added with this EventTracker.\par
     */\par
    removeAll: function() \{\par
      this.listeners_.forEach(EventTracker.removeEventListener_);\par
      this.listeners_ = [];\par
    \}\par
  \};\par
\par
  /**\par
   * Remove a single event listener given it's tracker entry.  It's up to the\par
   * caller to ensure the entry is removed from listeners_.\par
   * @param \{EventTracker.Entry\} h The entry describing the listener to remove.\par
   * @private\par
   */\par
  EventTracker.removeEventListener_ = function(h) \{\par
    h.node.removeEventListener(h.eventType, h.listener, h.capture);\par
  \};\par
\par
  return EventTracker;\par
\})();\par
\par
</script>\par
<script>// Copyright (c) 2011 The Chromium Authors. All rights reserved.\par
// Use of this source code is governed by a BSD-style license that can be\par
// found in the LICENSE file.\par
\par
// TODO(arv): Namespace\par
\par
/**\par
 * The local strings get injected into the page using a variable named\par
 * \{@code templateData\}. This class provides a simpler interface to access those\par
 * strings.\par
 *\par
 * @param \{Object\} opt_templateData Optional object containing translated\par
 *     strings.  If this is not supplied during construction, it can be\par
 *     assigned to the templateData property after construction.  If all else\par
 *     fails, the value of window.templateDate will be used.\par
 * @constructor\par
 */\par
function LocalStrings(opt_templateData) \{\par
  this.templateData = opt_templateData;\par
\}\par
\par
// Start of anonymous namespace.\par
(function() \{\par
\par
/**\par
 * Returns a formatted string where $1 to $9 are replaced by the second to the\par
 * tenth argument.\par
 * @param \{string\} s The format string.\par
 * @param \{...string\} The extra values to include in the formatted output.\par
 * @return \{string\} The string after format substitution.\par
 */\par
function replaceArgs(s, args) \{\par
  return s.replace(/\\$[$1-9]/g, function(m) \{\par
    return (m == '$$') ? '$' : args[m[1]];\par
  \});\par
\}\par
\par
/**\par
 * Returns a string after removing Windows-style accelerators.\par
 * @param \{string\} s The input string that may contain accelerators.\par
 * @return \{string\} The resulting string with accelerators removed.\par
 */\par
function trimAccelerators(s) \{\par
  return s.replace(/&\{1,2\}/g, function(m) \{\par
    return (m == '&&') ? '&' : '';\par
  \});\par
\}\par
\par
LocalStrings.prototype = \{\par
  /**\par
   * The template data object.\par
   * @type \{Object\}\par
   */\par
  templateData: null,\par
\par
  /**\par
   * Gets a localized string by its id.\par
   * @param \{string\} s The ID of the string we want.\par
   * @return \{string\} The localized string.\par
   */\par
  getString: function(id) \{\par
    // TODO(arv): We should not rely on a global variable here.\par
    return (this.templateData || window.templateData)[id] || '';\par
  \},\par
\par
  /**\par
   * Returns a formatted localized string where $1 to $9 are replaced by the\par
   * second to the tenth argument.\par
   * @param \{string\} id The ID of the string we want.\par
   * @param \{...string\} The extra values to include in the formatted output.\par
   * @return \{string\} The formatted string.\par
   */\par
  getStringF: function(id, var_args) \{\par
    return replaceArgs(this.getString(id), arguments);\par
  \},\par
\};\par
\par
// End of anonymous namespace.\par
\})();\par
</script>\par
<script>/**\par
 * Whitelist of tag names allowed in parseHtmlSubset.\par
 * @type \{[string]\}\par
 */\par
var allowedTags = ['A', 'B', 'STRONG'];\par
\par
/**\par
 * Parse a very small subset of HTML.\par
 * @param \{string\} s The string to parse.\par
 * @throws \{Error\} In case of non supported markup.\par
 * @return \{DocumentFragment\} A document fragment containing the DOM tree.\par
 */\par
var allowedAttributes = \{\par
  'href': function(node, value) \{\par
    // Only allow a[href] starting with {{\field{\*\fldinst{HYPERLINK http:// }}{\fldrslt{http://\ul0\cf0}}}}\f0\fs22  and {{\field{\*\fldinst{HYPERLINK https:// }}{\fldrslt{https://\ul0\cf0}}}}\f0\fs22\par
    return node.tagName == 'A' && (value.indexOf('{{\field{\*\fldinst{HYPERLINK http:// }}{\fldrslt{http://\ul0\cf0}}}}\f0\fs22 ') == 0 ||\par
        value.indexOf('{{\field{\*\fldinst{HYPERLINK https:// }}{\fldrslt{https://\ul0\cf0}}}}\f0\fs22 ') == 0);\par
  \},\par
  'target': function(node, value) \{\par
    // Allow a[target] but reset the value to "".\par
    if (node.tagName != 'A')\par
      return false;\par
    node.setAttribute('target', '');\par
    return true;\par
  \}\par
\}\par
\par
/**\par
 * Parse a very small subset of HTML.  This ensures that insecure HTML /\par
 * javascript cannot be injected into the new tab page.\par
 * @param \{string\} s The string to parse.\par
 * @throws \{Error\} In case of non supported markup.\par
 * @return \{DocumentFragment\} A document fragment containing the DOM tree.\par
 */\par
function parseHtmlSubset(s) \{\par
  function walk(n, f) \{\par
    f(n);\par
    for (var i = 0; i < n.childNodes.length; i++) \{\par
      walk(n.childNodes[i], f);\par
    \}\par
  \}\par
\par
  function assertElement(node) \{\par
    if (allowedTags.indexOf(node.tagName) == -1)\par
      throw Error(node.tagName + ' is not supported');\par
  \}\par
\par
  function assertAttribute(attrNode, node) \{\par
    var n = attrNode.nodeName;\par
    var v = attrNode.nodeValue;\par
    if (!allowedAttributes.hasOwnProperty(n) || !allowedAttributes[n](node, v))\par
      throw Error(node.tagName + '[' + n + '="' + v + '"] is not supported');\par
  \}\par
\par
  var r = document.createRange();\par
  r.selectNode(document.body);\par
  // This does not execute any scripts.\par
  var df = r.createContextualFragment(s);\par
  walk(df, function(node) \{\par
    switch (node.nodeType) \{\par
      case Node.ELEMENT_NODE:\par
        assertElement(node);\par
        var attrs = node.attributes;\par
        for (var i = 0; i < attrs.length; i++) \{\par
          assertAttribute(attrs[i], node);\par
        \}\par
        break;\par
\par
      case Node.COMMENT_NODE:\par
      case Node.DOCUMENT_FRAGMENT_NODE:\par
      case Node.TEXT_NODE:\par
        break;\par
\par
      default:\par
        throw Error('Node type ' + node.nodeType + ' is not supported');\par
    \}\par
  \});\par
  return df;\par
\}\par
</script>\par
<script>// Copyright (c) 2011 The Chromium Authors. All rights reserved.\par
// Use of this source code is governed by a BSD-style license that can be\par
// found in the LICENSE file.\par
\par
/**\par
 * The global object.\par
 * @type \{!Object\}\par
 */\par
const global = this;\par
\par
/**\par
 * Alias for document.getElementById.\par
 * @param \{string\} id The ID of the element to find.\par
 * @return \{HTMLElement\} The found element or null if not found.\par
 */\par
function $(id) \{\par
  return document.getElementById(id);\par
\}\par
\par
/**\par
 * Calls chrome.send with a callback and restores the original afterwards.\par
 * @param \{string\} name The name of the message to send.\par
 * @param \{!Array\} params The parameters to send.\par
 * @param \{string\} callbackName The name of the function that the backend calls.\par
 * @param \{!Function\} The function to call.\par
 */\par
function chromeSend(name, params, callbackName, callback) \{\par
  var old = global[callbackName];\par
  global[callbackName] = function() \{\par
    // restore\par
    global[callbackName] = old;\par
\par
    var args = Array.prototype.slice.call(arguments);\par
    return callback.apply(global, args);\par
  \};\par
  chrome.send(name, params);\par
\}\par
\par
/**\par
 * Generates a CSS url string.\par
 * @param \{string\} s The URL to generate the CSS url for.\par
 * @return \{string\} The CSS url string.\par
 */\par
function url(s) \{\par
  // {{\field{\*\fldinst{HYPERLINK http://www.w3.org/TR/css3-values/#uris }}{\fldrslt{http://www.w3.org/TR/css3-values/#uris\ul0\cf0}}}}\f0\fs22\par
  // Parentheses, commas, whitespace characters, single quotes (') and double\par
  // quotes (") appearing in a URI must be escaped with a backslash\par
  var s2 = s.replace(/(\\(|\\)|\\,|\\s|\\'|\\"|{{\field{\*\fldinst{HYPERLINK "\\\\\\\\)/g"}}{\fldrslt{\\\\)/g\ul0\cf0}}}}\f0\fs22 , '{{\field{\*\fldinst{HYPERLINK "\\\\\\\\$1'"}}{\fldrslt{\\\\$1'\ul0\cf0}}}}\f0\fs22 );\par
  // WebKit has a bug when it comes to URLs that end with \\\par
  // {{\field{\*\fldinst{HYPERLINK https://bugs.webkit.org/show_bug.cgi?id=28885 }}{\fldrslt{https://bugs.webkit.org/show_bug.cgi?id=28885\ul0\cf0}}}}\f0\fs22\par
  if (/\\\\\\\\$/.test(s2)) \{\par
    // Add a space to work around the WebKit bug.\par
    s2 += ' ';\par
  \}\par
  return 'url("' + s2 + '")';\par
\}\par
\par
/**\par
 * Parses query parameters from Location.\par
 * @param \{string\} s The URL to generate the CSS url for.\par
 * @return \{object\} Dictionary containing name value pairs for URL\par
 */\par
function parseQueryParams(location) \{\par
  var params = \{\};\par
  var query = unescape(location.search.substring(1));\par
  var vars = query.split("&");\par
  for (var i=0; i < vars.length; i++) \{\par
    var pair = vars[i].split("=");\par
    params[pair[0]] = pair[1];\par
  \}\par
  return params;\par
\}\par
\par
function findAncestorByClass(el, className) \{\par
  return findAncestor(el, function(el) \{\par
    if (el.classList)\par
      return el.classList.contains(className);\par
    return null;\par
  \});\par
\}\par
\par
/**\par
 * Return the first ancestor for which the \{@code predicate\} returns true.\par
 * @param \{Node\} node The node to check.\par
 * @param \{function(Node) : boolean\} predicate The function that tests the\par
 *     nodes.\par
 * @return \{Node\} The found ancestor or null if not found.\par
 */\par
function findAncestor(node, predicate) \{\par
  var last = false;\par
  while (node != null && !(last = predicate(node))) \{\par
    node = node.parentNode;\par
  \}\par
  return last ? node : null;\par
\}\par
\par
function swapDomNodes(a, b) \{\par
  var afterA = a.nextSibling;\par
  if (afterA == b) \{\par
    swapDomNodes(b, a);\par
    return;\par
  \}\par
  var aParent = a.parentNode;\par
  b.parentNode.replaceChild(a, b);\par
  aParent.insertBefore(b, afterA);\par
\}\par
\par
/**\par
 * Disables text selection and dragging.\par
 */\par
function disableTextSelectAndDrag() \{\par
  // Disable text selection.\par
  document.onselectstart = function(e) \{\par
    e.preventDefault();\par
  \}\par
\par
  // Disable dragging.\par
  document.ondragstart = function(e) \{\par
    e.preventDefault();\par
  \}\par
\}\par
\par
/**\par
 * Check the directionality of the page.\par
 * @return \{boolean\} True if Chrome is running an RTL UI.\par
 */\par
function isRTL() \{\par
  return document.documentElement.dir == 'rtl';\par
\}\par
\par
/**\par
 * Simple common assertion API\par
 * @param \{*\} condition The condition to test.  Note that this may be used to\par
 *     test whether a value is defined or not, and we don't want to force a\par
 *     cast to Boolean.\par
 * @param \{string=\} opt_message A message to use in any error.\par
 */\par
function assert(condition, opt_message) \{\par
  'use strict';\par
  if (!condition) \{\par
    var msg = 'Assertion failed';\par
    if (opt_message)\par
      msg = msg + ': ' + opt_message;\par
    throw new Error(msg);\par
  \}\par
\}\par
\par
/**\par
 * Get an element that's known to exist by its ID. We use this instead of just\par
 * calling getElementById and not checking the result because this lets us\par
 * satisfy the JSCompiler type system.\par
 * @param \{string\} id The identifier name.\par
 * @return \{!Element\} the Element.\par
 */\par
function getRequiredElement(id) \{\par
  var element = $(id);\par
  assert(element, 'Missing required element: ' + id);\par
  return element;\par
\}\par
\par
// Handle click on a link. If the link points to a chrome: or file: url, then\par
// call into the browser to do the navigation.\par
document.addEventListener('click', function(e) \{\par
  // Allow preventDefault to work.\par
  if (!e.returnValue)\par
    return;\par
\par
  var el = e.target;\par
  if (el.nodeType == Node.ELEMENT_NODE &&\par
      el.webkitMatchesSelector('A, A *')) \{\par
    while (el.tagName != 'A') \{\par
      el = el.parentElement;\par
    \}\par
\par
    if ((el.protocol == '{{\field{\*\fldinst{HYPERLINK file: }}{\fldrslt{file:\ul0\cf0}}}}\f0\fs22 ' || el.protocol == 'about:') &&\par
        (e.button == 0 || e.button == 1)) \{\par
      chrome.send('navigateToUrl', [\par
        el.href,\par
        el.target,\par
        e.button,\par
        e.altKey,\par
        e.ctrlKey,\par
        e.metaKey,\par
        e.shiftKey\par
      ]);\par
      e.preventDefault();\par
    \}\par
  \}\par
\});\par
\par
/**\par
 * Creates a new URL which is the old URL with a GET param of key=value.\par
 * @param \{string\} url The base URL. There is not sanity checking on the URL so\par
 *     it must be passed in a proper format.\par
 * @param \{string\} key The key of the param.\par
 * @param \{string\} value The value of the param.\par
 * @return \{string\}\par
 */\par
function appendParam(url, key, value) \{\par
  var param = encodeURIComponent(key) + '=' + encodeURIComponent(value);\par
\par
  if (url.indexOf('?') == -1)\par
    return url + '?' + param;\par
  return url + '&' + param;\par
\}\par
</script>\par
\par
<script>// Copyright (c) 2012 The Chromium Authors. All rights reserved.\par
// Use of this source code is governed by a BSD-style license that can be\par
// found in the LICENSE file.\par
\par
const cr = (function() \{\par
\par
  /**\par
   * Whether we are using a Mac or not.\par
   * @type \{boolean\}\par
   */\par
  const isMac = /Mac/.test(navigator.platform);\par
\par
  /**\par
   * Whether this is on the Windows platform or not.\par
   * @type \{boolean\}\par
   */\par
  const isWindows = /Win/.test(navigator.platform);\par
\par
  /**\par
   * Whether this is on chromeOS or not.\par
   * @type \{boolean\}\par
   */\par
  const isChromeOS = /CrOS/.test(navigator.userAgent);\par
\par
  /**\par
   * Whether this is on vanilla Linux (not chromeOS).\par
   * @type \{boolean\}\par
   */\par
  const isLinux = /Linux/.test(navigator.userAgent);\par
\par
  /**\par
   * Whether this uses GTK or not.\par
   * @type \{boolean\}\par
   */\par
  const isGTK = /GTK/.test(chrome.toolkit);\par
\par
  /**\par
   * Whether this uses the views toolkit or not.\par
   * @type \{boolean\}\par
   */\par
  const isViews = /views/.test(chrome.toolkit);\par
\par
  /**\par
   * Whether this window is optimized for touch-based input.\par
   * @type \{boolean\}\par
   */\par
  const isTouchOptimized = !!chrome.touchOptimized;\par
\par
  /**\par
   * Sets the os and toolkit attributes in the <html> element so that platform\par
   * specific css rules can be applied.\par
   */\par
  function enablePlatformSpecificCSSRules() \{\par
    if (isMac)\par
      doc.documentElement.setAttribute('os', 'mac');\par
    if (isWindows)\par
      doc.documentElement.setAttribute('os', 'windows');\par
    if (isChromeOS)\par
      doc.documentElement.setAttribute('os', 'chromeos');\par
    if (isLinux)\par
      doc.documentElement.setAttribute('os', 'linux');\par
    if (isGTK)\par
      doc.documentElement.setAttribute('toolkit', 'gtk');\par
    if (isViews)\par
      doc.documentElement.setAttribute('toolkit', 'views');\par
    if (isTouchOptimized)\par
      doc.documentElement.setAttribute('touch-optimized', '');\par
  \}\par
\par
  /**\par
   * Builds an object structure for the provided namespace path,\par
   * ensuring that names that already exist are not overwritten. For\par
   * example:\par
   * "a.b.c" -> a = \{\};a.b=\{\};a.b.c=\{\};\par
   * @param \{string\} name Name of the object that this file defines.\par
   * @param \{*=\} opt_object The object to expose at the end of the path.\par
   * @param \{Object=\} opt_objectToExportTo The object to add the path to;\par
   *     default is \{@code window\}.\par
   * @private\par
   */\par
  function exportPath(name, opt_object, opt_objectToExportTo) \{\par
    var parts = name.split('.');\par
    var cur = opt_objectToExportTo || window /* global */;\par
\par
    for (var part; parts.length && (part = parts.shift());) \{\par
      if (!parts.length && opt_object !== undefined) \{\par
        // last part and we have an object; use it\par
        cur[part] = opt_object;\par
      \} else if (part in cur) \{\par
        cur = cur[part];\par
      \} else \{\par
        cur = cur[part] = \{\};\par
      \}\par
    \}\par
    return cur;\par
  \};\par
\par
  // cr.Event is called CrEvent in here to prevent naming conflicts. We also\par
  // store the original Event in case someone does a global alias of cr.Event.\par
  const DomEvent = Event;\par
\par
  /**\par
   * Creates a new event to be used with cr.EventTarget or DOM EventTarget\par
   * objects.\par
   * @param \{string\} type The name of the event.\par
   * @param \{boolean=\} opt_bubbles Whether the event bubbles. Default is false.\par
   * @param \{boolean=\} opt_preventable Whether the default action of the event\par
   *     can be prevented.\par
   * @constructor\par
   * @extends \{DomEvent\}\par
   */\par
  function CrEvent(type, opt_bubbles, opt_preventable) \{\par
    var e = cr.doc.createEvent('Event');\par
    e.initEvent(type, !!opt_bubbles, !!opt_preventable);\par
    e.__proto__ = CrEvent.prototype;\par
    return e;\par
  \}\par
\par
  CrEvent.prototype = \{\par
    __proto__: DomEvent.prototype\par
  \};\par
\par
  /**\par
   * Fires a property change event on the target.\par
   * @param \{EventTarget\} target The target to dispatch the event on.\par
   * @param \{string\} propertyName The name of the property that changed.\par
   * @param \{*\} newValue The new value for the property.\par
   * @param \{*\} oldValue The old value for the property.\par
   */\par
  function dispatchPropertyChange(target, propertyName, newValue, oldValue) \{\par
    var e = new CrEvent(propertyName + 'Change');\par
    e.propertyName = propertyName;\par
    e.newValue = newValue;\par
    e.oldValue = oldValue;\par
    target.dispatchEvent(e);\par
  \}\par
\par
  /**\par
   * Converts a camelCase javascript property name to a hyphenated-lower-case\par
   * attribute name.\par
   * @param \{string\} jsName The javascript camelCase property name.\par
   * @return \{string\} The equivalent hyphenated-lower-case attribute name.\par
   */\par
  function getAttributeName(jsName) \{\par
    return jsName.replace(/([A-Z])/g, '-$1').toLowerCase();\par
  \}\par
\par
  /**\par
   * The kind of property to define in \{@code defineProperty\}.\par
   * @enum \{number\}\par
   */\par
  const PropertyKind = \{\par
    /**\par
     * Plain old JS property where the backing data is stored as a "private"\par
     * field on the object.\par
     */\par
    JS: 'js',\par
\par
    /**\par
     * The property backing data is stored as an attribute on an element.\par
     */\par
    ATTR: 'attr',\par
\par
    /**\par
     * The property backing data is stored as an attribute on an element. If the\par
     * element has the attribute then the value is true.\par
     */\par
    BOOL_ATTR: 'boolAttr'\par
  \};\par
\par
  /**\par
   * Helper function for defineProperty that returns the getter to use for the\par
   * property.\par
   * @param \{string\} name\par
   * @param \{cr.PropertyKind\} kind\par
   * @return \{function():*\} The getter for the property.\par
   */\par
  function getGetter(name, kind) \{\par
    switch (kind) \{\par
      case PropertyKind.JS:\par
        var privateName = name + '_';\par
        return function() \{\par
          return this[privateName];\par
        \};\par
      case PropertyKind.ATTR:\par
        var attributeName = getAttributeName(name);\par
        return function() \{\par
          return this.getAttribute(attributeName);\par
        \};\par
      case PropertyKind.BOOL_ATTR:\par
        var attributeName = getAttributeName(name);\par
        return function() \{\par
          return this.hasAttribute(attributeName);\par
        \};\par
    \}\par
  \}\par
\par
  /**\par
   * Helper function for defineProperty that returns the setter of the right\par
   * kind.\par
   * @param \{string\} name The name of the property we are defining the setter\par
   *     for.\par
   * @param \{cr.PropertyKind\} kind The kind of property we are getting the\par
   *     setter for.\par
   * @param \{function(*):void\} opt_setHook A function to run after the property\par
   *     is set, but before the propertyChange event is fired.\par
   * @return \{function(*):void\} The function to use as a setter.\par
   */\par
  function getSetter(name, kind, opt_setHook) \{\par
    switch (kind) \{\par
      case PropertyKind.JS:\par
        var privateName = name + '_';\par
        return function(value) \{\par
          var oldValue = this[privateName];\par
          if (value !== oldValue) \{\par
            this[privateName] = value;\par
            if (opt_setHook)\par
              opt_setHook.call(this, value, oldValue);\par
            dispatchPropertyChange(this, name, value, oldValue);\par
          \}\par
        \};\par
\par
      case PropertyKind.ATTR:\par
        var attributeName = getAttributeName(name);\par
        return function(value) \{\par
          var oldValue = this[attributeName];\par
          if (value !== oldValue) \{\par
            if (value == undefined)\par
              this.removeAttribute(attributeName);\par
            else\par
              this.setAttribute(attributeName, value);\par
            if (opt_setHook)\par
              opt_setHook.call(this, value, oldValue);\par
            dispatchPropertyChange(this, name, value, oldValue);\par
          \}\par
        \};\par
\par
      case PropertyKind.BOOL_ATTR:\par
        var attributeName = getAttributeName(name);\par
        return function(value) \{\par
          var oldValue = this[attributeName];\par
          if (value !== oldValue) \{\par
            if (value)\par
              this.setAttribute(attributeName, name);\par
            else\par
              this.removeAttribute(attributeName);\par
            if (opt_setHook)\par
              opt_setHook.call(this, value, oldValue);\par
            dispatchPropertyChange(this, name, value, oldValue);\par
          \}\par
        \};\par
    \}\par
  \}\par
\par
  /**\par
   * Defines a property on an object. When the setter changes the value a\par
   * property change event with the type \{@code name + 'Change'\} is fired.\par
   * @param \{!Object\} obj The object to define the property for.\par
   * @param \{string\} name The name of the property.\par
   * @param \{cr.PropertyKind=\} opt_kind What kind of underlying storage to use.\par
   * @param \{function(*):void\} opt_setHook A function to run after the\par
   *     property is set, but before the propertyChange event is fired.\par
   */\par
  function defineProperty(obj, name, opt_kind, opt_setHook) \{\par
    if (typeof obj == 'function')\par
      obj = obj.prototype;\par
\par
    var kind = opt_kind || PropertyKind.JS;\par
\par
    if (!obj.__lookupGetter__(name))\par
      obj.__defineGetter__(name, getGetter(name, kind));\par
\par
    if (!obj.__lookupSetter__(name))\par
      obj.__defineSetter__(name, getSetter(name, kind, opt_setHook));\par
  \}\par
\par
  /**\par
   * Counter for use with createUid\par
   */\par
  var uidCounter = 1;\par
\par
  /**\par
   * @return \{number\} A new unique ID.\par
   */\par
  function createUid() \{\par
    return uidCounter++;\par
  \}\par
\par
  /**\par
   * Returns a unique ID for the item. This mutates the item so it needs to be\par
   * an object\par
   * @param \{!Object\} item The item to get the unique ID for.\par
   * @return \{number\} The unique ID for the item.\par
   */\par
  function getUid(item) \{\par
    if (item.hasOwnProperty('uid'))\par
      return item.uid;\par
    return item.uid = createUid();\par
  \}\par
\par
  /**\par
   * Dispatches a simple event on an event target.\par
   * @param \{!EventTarget\} target The event target to dispatch the event on.\par
   * @param \{string\} type The type of the event.\par
   * @param \{boolean=\} opt_bubbles Whether the event bubbles or not.\par
   * @param \{boolean=\} opt_cancelable Whether the default action of the event\par
   *     can be prevented.\par
   * @return \{boolean\} If any of the listeners called \{@code preventDefault\}\par
   *     during the dispatch this will return false.\par
   */\par
  function dispatchSimpleEvent(target, type, opt_bubbles, opt_cancelable) \{\par
    var e = new cr.Event(type, opt_bubbles, opt_cancelable);\par
    return target.dispatchEvent(e);\par
  \}\par
\par
  /**\par
   * @param \{string\} name\par
   * @param \{!Function\} fun\par
   */\par
  function define(name, fun) \{\par
    var obj = exportPath(name);\par
    var exports = fun();\par
    for (var propertyName in exports) \{\par
      // Maybe we should check the prototype chain here? The current usage\par
      // pattern is always using an object literal so we only care about own\par
      // properties.\par
      var propertyDescriptor = Object.getOwnPropertyDescriptor(exports,\par
                                                               propertyName);\par
      if (propertyDescriptor)\par
        Object.defineProperty(obj, propertyName, propertyDescriptor);\par
    \}\par
  \}\par
\par
  /**\par
   * Document used for various document related operations.\par
   * @type \{!Document\}\par
   */\par
  var doc = document;\par
\par
\par
  /**\par
   * Allows you to run func in the context of a different document.\par
   * @param \{!Document\} document The document to use.\par
   * @param \{function():*\} func The function to call.\par
   */\par
  function withDoc(document, func) \{\par
    var oldDoc = doc;\par
    doc = document;\par
    try \{\par
      func();\par
    \} finally \{\par
      doc = oldDoc;\par
    \}\par
  \}\par
\par
  /**\par
   * Adds a \{@code getInstance\} static method that always return the same\par
   * instance object.\par
   * @param \{!Function\} ctor The constructor for the class to add the static\par
   *     method to.\par
   */\par
  function addSingletonGetter(ctor) \{\par
    ctor.getInstance = function() \{\par
      return ctor.instance_ || (ctor.instance_ = new ctor());\par
    \};\par
  \}\par
\par
  return \{\par
    addSingletonGetter: addSingletonGetter,\par
    isChromeOS: isChromeOS,\par
    isMac: isMac,\par
    isWindows: isWindows,\par
    isLinux: isLinux,\par
    isViews: isViews,\par
    isTouchOptimized: isTouchOptimized,\par
    enablePlatformSpecificCSSRules: enablePlatformSpecificCSSRules,\par
    define: define,\par
    defineProperty: defineProperty,\par
    PropertyKind: PropertyKind,\par
    createUid: createUid,\par
    getUid: getUid,\par
    dispatchSimpleEvent: dispatchSimpleEvent,\par
    dispatchPropertyChange: dispatchPropertyChange,\par
\par
    /**\par
     * The document that we are currently using.\par
     * @type \{!Document\}\par
     */\par
    get doc() \{\par
      return doc;\par
    \},\par
    withDoc: withDoc,\par
    Event: CrEvent\par
  \};\par
\})();\par
</script>\par
<script>// Copyright (c) 2010 The Chromium Authors. All rights reserved.\par
// Use of this source code is governed by a BSD-style license that can be\par
// found in the LICENSE file.\par
\par
cr.define('cr.ui', function() \{\par
\par
  /**\par
   * Decorates elements as an instance of a class.\par
   * @param \{string|!Element\} source The way to find the element(s) to decorate.\par
   *     If this is a string then \{@code querySeletorAll\} is used to find the\par
   *     elements to decorate.\par
   * @param \{!Function\} constr The constructor to decorate with. The constr\par
   *     needs to have a \{@code decorate\} function.\par
   */\par
  function decorate(source, constr) \{\par
    var elements;\par
    if (typeof source == 'string')\par
      elements = cr.doc.querySelectorAll(source);\par
    else\par
      elements = [source];\par
\par
    for (var i = 0, el; el = elements[i]; i++) \{\par
      if (!(el instanceof constr))\par
        constr.decorate(el);\par
    \}\par
  \}\par
\par
  /**\par
   * Helper function for creating new element for define.\par
   */\par
  function createElementHelper(tagName, opt_bag) \{\par
    // Allow passing in ownerDocument to create in a different document.\par
    var doc;\par
    if (opt_bag && opt_bag.ownerDocument)\par
      doc = opt_bag.ownerDocument;\par
    else\par
      doc = cr.doc;\par
    return doc.createElement(tagName);\par
  \}\par
\par
  /**\par
   * Creates the constructor for a UI element class.\par
   *\par
   * Usage:\par
   * <pre>\par
   * var List = cr.ui.define('list');\par
   * List.prototype = \{\par
   *   __proto__: HTMLUListElement.prototype,\par
   *   decorate: function() \{\par
   *     ...\par
   *   \},\par
   *   ...\par
   * \};\par
   * </pre>\par
   *\par
   * @param \{string|Function\} tagNameOrFunction The tagName or\par
   *     function to use for newly created elements. If this is a function it\par
   *     needs to return a new element when called.\par
   * @return \{function(Object=):Element\} The constructor function which takes\par
   *     an optional property bag. The function also has a static\par
   *     \{@code decorate\} method added to it.\par
   */\par
  function define(tagNameOrFunction) \{\par
    var createFunction, tagName;\par
    if (typeof tagNameOrFunction == 'function') \{\par
      createFunction = tagNameOrFunction;\par
      tagName = '';\par
    \} else \{\par
      createFunction = createElementHelper;\par
      tagName = tagNameOrFunction;\par
    \}\par
\par
    /**\par
     * Creates a new UI element constructor.\par
     * @param \{Object=\} opt_propertyBag Optional bag of properties to set on the\par
     *     object after created. The property \{@code ownerDocument\} is special\par
     *     cased and it allows you to create the element in a different\par
     *     document than the default.\par
     * @constructor\par
     */\par
    function f(opt_propertyBag) \{\par
      var el = createFunction(tagName, opt_propertyBag);\par
      f.decorate(el);\par
      for (var propertyName in opt_propertyBag) \{\par
        el[propertyName] = opt_propertyBag[propertyName];\par
      \}\par
      return el;\par
    \}\par
\par
    /**\par
     * Decorates an element as a UI element class.\par
     * @param \{!Element\} el The element to decorate.\par
     */\par
    f.decorate = function(el) \{\par
      el.__proto__ = f.prototype;\par
      el.decorate();\par
    \};\par
\par
    return f;\par
  \}\par
\par
  /**\par
   * Input elements do not grow and shrink with their content. This is a simple\par
   * (and not very efficient) way of handling shrinking to content with support\par
   * for min width and limited by the width of the parent element.\par
   * @param \{HTMLElement\} el The element to limit the width for.\par
   * @param \{number\} parentEl The parent element that should limit the size.\par
   * @param \{number\} min The minimum width.\par
   */\par
  function limitInputWidth(el, parentEl, min) \{\par
    // Needs a size larger than borders\par
    el.style.width = '10px';\par
    var doc = el.ownerDocument;\par
    var win = doc.defaultView;\par
    var computedStyle = win.getComputedStyle(el);\par
    var parentComputedStyle = win.getComputedStyle(parentEl);\par
    var rtl = computedStyle.direction == 'rtl';\par
\par
    // To get the max width we get the width of the treeItem minus the position\par
    // of the input.\par
    var inputRect = el.getBoundingClientRect();  // box-sizing\par
    var parentRect = parentEl.getBoundingClientRect();\par
    var startPos = rtl ? parentRect.right - inputRect.right :\par
        inputRect.left - parentRect.left;\par
\par
    // Add up border and padding of the input.\par
    var inner = parseInt(computedStyle.borderLeftWidth, 10) +\par
        parseInt(computedStyle.paddingLeft, 10) +\par
        parseInt(computedStyle.paddingRight, 10) +\par
        parseInt(computedStyle.borderRightWidth, 10);\par
\par
    // We also need to subtract the padding of parent to prevent it to overflow.\par
    var parentPadding = rtl ? parseInt(parentComputedStyle.paddingLeft, 10) :\par
        parseInt(parentComputedStyle.paddingRight, 10);\par
\par
    var max = parentEl.clientWidth - startPos - inner - parentPadding;\par
\par
    function limit() \{\par
      if (el.scrollWidth > max) \{\par
        el.style.width = max + 'px';\par
      \} else \{\par
        el.style.width = 0;\par
        var sw = el.scrollWidth;\par
        if (sw < min) \{\par
          el.style.width = min + 'px';\par
        \} else \{\par
          el.style.width = sw + 'px';\par
        \}\par
      \}\par
    \}\par
\par
    el.addEventListener('input', limit);\par
    limit();\par
  \}\par
\par
  return \{\par
    decorate: decorate,\par
    define: define,\par
    limitInputWidth: limitInputWidth\par
  \};\par
\});\par
</script>\par
<script>// Copyright (c) 2011 The Chromium Authors. All rights reserved.\par
// Use of this source code is governed by a BSD-style license that can be\par
// found in the LICENSE file.\par
\par
// require: event_tracker.js\par
\par
cr.define('cr.ui', function() \{\par
\par
  // The arrow location specifies how the arrow and bubble are positioned in\par
  // relation to the anchor node.\par
  const ArrowLocation = \{\par
    // The arrow is positioned at the top and the start of the bubble. In left\par
    // to right mode this is the top left. The entire bubble is positioned below\par
    // the anchor node.\par
    TOP_START : "top-start",\par
    // The arrow is positioned at the top and the end of the bubble. In left to\par
    // right mode this is the top right. The entire bubble is positioned below\par
    // the anchor node.\par
    TOP_END : "top-end",\par
    // The arrow is positioned at the bottom and the start of the bubble. In\par
    // left to right mode this is the bottom left. The entire bubble is\par
    // positioned above the anchor node.\par
    BOTTOM_START : "bottom-start",\par
    // The arrow is positioned at the bottom and the end of the bubble. In\par
    // left to right mode this is the bottom right. The entire bubble is\par
    // positioned above the anchor node.\par
    BOTTOM_END : "bottom-end"\par
  \};\par
\par
  // The bubble alignment specifies the horizontal position of the bubble in\par
  // relation to the anchor node.\par
  const BubbleAlignment = \{\par
    // The bubble is positioned so that the tip of the arrow points to the\par
    // middle of the anchor node.\par
    ARROW_TO_MID_ANCHOR : "arrow-to-mid-anchor",\par
    // The bubble is positioned so that the edge nearest to the arrow is lined\par
    // up with the edge of the anchor node.\par
    BUBBLE_EDGE_TO_ANCHOR_EDGE : "bubble-edge-anchor-edge"\par
  \};\par
\par
  // The horizontal distance between the tip of the arrow and the start or the\par
  // end of the bubble (as specified by the arrow location).\par
  const ARROW_OFFSET_X = 30;\par
\par
  // The vertical distance between the tip of the arrow and the bottom or top of\par
  // the bubble (as specified by the arrow location). Note, if you change this\par
  // then you should also change the "top" and "bottom" values for .bubble-arrow\par
  // in bubble.css.\par
  const ARROW_OFFSET_Y = 8;\par
\par
  /**\par
   * Bubble is a free-floating informational bubble with a triangular arrow\par
   * that points at a place of interest on the page.\par
   */\par
  var Bubble = cr.ui.define('div');\par
\par
  Bubble.prototype = \{\par
    __proto__: HTMLDivElement.prototype,\par
\par
    decorate: function() \{\par
      this.className = 'bubble';\par
      this.innerHTML =\par
          '<div class=\\"bubble-contents\\"></div>' +\par
          '<div class=\\"bubble-close\\"></div>' +\par
          '<div class=\\"bubble-shadow\\"></div>' +\par
          '<div class=\\"bubble-arrow\\"></div>';\par
\par
      this.hidden = true;\par
      this.handleCloseEvent = this.hide;\par
      this.deactivateToDismissDelay_ = 0;\par
      this.bubbleAlignment = BubbleAlignment.ARROW_TO_MID_ANCHOR;\par
    \},\par
\par
    /**\par
     * Sets the child node of the bubble.\par
     * @param \{node\} An HTML element\par
     */\par
    set content(node) \{\par
      var bubbleContent = this.querySelector('.bubble-contents');\par
      bubbleContent.innerHTML = "";\par
      bubbleContent.appendChild(node);\par
    \},\par
\par
    /**\par
     * Handles close event which is triggered when the close button\par
     * is clicked. By default is set to this.hide.\par
     * @param \{function\} A function with no parameters\par
     */\par
    set handleCloseEvent(func) \{\par
      this.handleCloseEvent_ = func;\par
    \},\par
\par
    /**\par
     * Sets the anchor node, i.e. the node that this bubble points at.\par
     * @param \{HTMLElement\} node The new anchor node.\par
     */\par
    set anchorNode(node) \{\par
      this.anchorNode_ = node;\par
\par
      if (!this.hidden)\par
        this.reposition();\par
    \},\par
\par
    /**\par
     * Sets the arrow location.\par
     * @param \{cr.ui.ArrowLocation\} arrowLocation The new arrow location.\par
     */\par
    setArrowLocation: function(arrowLocation) \{\par
      this.isRight_ = arrowLocation == ArrowLocation.TOP_END ||\par
                      arrowLocation == ArrowLocation.BOTTOM_END;\par
      if (document.documentElement.dir == 'rtl')\par
        this.isRight_ = !this.isRight_;\par
      this.isTop_ = arrowLocation == ArrowLocation.TOP_START ||\par
                    arrowLocation == ArrowLocation.TOP_END;\par
\par
      var bubbleArrow = this.querySelector('.bubble-arrow');\par
      bubbleArrow.setAttribute('is-right', this.isRight_);\par
      bubbleArrow.setAttribute('is-top', this.isTop_);\par
\par
      if (!this.hidden)\par
        this.reposition();\par
    \},\par
\par
    /**\par
     * Sets the bubble alignment.\par
     * @param \{cr.ui.BubbleAlignment\} alignment The new bubble alignment.\par
     */\par
    set bubbleAlignment(alignment) \{\par
      this.bubbleAlignment_ = alignment;\par
    \},\par
\par
    /**\par
     * Sets the delay before the user is allowed to click outside the bubble\par
     * to dismiss it. Using a delay makes it less likely that the user will\par
     * unintentionally dismiss the bubble.\par
     * @param \{int\} delay The delay in miliseconds.\par
     */\par
    set deactivateToDismissDelay(delay) \{\par
      this.deactivateToDismissDelay_ = delay;\par
    \},\par
\par
    /**\par
     * Hides or shows the close button.\par
     * @param \{Boolean\} isVisible True if the close button should be visible.\par
     */\par
    setCloseButtonVisible: function(isVisible) \{\par
      this.querySelector('.bubble-close').hidden = !isVisible;\par
    \},\par
\par
    /**\par
     * Updates the position of the bubble. This is automatically called when\par
     * the window is resized, but should also be called any time the layout\par
     * may have changed.\par
     */\par
    reposition: function() \{\par
      var clientRect = this.anchorNode_.getBoundingClientRect();\par
\par
      var left;\par
      if (this.bubbleAlignment_ ==\par
          BubbleAlignment.BUBBLE_EDGE_TO_ANCHOR_EDGE) \{\par
        left = this.isRight_ ? clientRect.right - this.clientWidth :\par
            clientRect.left;\par
      \} else \{\par
        var anchorMid = (clientRect.left + clientRect.right) / 2;\par
        left = this.isRight_ ? anchorMid - this.clientWidth + ARROW_OFFSET_X :\par
            anchorMid - ARROW_OFFSET_X;\par
      \}\par
      var top = this.isTop_ ? clientRect.bottom + ARROW_OFFSET_Y :\par
          clientRect.top - this.clientHeight - ARROW_OFFSET_Y;\par
\par
      this.style.left = left + 'px';\par
      this.style.top = top + 'px';\par
    \},\par
\par
    /**\par
     * Starts showing the bubble. The bubble will show until the user clicks\par
     * away or presses Escape.\par
     */\par
    show: function() \{\par
      if (!this.hidden)\par
        return;\par
\par
      document.body.appendChild(this);\par
      this.hidden = false;\par
      this.reposition();\par
      this.showTime_ = Date.now();\par
\par
      this.eventTracker_ = new EventTracker;\par
      this.eventTracker_.add(window, 'resize', this.reposition.bind(this));\par
\par
      var doc = this.ownerDocument;\par
      this.eventTracker_.add(doc, 'keydown', this, true);\par
      this.eventTracker_.add(doc, 'mousedown', this, true);\par
    \},\par
\par
    /**\par
     * Hides the bubble from view.\par
     */\par
    hide: function() \{\par
      this.hidden = true;\par
      this.eventTracker_.removeAll();\par
      this.parentNode.removeChild(this);\par
    \},\par
\par
    /**\par
     * Handles keydown and mousedown events, dismissing the bubble if\par
     * necessary.\par
     * @param \{Event\} e The event.\par
     */\par
    handleEvent: function(e) \{\par
      switch (e.type) \{\par
        case 'keydown': \{\par
          if (e.keyCode == 27)  // Esc\par
            this.hide();\par
          break;\par
        \}\par
        case 'mousedown': \{\par
          if (e.target == this.querySelector('.bubble-close')) \{\par
            this.handleCloseEvent_();\par
          \} else if (!this.contains(e.target)) \{\par
            if (Date.now() - this.showTime_ < this.deactivateToDismissDelay_)\par
              return;\par
            this.hide();\par
          \} else \{\par
            return;\par
          \}\par
          break;\par
        \}\par
      \}\par
    \},\par
  \};\par
\par
  return \{\par
    ArrowLocation : ArrowLocation,\par
    Bubble : Bubble,\par
    BubbleAlignment : BubbleAlignment\par
  \};\par
\});\par
</script>\par
<script>// Copyright (c) 2012 The Chromium Authors. All rights reserved.\par
// Use of this source code is governed by a BSD-style license that can be\par
// found in the LICENSE file.\par
\par
/**\par
 * @fileoverview Card slider implementation. Allows you to create interactions\par
 * that have items that can slide left to right to reveal additional items.\par
 * Works by adding the necessary event handlers to a specific DOM structure\par
 * including a frame, container and cards.\par
 * - The frame defines the boundary of one item. Each card will be expanded to\par
 *   fill the width of the frame. This element is also overflow hidden so that\par
 *   the additional items left / right do not trigger horizontal scrolling.\par
 * - The container is what all the touch events are attached to. This element\par
 *   will be expanded to be the width of all cards.\par
 * - The cards are the individual viewable items. There should be one card for\par
 *   each item in the list. Only one card will be visible at a time. Two cards\par
 *   will be visible while you are transitioning between cards.\par
 *\par
 * This class is designed to work well on any hardware-accelerated touch device.\par
 * It should still work on pre-hardware accelerated devices it just won't feel\par
 * very good. It should also work well with a mouse.\par
 */\par
\par
// Use an anonymous function to enable strict mode just for this file (which\par
// will be concatenated with other files when embedded in Chrome\par
cr.define('cr.ui', function() \{\par
  'use strict';\par
\par
  /**\par
   * @constructor\par
   * @param \{!Element\} frame The bounding rectangle that cards are visible in.\par
   * @param \{!Element\} container The surrounding element that will have event\par
   *     listeners attached to it.\par
   * @param \{number\} cardWidth The width of each card should have.\par
   */\par
  function CardSlider(frame, container, cardWidth) \{\par
    /**\par
     * @type \{!Element\}\par
     * @private\par
     */\par
    this.frame_ = frame;\par
\par
    /**\par
     * @type \{!Element\}\par
     * @private\par
     */\par
    this.container_ = container;\par
\par
    /**\par
     * Array of card elements.\par
     * @type \{!Array.<!Element>\}\par
     * @private\par
     */\par
    this.cards_ = [];\par
\par
    /**\par
     * Index of currently shown card.\par
     * @type \{number\}\par
     * @private\par
     */\par
    this.currentCard_ = -1;\par
\par
    /**\par
     * @type \{number\}\par
     * @private\par
     */\par
    this.cardWidth_ = cardWidth;\par
\par
    /**\par
     * @type \{!cr.ui.TouchHandler\}\par
     * @private\par
     */\par
    this.touchHandler_ = new cr.ui.TouchHandler(this.container_);\par
  \}\par
\par
\par
  /**\par
   * The time to transition between cards when animating. Measured in ms.\par
   * @type \{number\}\par
   * @private\par
   * @const\par
   */\par
  CardSlider.TRANSITION_TIME_ = 200;\par
\par
\par
  /**\par
   * The minimum velocity required to transition cards if they did not drag past\par
   * the halfway point between cards. Measured in pixels / ms.\par
   * @type \{number\}\par
   * @private\par
   * @const\par
   */\par
  CardSlider.TRANSITION_VELOCITY_THRESHOLD_ = 0.2;\par
\par
\par
  CardSlider.prototype = \{\par
    /**\par
     * The current left offset of the container relative to the frame.\par
     * @type \{number\}\par
     * @private\par
     */\par
    currentLeft_: 0,\par
\par
    /**\par
     * Initialize all elements and event handlers. Must call after construction\par
     * and before usage.\par
     */\par
    initialize: function() \{\par
      var view = this.container_.ownerDocument.defaultView;\par
      assert(view.getComputedStyle(this.container_).display == '-webkit-box',\par
          'Container should be display -webkit-box.');\par
      assert(view.getComputedStyle(this.frame_).overflow == 'hidden',\par
          'Frame should be overflow hidden.');\par
      assert(view.getComputedStyle(this.container_).position == 'static',\par
          'Container should be position static.');\par
\par
      this.updateCardWidths_();\par
\par
      this.mouseWheelScrollAmount_ = 0;\par
      this.mouseWheelCardSelected_ = false;\par
      this.mouseWheelIsContinuous_ = false;\par
      this.scrollClearTimeout_ = null;\par
      this.frame_.addEventListener('mousewheel',\par
                                   this.onMouseWheel_.bind(this));\par
      this.container_.addEventListener(\par
          'webkitTransitionEnd', this.onWebkitTransitionEnd_.bind(this));\par
\par
      // Also support touch events in case a touch screen happens to be\par
      // available.  Ideally we would support touch events whenever they\par
      // are fired, but for now restrict this extra code to when we know\par
      // we want to support touch input.\par
      if (cr.isTouchOptimized) \{\par
        var TouchHandler = cr.ui.TouchHandler;\par
        this.container_.addEventListener(TouchHandler.EventType.TOUCH_START,\par
                                         this.onTouchStart_.bind(this));\par
        this.container_.addEventListener(TouchHandler.EventType.DRAG_START,\par
                                         this.onDragStart_.bind(this));\par
        this.container_.addEventListener(TouchHandler.EventType.DRAG_MOVE,\par
                                         this.onDragMove_.bind(this));\par
        this.container_.addEventListener(TouchHandler.EventType.DRAG_END,\par
                                         this.onDragEnd_.bind(this));\par
\par
        this.touchHandler_.enable(/* opt_capture */ false);\par
      \}\par
    \},\par
\par
    /**\par
     * Use in cases where the width of the frame has changed in order to update\par
     * the width of cards. For example should be used when orientation changes\par
     * in full width sliders.\par
     * @param \{number\} newCardWidth Width all cards should have, in pixels.\par
     */\par
    resize: function(newCardWidth) \{\par
      if (newCardWidth != this.cardWidth_) \{\par
        this.cardWidth_ = newCardWidth;\par
\par
        this.updateCardWidths_();\par
\par
        // Must upate the transform on the container to show the correct card.\par
        this.transformToCurrentCard_();\par
      \}\par
    \},\par
\par
    /**\par
     * Sets the cards used. Can be called more than once to switch card sets.\par
     * @param \{!Array.<!Element>\} cards The individual viewable cards.\par
     * @param \{number\} index Index of the card to in the new set of cards to\par
     *     navigate to.\par
     */\par
    setCards: function(cards, index) \{\par
      assert(index >= 0 && index < cards.length,\par
          'Invalid index in CardSlider#setCards');\par
      this.cards_ = cards;\par
\par
      this.updateCardWidths_();\par
\par
      // Jump to the given card index.\par
      this.selectCard(index);\par
    \},\par
\par
    /**\par
     * Updates the width of each card.\par
     * @private\par
     */\par
    updateCardWidths_: function() \{\par
      for (var i = 0, card; card = this.cards_[i]; i++)\par
        card.style.width = this.cardWidth_ + 'px';\par
    \},\par
\par
    /**\par
     * Returns the index of the current card.\par
     * @return \{number\} index of the current card.\par
     */\par
    get currentCard() \{\par
      return this.currentCard_;\par
    \},\par
\par
    /**\par
     * Allows setting the current card index.\par
     * @param \{number\} index A new index to set the current index to.\par
     * @return \{number\} The new index after having been set.\par
     */\par
    set currentCard(index) \{\par
      return (this.currentCard_ = index);\par
    \},\par
\par
    /**\par
     * Returns the number of cards.\par
     * @return \{number\} number of cards.\par
     */\par
    get cardCount() \{\par
      return this.cards_.length;\par
    \},\par
\par
    /**\par
     * Returns the current card itself.\par
     * @return \{!Element\} the currently shown card.\par
     */\par
    get currentCardValue() \{\par
      return this.cards_[this.currentCard_];\par
    \},\par
\par
    /**\par
     * Handle horizontal scrolls to flip between pages.\par
     * @private\par
     */\par
    onMouseWheel_: function(e) \{\par
      if (e.wheelDeltaX == 0)\par
        return;\par
\par
      // Prevent OS X 10.7+ history swiping on the NTP.\par
      e.preventDefault();\par
\par
      // Continuous devices such as an Apple Touchpad or Apple MagicMouse will\par
      // send arbitrary delta values. Conversly, standard mousewheels will\par
      // send delta values in increments of 120.  (There is of course a small\par
      // chance we mistake a continuous device for a non-continuous device.\par
      // Unfortunately there isn't a better way to do this until real touch\par
      // events are available to desktop clients.)\par
      var DISCRETE_DELTA = 120;\par
      if (e.wheelDeltaX % DISCRETE_DELTA)\par
        this.mouseWheelIsContinuous_ = true;\par
\par
      if (this.mouseWheelIsContinuous_) \{\par
        // For continuous devices, detect a page swipe when the accumulated\par
        // delta matches a pre-defined threshhold.  After changing the page,\par
        // ignore wheel events for a short time before repeating this process.\par
        if (this.mouseWheelCardSelected_) return;\par
        this.mouseWheelScrollAmount_ += e.wheelDeltaX;\par
        if (Math.abs(this.mouseWheelScrollAmount_) >= 600) \{\par
          var pagesToScroll = this.mouseWheelScrollAmount_ > 0 ? 1 : -1;\par
          if (!isRTL())\par
            pagesToScroll *= -1;\par
          var newCardIndex = this.currentCard + pagesToScroll;\par
          newCardIndex = Math.min(this.cards_.length - 1,\par
                                  Math.max(0, newCardIndex));\par
          this.selectCard(newCardIndex, true);\par
          this.mouseWheelCardSelected_ = true;\par
        \}\par
      \} else \{\par
        // For discrete devices, consider each wheel tick a page change.\par
        var pagesToScroll = e.wheelDeltaX / DISCRETE_DELTA;\par
        if (!isRTL())\par
          pagesToScroll *= -1;\par
        var newCardIndex = this.currentCard + pagesToScroll;\par
        newCardIndex = Math.min(this.cards_.length - 1,\par
                                Math.max(0, newCardIndex));\par
        this.selectCard(newCardIndex, true);\par
      \}\par
\par
      // We got a mouse wheel event, so cancel any pending scroll wheel timeout.\par
      if (this.scrollClearTimeout_ != null)\par
        clearTimeout(this.scrollClearTimeout_);\par
      // If we didn't use up all the scroll, hold onto it for a little bit, but\par
      // drop it after a delay.\par
      if (this.mouseWheelScrollAmount_ != 0) \{\par
        this.scrollClearTimeout_ =\par
            setTimeout(this.clearMouseWheelScroll_.bind(this), 500);\par
      \}\par
    \},\par
\par
    /**\par
     * Resets the amount of horizontal scroll we've seen to 0. See\par
     * onMouseWheel_.\par
     * @private\par
     */\par
    clearMouseWheelScroll_: function() \{\par
      this.mouseWheelScrollAmount_ = 0;\par
      this.mouseWheelCardSelected_ = false;\par
    \},\par
\par
    /**\par
     * Handles the ends of -webkit-transitions on -webkit-transform (animated\par
     * card switches).\par
     * @param \{Event\} e The webkitTransitionEnd event.\par
     * @private\par
     */\par
    onWebkitTransitionEnd_: function(e) \{\par
      // Ignore irrelevant transitions that might bubble up.\par
      if (e.target !== this.container_ ||\par
          e.propertyName != '-webkit-transform') \{\par
        return;\par
      \}\par
      this.fireChangeEndedEvent_(true);\par
    \},\par
\par
    /**\par
     * Dispatches a simple event to tell subscribers we're done moving to the\par
     * newly selected card.\par
     * @param \{boolean\} wasAnimated whether or not the change was animated.\par
     * @private\par
     */\par
    fireChangeEndedEvent_: function(wasAnimated) \{\par
      var e = document.createEvent('Event');\par
      e.initEvent('cardSlider:card_change_ended', true, true);\par
      e.cardSlider = this;\par
      e.changedTo = this.currentCard_;\par
      e.wasAnimated = wasAnimated;\par
      this.container_.dispatchEvent(e);\par
    \},\par
\par
    /**\par
     * Add a card to the card slider at a particular index. If the card being\par
     * added is inserted in front of the current card, cardSlider.currentCard\par
     * will be adjusted accordingly (to current card + 1).\par
     * @param \{!Node\} card A card that will be added to the card slider.\par
     * @param \{number\} index An index at which the given |card| should be\par
     *     inserted. Must be positive and less than the number of cards.\par
     */\par
    addCardAtIndex: function(card, index) \{\par
      assert(card instanceof Node, '|card| isn\\'t a Node');\par
      this.assertValidIndex_(index);\par
      this.cards_ = Array.prototype.concat.call(\par
          this.cards_.slice(0, index), card, this.cards_.slice(index));\par
\par
      if (this.currentCard_ == -1)\par
        this.currentCard_ = 0;\par
      else if (index <= this.currentCard_)\par
        this.selectCard(this.currentCard_ + 1, false, true);\par
\par
      this.fireAddedEvent_(card, index);\par
    \},\par
\par
    /**\par
     * Append a card to the end of the list.\par
     * @param \{!Node\} card A card to add at the end of the card slider.\par
     */\par
    appendCard: function(card) \{\par
      assert(card instanceof Node, '|card| isn\\'t a Node');\par
      this.cards_.push(card);\par
      this.fireAddedEvent_(card, this.cards_.length - 1);\par
    \},\par
\par
    /**\par
     * Dispatches a simple event to tell interested subscribers that a card was\par
     * added to this card slider.\par
     * @param \{Node\} card The recently added card.\par
     * @param \{number\} index The position of the newly added card.\par
     * @private\par
     */\par
    fireAddedEvent_: function(card, index) \{\par
      this.assertValidIndex_(index);\par
      var e = document.createEvent('Event');\par
      e.initEvent('cardSlider:card_added', true, true);\par
      e.addedIndex = index;\par
      e.addedCard = card;\par
      this.container_.dispatchEvent(e);\par
    \},\par
\par
    /**\par
     * Removes a card by index from the card slider. If the card to be removed\par
     * is the current card or in front of the current card, the current card\par
     * will be updated (to current card - 1).\par
     * @param \{!Node\} card A card to be removed.\par
     */\par
    removeCard: function(card) \{\par
      assert(card instanceof Node, '|card| isn\\'t a Node');\par
      this.removeCardAtIndex(this.cards_.indexOf(card));\par
    \},\par
\par
    /**\par
     * Removes a card by index from the card slider. If the card to be removed\par
     * is the current card or in front of the current card, the current card\par
     * will be updated (to current card - 1).\par
     * @param \{number\} index The index of the tile that should be removed.\par
     */\par
    removeCardAtIndex: function(index) \{\par
      this.assertValidIndex_(index);\par
      var removed = this.cards_.splice(index, 1).pop();\par
\par
      if (this.cards_.length == 0)\par
        this.currentCard_ = -1;\par
      else if (index < this.currentCard_)\par
        this.selectCard(this.currentCard_ - 1, false, true);\par
\par
      this.fireRemovedEvent_(removed, index);\par
    \},\par
\par
    /**\par
     * Dispatches a cardSlider:card_removed event so interested subscribers know\par
     * when a card was removed from this card slider.\par
     * @param \{Node\} card The recently removed card.\par
     * @param \{number\} index The index of the card before it was removed.\par
     * @private\par
     */\par
    fireRemovedEvent_: function(card, index) \{\par
      var e = document.createEvent('Event');\par
      e.initEvent('cardSlider:card_removed', true, true);\par
      e.removedCard = card;\par
      e.removedIndex = index;\par
      this.container_.dispatchEvent(e);\par
    \},\par
\par
    /**\par
     * Checks the the given |index| exists in this.cards_.\par
     * @param \{number\} index An index to check.\par
     * @private\par
     */\par
    assertValidIndex_: function(index) \{\par
      assert(index >= 0 && index < this.cards_.length);\par
    \},\par
\par
    /**\par
     * Selects a new card, ensuring that it is a valid index, transforming the\par
     * view and possibly calling the change card callback.\par
     * @param \{number\} newCardIndex Index of card to show.\par
     * @param \{boolean=\} opt_animate If true will animate transition from\par
     *     current position to new position.\par
     * @param \{boolean=\} opt_dontNotify If true, don't tell subscribers that\par
     *     we've changed cards.\par
     */\par
    selectCard: function(newCardIndex, opt_animate, opt_dontNotify) \{\par
      this.assertValidIndex_(newCardIndex);\par
\par
      var previousCard = this.currentCardValue;\par
      var isChangingCard =\par
          !this.cards_[newCardIndex].classList.contains('selected-card');\par
\par
      if (isChangingCard) \{\par
        if (previousCard)\par
          previousCard.classList.remove('selected-card');\par
        this.currentCard_ = newCardIndex;\par
        this.currentCardValue.classList.add('selected-card');\par
      \}\par
\par
      var willTransitionHappen = this.transformToCurrentCard_(opt_animate);\par
\par
      if (isChangingCard && !opt_dontNotify) \{\par
        var event = document.createEvent('Event');\par
        event.initEvent('cardSlider:card_changed', true, true);\par
        event.cardSlider = this;\par
        event.wasAnimated = !!opt_animate;\par
        this.container_.dispatchEvent(event);\par
\par
        // We also dispatch an event on the cards themselves.\par
        if (previousCard) \{\par
          cr.dispatchSimpleEvent(previousCard, 'carddeselected',\par
                                 true, true);\par
        \}\par
        cr.dispatchSimpleEvent(this.currentCardValue, 'cardselected',\par
                               true, true);\par
      \}\par
\par
      // If we're not changing, animated, or transitioning, fire a\par
      // cardSlider:card_change_ended event right away.\par
      if ((!isChangingCard || !opt_animate || !willTransitionHappen) &&\par
          !opt_dontNotify) \{\par
        this.fireChangeEndedEvent_(false);\par
      \}\par
    \},\par
\par
    /**\par
     * Selects a card from the stack. Passes through to selectCard.\par
     * @param \{Node\} newCard The card that should be selected.\par
     * @param \{boolean=\} opt_animate Whether to animate.\par
     */\par
    selectCardByValue: function(newCard, opt_animate) \{\par
      var i = this.cards_.indexOf(newCard);\par
      assert(i != -1);\par
      this.selectCard(i, opt_animate);\par
    \},\par
\par
    /**\par
     * Centers the view on the card denoted by this.currentCard. Can either\par
     * animate to that card or snap to it.\par
     * @param \{boolean=\} opt_animate If true will animate transition from\par
     *     current position to new position.\par
     * @return \{boolean\} Whether or not a transformation was necessary.\par
     * @private\par
     */\par
    transformToCurrentCard_: function(opt_animate) \{\par
      var prevLeft = this.currentLeft_;\par
      this.currentLeft_ = -this.cardWidth_ *\par
          (isRTL() ? this.cards_.length - this.currentCard - 1 :\par
                     this.currentCard);\par
\par
      // If there's no change, return something to let the caller know there\par
      // won't be a transition occuring.\par
      if (prevLeft == this.currentLeft_)\par
        return false;\par
\par
      // Animate to the current card, which will either transition if the\par
      // current card is new, or reset the existing card if we didn't drag\par
      // enough to change cards.\par
      var transition = '';\par
      if (opt_animate) \{\par
        transition = '-webkit-transform ' + CardSlider.TRANSITION_TIME_ +\par
                     'ms ease-in-out';\par
      \}\par
      this.container_.style.WebkitTransition = transition;\par
      this.translateTo_(this.currentLeft_);\par
\par
      return true;\par
    \},\par
\par
    /**\par
     * Moves the view to the specified position.\par
     * @param \{number\} x Horizontal position to move to.\par
     * @private\par
     */\par
    translateTo_: function(x) \{\par
      // We use a webkitTransform to slide because this is GPU accelerated on\par
      // Chrome and iOS.  Once Chrome does GPU acceleration on the position\par
      // fixed-layout elements we could simply set the element's position to\par
      // fixed and modify 'left' instead.\par
      this.container_.style.WebkitTransform = 'translate3d(' + x + 'px, 0, 0)';\par
    \},\par
\par
    /* Touch ******************************************************************/\par
\par
    /**\par
     * Clear any transition that is in progress and enable dragging for the\par
     * touch.\par
     * @param \{!cr.ui.TouchHandler.Event\} e The TouchHandler event.\par
     * @private\par
     */\par
    onTouchStart_: function(e) \{\par
      this.container_.style.WebkitTransition = '';\par
      e.enableDrag = true;\par
    \},\par
\par
    /**\par
     * Tell the TouchHandler that dragging is acceptable when the user begins by\par
     * scrolling horizontally.\par
     * @param \{!cr.ui.TouchHandler.Event\} e The TouchHandler event.\par
     * @private\par
     */\par
    onDragStart_: function(e) \{\par
      e.enableDrag = Math.abs(e.dragDeltaX) > Math.abs(e.dragDeltaY);\par
    \},\par
\par
    /**\par
     * On each drag move event reposition the container appropriately so the\par
     * cards look like they are sliding.\par
     * @param \{!cr.ui.TouchHandler.Event\} e The TouchHandler event.\par
     * @private\par
     */\par
    onDragMove_: function(e) \{\par
      var deltaX = e.dragDeltaX;\par
      // If dragging beyond the first or last card then apply a backoff so the\par
      // dragging feels stickier than usual.\par
      if (!this.currentCard && deltaX > 0 ||\par
          this.currentCard == (this.cards_.length - 1) && deltaX < 0) \{\par
        deltaX /= 2;\par
      \}\par
      this.translateTo_(this.currentLeft_ + deltaX);\par
    \},\par
\par
    /**\par
     * On drag end events we may want to transition to another card, depending\par
     * on the ending position of the drag and the velocity of the drag.\par
     * @param \{!cr.ui.TouchHandler.Event\} e The TouchHandler event.\par
     * @private\par
     */\par
    onDragEnd_: function(e) \{\par
      var deltaX = e.dragDeltaX;\par
      var velocity = this.touchHandler_.getEndVelocity().x;\par
      var newX = this.currentLeft_ + deltaX;\par
      var newCardIndex = Math.round(-newX / this.cardWidth_);\par
\par
      if (newCardIndex == this.currentCard && Math.abs(velocity) >\par
          CardSlider.TRANSITION_VELOCITY_THRESHOLD_) \{\par
        // If the drag wasn't far enough to change cards but the velocity was\par
        // high enough to transition anyways. If the velocity is to the left\par
        // (negative) then the user wishes to go right (card +1).\par
        newCardIndex += velocity > 0 ? -1 : 1;\par
      \}\par
\par
      this.selectCard(newCardIndex, /* animate */ true);\par
    \},\par
\par
    /**\par
     * Cancel any current touch/slide as if we saw a touch end\par
     */\par
    cancelTouch: function() \{\par
      // Stop listening to any current touch\par
      this.touchHandler_.cancelTouch();\par
\par
      // Ensure we're at a card bounary\par
      this.transformToCurrentCard_(true);\par
    \},\par
  \};\par
\par
  return \{\par
    CardSlider: CardSlider\par
  \};\par
\});\par
</script>\par
<script>// Copyright (c) 2012 The Chromium Authors. All rights reserved.\par
// Use of this source code is governed by a BSD-style license that can be\par
// found in the LICENSE file.\par
\par
cr.define('cr.ui', function() \{\par
\par
  const Menu = cr.ui.Menu;\par
\par
  /**\par
   * Handles context menus.\par
   * @constructor\par
   */\par
  function ContextMenuHandler() \{\}\par
\par
  ContextMenuHandler.prototype = \{\par
\par
    /**\par
     * The menu that we are currently showing.\par
     * @type \{cr.ui.Menu\}\par
     */\par
    menu_: null,\par
    get menu() \{\par
      return this.menu_;\par
    \},\par
\par
    /**\par
     * Shows a menu as a context menu.\par
     * @param \{!Event\} e The event triggering the show (usally a contextmenu\par
     *     event).\par
     * @param \{!cr.ui.Menu\} menu The menu to show.\par
     */\par
    showMenu: function(e, menu) \{\par
      this.menu_ = menu;\par
\par
      menu.style.display = 'block';\par
      // when the menu is shown we steal all keyboard events.\par
      var doc = menu.ownerDocument;\par
      doc.addEventListener('keydown', this, true);\par
      doc.addEventListener('mousedown', this, true);\par
      doc.addEventListener('blur', this, true);\par
      doc.defaultView.addEventListener('resize', this);\par
      menu.addEventListener('contextmenu', this);\par
      menu.addEventListener('activate', this);\par
      this.positionMenu_(e, menu);\par
    \},\par
\par
    /**\par
     * Hide the currently shown menu.\par
     */\par
    hideMenu: function() \{\par
      var menu = this.menu;\par
      if (!menu)\par
        return;\par
\par
      menu.style.display = 'none';\par
      var doc = menu.ownerDocument;\par
      doc.removeEventListener('keydown', this, true);\par
      doc.removeEventListener('mousedown', this, true);\par
      doc.removeEventListener('blur', this, true);\par
      doc.defaultView.removeEventListener('resize', this);\par
      menu.removeEventListener('contextmenu', this);\par
      menu.removeEventListener('activate', this);\par
      menu.selectedIndex = -1;\par
      this.menu_ = null;\par
\par
      // On windows we might hide the menu in a right mouse button up and if\par
      // that is the case we wait some short period before we allow the menu\par
      // to be shown again.\par
      this.hideTimestamp_ = cr.isWindows ? Date.now() : 0;\par
    \},\par
\par
    /**\par
     * Positions the menu\par
     * @param \{!Event\} e The event object triggering the showing.\par
     * @param \{!cr.ui.Menu\} menu The menu to position.\par
     * @private\par
     */\par
    positionMenu_: function(e, menu) \{\par
      // TODO(arv): Handle scrolled documents when needed.\par
\par
      var element = e.currentTarget;\par
      var x, y;\par
      // When the user presses the context menu key (on the keyboard) we need\par
      // to detect this.\par
      if (this.keyIsDown_) \{\par
        var rect = element.getRectForContextMenu ?\par
                       element.getRectForContextMenu() :\par
                       element.getBoundingClientRect();\par
        var offset = Math.min(rect.width, rect.height) / 2;\par
        x = rect.left + offset;\par
        y = rect.top + offset;\par
      \} else \{\par
        x = e.clientX;\par
        y = e.clientY;\par
      \}\par
\par
      cr.ui.positionPopupAtPoint(x, y, menu);\par
    \},\par
\par
    /**\par
     * Handles event callbacks.\par
     * @param \{!Event\} e The event object.\par
     */\par
    handleEvent: function(e) \{\par
      // Keep track of keydown state so that we can use that to determine the\par
      // reason for the contextmenu event.\par
      switch (e.type) \{\par
        case 'keydown':\par
          this.keyIsDown_ = !e.ctrlKey && !e.altKey &&\par
              // context menu key or Shift-F10\par
              (e.keyCode == 93 && !e.shiftKey ||\par
               e.keyIdentifier == 'F10' && e.shiftKey);\par
          break;\par
\par
        case 'keyup':\par
          this.keyIsDown_ = false;\par
          break;\par
      \}\par
\par
      // Context menu is handled even when we have no menu.\par
      if (e.type != 'contextmenu' && !this.menu)\par
        return;\par
\par
      switch (e.type) \{\par
        case 'mousedown':\par
          if (!this.menu.contains(e.target))\par
            this.hideMenu();\par
          else\par
            e.preventDefault();\par
          break;\par
        case 'keydown':\par
          // keyIdentifier does not report 'Esc' correctly\par
          if (e.keyCode == 27 /* Esc */) \{\par
            this.hideMenu();\par
            e.stopPropagation();\par
            e.preventDefault();\par
\par
          // If the menu is visible we let it handle all the keyboard events.\par
          \} else if (this.menu) \{\par
            this.menu.handleKeyDown(e);\par
            e.preventDefault();\par
            e.stopPropagation();\par
          \}\par
          break;\par
\par
        case 'activate':\par
        case 'blur':\par
        case 'resize':\par
          this.hideMenu();\par
          break;\par
\par
        case 'contextmenu':\par
          if ((!this.menu || !this.menu.contains(e.target)) &&\par
              (!this.hideTimestamp_ || Date.now() - this.hideTimestamp_ > 50))\par
            this.showMenu(e, e.currentTarget.contextMenu);\par
          e.preventDefault();\par
          // Don't allow elements further up in the DOM to show their menus.\par
          e.stopPropagation();\par
          break;\par
      \}\par
    \},\par
\par
    /**\par
     * Adds a contextMenu property to an element or element class.\par
     * @param \{!Element|!Function\} element The element or class to add the\par
     *     contextMenu property to.\par
     */\par
    addContextMenuProperty: function(element) \{\par
      if (typeof element == 'function')\par
        element = element.prototype;\par
\par
      element.__defineGetter__('contextMenu', function() \{\par
        return this.contextMenu_;\par
      \});\par
      element.__defineSetter__('contextMenu', function(menu) \{\par
        var oldContextMenu = this.contextMenu;\par
\par
        if (typeof menu == 'string' && menu[0] == '#') \{\par
          menu = this.ownerDocument.getElementById(menu.slice(1));\par
          cr.ui.decorate(menu, Menu);\par
        \}\par
\par
        if (menu === oldContextMenu)\par
          return;\par
\par
        if (oldContextMenu && !menu) \{\par
          this.removeEventListener('contextmenu', contextMenuHandler);\par
          this.removeEventListener('keydown', contextMenuHandler);\par
          this.removeEventListener('keyup', contextMenuHandler);\par
        \}\par
        if (menu && !oldContextMenu) \{\par
          this.addEventListener('contextmenu', contextMenuHandler);\par
          this.addEventListener('keydown', contextMenuHandler);\par
          this.addEventListener('keyup', contextMenuHandler);\par
        \}\par
\par
        this.contextMenu_ = menu;\par
\par
        if (menu && menu.id)\par
          this.setAttribute('contextmenu', '#' + menu.id);\par
\par
        cr.dispatchPropertyChange(this, 'contextMenu', menu, oldContextMenu);\par
      \});\par
\par
      if (!element.getRectForContextMenu) \{\par
        /**\par
         * @return \{!ClientRect\} The rect to use for positioning the context\par
         *     menu when the context menu is not opened using a mouse position.\par
         */\par
        element.getRectForContextMenu = function() \{\par
          return this.getBoundingClientRect();\par
        \};\par
      \}\par
    \},\par
\par
    /**\par
     * Sets the given contextMenu to the given element. A contextMenu property\par
     * would be added if necessary.\par
     * @param \{!Element\} element The element or class to set the contextMenu to.\par
     * @param \{!cr.ui.Menu\} contextMenu The contextMenu property to be set.\par
     */\par
    setContextMenu: function(element, contextMenu) \{\par
      if (!element.contextMenu)\par
        this.addContextMenuProperty(element);\par
      element.contextMenu = contextMenu;\par
    \}\par
  \};\par
\par
  /**\par
   * The singleton context menu handler.\par
   * @type \{!ContextMenuHandler\}\par
   */\par
  var contextMenuHandler = new ContextMenuHandler;\par
\par
  // Export\par
  return \{\par
    contextMenuHandler: contextMenuHandler\par
  \};\par
\});\par
</script>\par
<script>// Copyright (c) 2011 The Chromium Authors. All rights reserved.\par
// Use of this source code is governed by a BSD-style license that can be\par
// found in the LICENSE file.\par
\par
/**\par
 * @fileoverview DragWrapper\par
 * A class for simplifying HTML5 drag and drop. Classes should use this to\par
 * handle the nitty gritty of nested drag enters and leaves.\par
 */\par
cr.define('cr.ui', function() \{\par
  /**\par
   * Creates a DragWrapper which listens for drag target events on |target| and\par
   * delegates event handling to |handler|. The |handler| must implement:\par
   *   shouldAcceptDrag\par
   *   doDragEnter\par
   *   doDragLeave\par
   *   doDragOver\par
   *   doDrop\par
   */\par
  function DragWrapper(target, handler) \{\par
    this.initialize(target, handler);\par
  \}\par
\par
  DragWrapper.prototype = \{\par
    initialize: function(target, handler) \{\par
      target.addEventListener('dragenter',\par
                              this.onDragEnter_.bind(this));\par
      target.addEventListener('dragover', this.onDragOver_.bind(this));\par
      target.addEventListener('drop', this.onDrop_.bind(this));\par
      target.addEventListener('dragleave', this.onDragLeave_.bind(this));\par
\par
      this.target_ = target;\par
      this.handler_ = handler;\par
    \},\par
\par
    /**\par
     * The number of un-paired dragenter events that have fired on |this|. This\par
     * is incremented by |onDragEnter_| and decremented by |onDragLeave_|. This\par
     * is necessary because dragging over child widgets will fire additional\par
     * enter and leave events on |this|. A non-zero value does not necessarily\par
     * indicate that |isCurrentDragTarget()| is true.\par
     * @type \{number\}\par
     * @private\par
     */\par
    dragEnters_: 0,\par
\par
    /**\par
     * Whether the tile page is currently being dragged over with data it can\par
     * accept.\par
     * @type \{boolean\}\par
     */\par
    get isCurrentDragTarget() \{\par
      return this.target_.classList.contains('drag-target');\par
    \},\par
\par
    /**\par
     * Handler for dragenter events fired on |target_|.\par
     * @param \{Event\} e A MouseEvent for the drag.\par
     * @private\par
     */\par
    onDragEnter_: function(e) \{\par
      if (++this.dragEnters_ == 1) \{\par
        if (this.handler_.shouldAcceptDrag(e)) \{\par
          this.target_.classList.add('drag-target');\par
          this.handler_.doDragEnter(e);\par
        \}\par
      \} else \{\par
        // Sometimes we'll get an enter event over a child element without an\par
        // over event following it. In this case we have to still call the\par
        // drag over handler so that we make the necessary updates (one visible\par
        // symptom of not doing this is that the cursor's drag state will\par
        // flicker during drags).\par
        this.onDragOver_(e);\par
      \}\par
    \},\par
\par
    /**\par
     * Thunk for dragover events fired on |target_|.\par
     * @param \{Event\} e A MouseEvent for the drag.\par
     * @private\par
     */\par
    onDragOver_: function(e) \{\par
      if (!this.target_.classList.contains('drag-target'))\par
        return;\par
      this.handler_.doDragOver(e);\par
    \},\par
\par
    /**\par
     * Thunk for drop events fired on |target_|.\par
     * @param \{Event\} e A MouseEvent for the drag.\par
     * @private\par
     */\par
    onDrop_: function(e) \{\par
      this.dragEnters_ = 0;\par
      if (!this.target_.classList.contains('drag-target'))\par
        return;\par
      this.target_.classList.remove('drag-target');\par
      this.handler_.doDrop(e);\par
    \},\par
\par
    /**\par
     * Thunk for dragleave events fired on |target_|.\par
     * @param \{Event\} e A MouseEvent for the drag.\par
     * @private\par
     */\par
    onDragLeave_: function(e) \{\par
      if (--this.dragEnters_ > 0)\par
        return;\par
\par
      this.target_.classList.remove('drag-target');\par
      this.handler_.doDragLeave(e);\par
    \},\par
  \};\par
\par
  return \{\par
    DragWrapper: DragWrapper\par
  \};\par
\});\par
</script>\par
<script>// Copyright (c) 2012 The Chromium Authors. All rights reserved.\par
// Use of this source code is governed by a BSD-style license that can be\par
// found in the LICENSE file.\par
\par
// require: event_tracker.js\par
\par
cr.define('cr.ui', function() \{\par
  'use strict';\par
\par
  /**\par
   * ExpandableBubble is a free-floating compact informational bubble with an\par
   * arrow that points at a place of interest on the page. When clicked, the\par
   * bubble expands to show more of its content. Width of the bubble is the\par
   * width of the node it is overlapping when unexpanded. Expanded, it is of a\par
   * fixed width, but variable height. Currently the arrow is always positioned\par
   * at the bottom right and points down.\par
   * @constructor\par
   * @extends \{cr.ui.div\}\par
   */\par
  var ExpandableBubble = cr.ui.define('div');\par
\par
  ExpandableBubble.prototype = \{\par
    __proto__: HTMLDivElement.prototype,\par
\par
    /** @inheritDoc */\par
    decorate: function() \{\par
      this.className = 'expandable-bubble';\par
      this.innerHTML =\par
          '<div class="expandable-bubble-contents">' +\par
            '<div class="expandable-bubble-title"></div>' +\par
            '<div class="expandable-bubble-main" hidden></div>' +\par
          '</div>' +\par
          '<div class="expandable-bubble-close" hidden></div>';\par
\par
      this.hidden = true;\par
      this.bubbleSuppressed = false;\par
      this.handleCloseEvent = this.hide;\par
    \},\par
\par
    /**\par
     * Sets the title of the bubble. The title is always visible when the\par
     * bubble is visible.\par
     * @type \{Node\} An HTML element to set as the title.\par
     */\par
    set contentTitle(node) \{\par
      var bubbleTitle = this.querySelector('.expandable-bubble-title');\par
      bubbleTitle.textContent = '';\par
      bubbleTitle.appendChild(node);\par
    \},\par
\par
    /**\par
     * Sets the content node of the bubble. The content node is only visible\par
     * when the bubble is expanded.\par
     * @param \{Node\} An HTML element.\par
     */\par
    set content(node) \{\par
      var bubbleMain = this.querySelector('.expandable-bubble-main');\par
      bubbleMain.textContent = '';\par
      bubbleMain.appendChild(node);\par
    \},\par
\par
    /**\par
     * Sets the anchor node, i.e. the node that this bubble points at and\par
     * partially overlaps.\par
     * @param \{HTMLElement\} node The new anchor node.\par
     */\par
    set anchorNode(node) \{\par
      this.anchorNode_ = node;\par
\par
      if (!this.hidden)\par
        this.resizeAndReposition();\par
    \},\par
\par
    /**\par
     * Handles the close event which is triggered when the close button\par
     * is clicked. By default is set to this.hide.\par
     * @param \{function\} A function with no parameters\par
     */\par
    set handleCloseEvent(func) \{\par
      this.handleCloseEvent_ = func;\par
    \},\par
\par
    /**\par
     * Temporarily suppresses the bubble from view (and toggles it back).\par
     * 'Suppressed' and 'hidden' are two bubble states that both indicate that\par
     * the bubble should not be visible, but when you 'un-suppress' a bubble,\par
     * only a suppressed bubble becomes visible. This can be handy, for example,\par
     * if the user switches away from the app card (then we need to know which\par
     * bubbles to show (only the suppressed ones, not the hidden ones). Hiding\par
     * and un-hiding a bubble overrides the suppressed state (a bubble cannot\par
     * be suppressed but not hidden).\par
     */\par
    set suppressed(suppress) \{\par
      if (suppress) \{\par
        // If the bubble is already hidden, then we don't need to suppress it.\par
        if (this.hidden)\par
          return;\par
\par
        this.hidden = true;\par
      \} else if (this.bubbleSuppressed) \{\par
        this.hidden = false;\par
      \}\par
      this.bubbleSuppressed = suppress;\par
      this.resizeAndReposition(this);\par
    \},\par
\par
    /**\par
     * Updates the position of the bubble.\par
     * @private\par
     */\par
    reposition_: function() \{\par
      var clientRect = this.anchorNode_.getBoundingClientRect();\par
\par
      // Center bubble in collapsed mode (if it doesn't take up all the room we\par
      // have).\par
      var offset = 0;\par
      if (!this.expanded)\par
        offset = (clientRect.width - parseInt(this.style.width)) / 2;\par
      this.style.left = this.style.right = clientRect.left + offset + 'px';\par
\par
      var top = Math.max(0, clientRect.top - 4);\par
      this.style.top = this.expanded ?\par
          (top - this.offsetHeight + this.unexpandedHeight) + 'px' :\par
          top + 'px';\par
    \},\par
\par
    /**\par
     * Resizes the bubble and then repositions it.\par
     * @private\par
     */\par
    resizeAndReposition: function() \{\par
      var clientRect = this.anchorNode_.getBoundingClientRect();\par
      var width = clientRect.width;\par
\par
      var bubbleTitle = this.querySelector('.expandable-bubble-title');\par
      var closeElement = this.querySelector('.expandable-bubble-close');\par
      var closeWidth = this.expanded ? closeElement.clientWidth : 0;\par
      var margin = 15;\par
\par
      // Suppress the width style so we can get it to calculate its width.\par
      // We'll set the right width again when we are done.\par
      bubbleTitle.style.width = '';\par
\par
      if (this.expanded) \{\par
        // We always show the full title but never show less width than 250\par
        // pixels.\par
        var expandedWidth =\par
            Math.max(250, bubbleTitle.scrollWidth + closeWidth + margin);\par
        this.style.marginLeft = (width - expandedWidth) + 'px';\par
        width = expandedWidth;\par
      \} else \{\par
        var newWidth = Math.min(bubbleTitle.scrollWidth + margin, width);\par
        // If we've maxed out in width then apply the mask.\par
        this.masked = newWidth == width;\par
        width = newWidth;\par
        this.style.marginLeft = '0';\par
      \}\par
\par
      // Width is determined by the width of the title (when not expanded) but\par
      // capped to the width of the anchor node.\par
      this.style.width = width + 'px';\par
      bubbleTitle.style.width = Math.max(0, width - margin - closeWidth) + 'px';\par
\par
      // Also reposition the bubble -- dimensions have potentially changed.\par
      this.reposition_();\par
    \},\par
\par
    /*\par
     * Expand the bubble (bringing the full content into view).\par
     * @private\par
     */\par
    expandBubble_: function() \{\par
      this.querySelector('.expandable-bubble-main').hidden = false;\par
      this.querySelector('.expandable-bubble-close').hidden = false;\par
      this.expanded = true;\par
      this.resizeAndReposition();\par
    \},\par
\par
    /**\par
     * Collapse the bubble, hiding the main content and the close button.\par
     * This is automatically called when the window is resized.\par
     * @private\par
     */\par
    collapseBubble_: function() \{\par
      this.querySelector('.expandable-bubble-main').hidden = true;\par
      this.querySelector('.expandable-bubble-close').hidden = true;\par
      this.expanded = false;\par
      this.resizeAndReposition();\par
    \},\par
\par
    /**\par
     * The onclick handler for the notification (expands the bubble).\par
     * @param \{Event\} e The event.\par
     * @private\par
     */\par
    onNotificationClick_ : function(e) \{\par
      if (!this.contains(e.target))\par
        return;\par
\par
      if (!this.expanded) \{\par
        // Save the height of the unexpanded bubble, so we can make sure to\par
        // position it correctly (arrow points in the same location) after\par
        // we expand it.\par
        this.unexpandedHeight = this.offsetHeight;\par
      \}\par
\par
      this.expandBubble_();\par
    \},\par
\par
    /**\par
     * Shows the bubble. The bubble will start collapsed and expand when\par
     * clicked.\par
     */\par
    show: function() \{\par
      if (!this.hidden)\par
        return;\par
\par
      document.body.appendChild(this);\par
      this.hidden = false;\par
      this.resizeAndReposition();\par
\par
      this.eventTracker_ = new EventTracker;\par
      this.eventTracker_.add(window,\par
                             'load', this.resizeAndReposition.bind(this));\par
      this.eventTracker_.add(window,\par
                             'resize', this.resizeAndReposition.bind(this));\par
      this.eventTracker_.add(this, 'click', this.onNotificationClick_);\par
\par
      var doc = this.ownerDocument;\par
      this.eventTracker_.add(doc, 'keydown', this, true);\par
      this.eventTracker_.add(doc, 'mousedown', this, true);\par
    \},\par
\par
    /**\par
     * Hides the bubble from view.\par
     */\par
    hide: function() \{\par
      this.hidden = true;\par
      this.bubbleSuppressed = false;\par
      this.eventTracker_.removeAll();\par
      this.parentNode.removeChild(this);\par
    \},\par
\par
    /**\par
     * Handles keydown and mousedown events, dismissing the bubble if\par
     * necessary.\par
     * @param \{Event\} e The event.\par
     * @private\par
     */\par
    handleEvent: function(e) \{\par
      var handled = false;\par
      switch (e.type) \{\par
        case 'keydown':\par
          if (e.keyCode == 27) \{  // Esc.\par
            if (this.expanded) \{\par
              this.collapseBubble_();\par
              handled = true;\par
            \}\par
          \}\par
          break;\par
\par
        case 'mousedown':\par
          if (e.target == this.querySelector('.expandable-bubble-close')) \{\par
            this.handleCloseEvent_();\par
            handled = true;\par
          \} else if (!this.contains(e.target)) \{\par
            if (this.expanded) \{\par
              this.collapseBubble_();\par
              handled = true;\par
            \}\par
          \}\par
          break;\par
      \}\par
\par
      if (handled) \{\par
        // The bubble emulates a focus grab when expanded, so when we've\par
        // collapsed/hide the bubble we consider the event handles and don't\par
        // need to propagate it further.\par
        e.stopPropagation();\par
        e.preventDefault();\par
      \}\par
    \},\par
  \};\par
\par
  /**\par
   * Whether the bubble is expanded or not.\par
   * @type \{boolean\}\par
   */\par
  cr.defineProperty(ExpandableBubble, 'expanded', cr.PropertyKind.BOOL_ATTR);\par
\par
  /**\par
   * Whether the title needs to be masked out towards the right, which indicates\par
   * to the user that part of the text is clipped. This is only used when the\par
   * bubble is collapsed and the title doesn't fit because it is maxed out in\par
   * width within the anchored node.\par
   * @type \{boolean\}\par
   */\par
  cr.defineProperty(ExpandableBubble, 'masked', cr.PropertyKind.BOOL_ATTR);\par
\par
  return \{\par
    ExpandableBubble: ExpandableBubble\par
  \};\par
\});\par
</script>\par
<script>// Copyright (c) 2010 The Chromium Authors. All rights reserved.\par
// Use of this source code is governed by a BSD-style license that can be\par
// found in the LICENSE file.\par
\par
cr.define('cr.ui', function() \{\par
\par
  const MenuItem = cr.ui.MenuItem;\par
\par
  /**\par
   * Creates a new menu element.\par
   * @param \{Object=\} opt_propertyBag Optional properties.\par
   * @constructor\par
   * @extends \{HTMLMenuElement\}\par
   */\par
  var Menu = cr.ui.define('menu');\par
\par
  Menu.prototype = \{\par
    __proto__: HTMLMenuElement.prototype,\par
\par
    selectedIndex_: -1,\par
\par
    /**\par
     * Initializes the menu element.\par
     */\par
    decorate: function() \{\par
      this.addEventListener('mouseover', this.handleMouseOver_);\par
      this.addEventListener('mouseout', this.handleMouseOut_);\par
\par
      // Decorate the children as menu items.\par
      var children = this.children;\par
      for (var i = 0, child; child = children[i]; i++) \{\par
        cr.ui.decorate(child, MenuItem);\par
      \}\par
    \},\par
\par
    /**\par
     * Walks up the ancestors until a menu item belonging to this menu is found.\par
     * @param \{Element\} el\par
     * @return \{cr.ui.MenuItem\} The found menu item or null.\par
     * @private\par
     */\par
    findMenuItem_: function(el) \{\par
      while (el && el.parentNode != this) \{\par
        el = el.parentNode;\par
      \}\par
      return el;\par
    \},\par
\par
    /**\par
     * Handles mouseover events and selects the hovered item.\par
     * @param \{Event\} e The mouseover event.\par
     * @private\par
     */\par
    handleMouseOver_: function(e) \{\par
      var overItem = this.findMenuItem_(e.target);\par
      this.selectedItem = overItem;\par
    \},\par
\par
    /**\par
     * Handles mouseout events and deselects any selected item.\par
     * @param \{Event\} e The mouseout event.\par
     * @private\par
     */\par
    handleMouseOut_: function(e) \{\par
      this.selectedItem = null;\par
    \},\par
\par
    /**\par
     * The selected menu item or null if none.\par
     * @type \{cr.ui.MenuItem\}\par
     */\par
    get selectedItem() \{\par
      return this.children[this.selectedIndex];\par
    \},\par
    set selectedItem(item) \{\par
      var index = Array.prototype.indexOf.call(this.children, item);\par
      this.selectedIndex = index;\par
    \},\par
\par
    /**\par
     * This is the function that handles keyboard navigation. This is usually\par
     * called by the element responsible for managing the menu.\par
     * @param \{Event\} e The keydown event object.\par
     * @return \{boolean\} Whether the event was handled be the menu.\par
     */\par
    handleKeyDown: function(e) \{\par
      var item = this.selectedItem;\par
\par
      var self = this;\par
      function selectNextVisible(m) \{\par
        var children = self.children;\par
        var len = children.length;\par
        var i = self.selectedIndex;\par
        if (i == -1 && m == -1) \{\par
          // Edge case when we need to go the last item fisrt.\par
          i = 0;\par
        \}\par
        while (true) \{\par
          i = (i + m + len) % len;\par
          item = children[i];\par
          if (item && !item.isSeparator() && !item.hidden)\par
            break;\par
        \}\par
        if (item)\par
          self.selectedIndex = i;\par
      \}\par
\par
      switch (e.keyIdentifier) \{\par
        case 'Down':\par
          selectNextVisible(1);\par
          return true;\par
        case 'Up':\par
          selectNextVisible(-1);\par
          return true;\par
        case 'Enter':\par
        case 'U+0020': // Space\par
          if (item) \{\par
            if (cr.dispatchSimpleEvent(item, 'activate', true, true)) \{\par
              if (item.command)\par
                item.command.execute();\par
            \}\par
          \}\par
          return true;\par
      \}\par
\par
      return false;\par
    \}\par
  \};\par
\par
  function selectedIndexChanged(selectedIndex, oldSelectedIndex) \{\par
    var oldSelectedItem = this.children[oldSelectedIndex];\par
    if (oldSelectedItem)\par
      oldSelectedItem.selected = false;\par
    var item = this.selectedItem;\par
    if (item)\par
      item.selected = true;\par
  \}\par
  /**\par
   * The selected menu item.\par
   * @type \{number\}\par
   */\par
  cr.defineProperty(Menu, 'selectedIndex', cr.PropertyKind.JS,\par
      selectedIndexChanged);\par
\par
  // Export\par
  return \{\par
    Menu: Menu\par
  \};\par
\});\par
</script>\par
<script>// Copyright (c) 2011 The Chromium Authors. All rights reserved.\par
// Use of this source code is governed by a BSD-style license that can be\par
// found in the LICENSE file.\par
\par
cr.define('cr.ui', function() \{\par
  const Command = cr.ui.Command;\par
\par
  /**\par
   * Creates a new menu item element.\par
   * @param \{Object=\} opt_propertyBag Optional properties.\par
   * @constructor\par
   * @extends \{HTMLDivElement\}\par
   */\par
  var MenuItem = cr.ui.define('div');\par
\par
  /**\par
   * Creates a new menu separator element.\par
   * @return \{cr.ui.MenuItem\}\par
   */\par
  MenuItem.createSeparator = function() \{\par
    var el = cr.doc.createElement('hr');\par
    MenuItem.decorate(el);\par
    return el;\par
  \};\par
\par
  MenuItem.prototype = \{\par
    __proto__: HTMLButtonElement.prototype,\par
\par
    /**\par
     * Initializes the menu item.\par
     */\par
    decorate: function() \{\par
      var commandId;\par
      if ((commandId = this.getAttribute('command')))\par
        this.command = commandId;\par
\par
      this.addEventListener('mouseup', this.handleMouseUp_);\par
\par
      // Adding the 'custom-appearance' class prevents button.css from changing\par
      // the appearance of this element.\par
      this.classList.add('custom-appearance');\par
    \},\par
\par
    /**\par
     * The command associated with this menu item. If this is set to a string\par
     * of the form "#element-id" then the element is looked up in the document\par
     * of the command.\par
     * @type \{cr.ui.Command\}\par
     */\par
    command_: null,\par
    get command() \{\par
      return this.command_;\par
    \},\par
    set command(command) \{\par
      if (this.command_) \{\par
        this.command_.removeEventListener('labelChange', this);\par
        this.command_.removeEventListener('disabledChange', this);\par
        this.command_.removeEventListener('hiddenChange', this);\par
        this.command_.removeEventListener('checkedChange', this);\par
      \}\par
\par
      if (typeof command == 'string' && command[0] == '#') \{\par
        command = this.ownerDocument.getElementById(command.slice(1));\par
        cr.ui.decorate(command, Command);\par
      \}\par
\par
      this.command_ = command;\par
      if (command) \{\par
        if (command.id)\par
          this.setAttribute('command', '#' + command.id);\par
\par
        this.label = command.label;\par
        this.disabled = command.disabled;\par
        this.hidden = command.hidden;\par
\par
        this.command_.addEventListener('labelChange', this);\par
        this.command_.addEventListener('disabledChange', this);\par
        this.command_.addEventListener('hiddenChange', this);\par
        this.command_.addEventListener('checkedChange', this);\par
      \}\par
    \},\par
\par
    /**\par
     * The text label.\par
     * @type \{string\}\par
     */\par
    get label() \{\par
      return this.textContent;\par
    \},\par
    set label(label) \{\par
      this.textContent = label;\par
    \},\par
\par
    /**\par
     * @return \{boolean\} Whether the menu item is a separator.\par
     */\par
    isSeparator: function() \{\par
      return this.tagName == 'HR';\par
    \},\par
\par
    /**\par
     * Handles mouseup events. This dispatches an active event and if there\par
     * is an assiciated command then that is executed.\par
     * @param \{Event\} The mouseup event object.\par
     * @private\par
     */\par
    handleMouseUp_: function(e) \{\par
      if (!this.disabled && !this.isSeparator() && this.selected) \{\par
        // Dispatch command event followed by executing the command object.\par
        if (cr.dispatchSimpleEvent(this, 'activate', true, true)) \{\par
          var command = this.command;\par
          if (command)\par
            command.execute();\par
        \}\par
      \}\par
    \},\par
\par
    /**\par
     * Handles changes to the associated command.\par
     * @param \{Event\} e The event object.\par
     */\par
    handleEvent: function(e) \{\par
      switch (e.type) \{\par
        case 'disabledChange':\par
          this.disabled = this.command.disabled;\par
          break;\par
        case 'hiddenChange':\par
          this.hidden = this.command.hidden;\par
          break;\par
        case 'labelChange':\par
          this.label = this.command.label;\par
          break;\par
        case 'checkedChange':\par
          this.checked = this.command.checked;\par
          break;\par
      \}\par
    \}\par
  \};\par
\par
  /**\par
   * Whether the menu item is disabled or not.\par
   * @type \{boolean\}\par
   */\par
  cr.defineProperty(MenuItem, 'disabled', cr.PropertyKind.BOOL_ATTR);\par
\par
  /**\par
   * Whether the menu item is hidden or not.\par
   * @type \{boolean\}\par
   */\par
  cr.defineProperty(MenuItem, 'hidden', cr.PropertyKind.BOOL_ATTR);\par
\par
  /**\par
   * Whether the menu item is selected or not.\par
   * @type \{boolean\}\par
   */\par
  cr.defineProperty(MenuItem, 'selected', cr.PropertyKind.BOOL_ATTR);\par
\par
  /**\par
   * Whether the menu item is checked or not.\par
   * @type \{boolean\}\par
   */\par
  cr.defineProperty(MenuItem, 'checked', cr.PropertyKind.BOOL_ATTR);\par
\par
  // Export\par
  return \{\par
    MenuItem: MenuItem\par
  \};\par
\});\par
</script>\par
<script>// Copyright (c) 2010 The Chromium Authors. All rights reserved.\par
// Use of this source code is governed by a BSD-style license that can be\par
// found in the LICENSE file.\par
\par
/**\par
 * @fileoverview This file provides utility functions for position popups.\par
 */\par
\par
cr.define('cr.ui', function() \{\par
\par
  /**\par
   * Type def for rects as returned by getBoundingClientRect.\par
   * @typedef \{ \{left: number, top: number, width: number, height: number,\par
   *             right: number, bottom: number\}\}\par
   */\par
  var Rect;\par
\par
  /**\par
   * Enum for defining how to anchor a popup to an anchor element.\par
   * @enum \{number\}\par
   */\par
  const AnchorType = \{\par
    /**\par
     * The popup's right edge is aligned with the left edge of the anchor.\par
     * The popup's top edge is aligned with the top edge of the anchor.\par
     */\par
    BEFORE: 1,  // p: right, a: left, p: top, a: top\par
\par
    /**\par
     * The popop's left edge is aligned with the right edge of the anchor.\par
     * The popup's top edge is aligned with the top edge of the anchor.\par
     */\par
    AFTER: 2,  // p: left a: right, p: top, a: top\par
\par
    /**\par
     * The popop's bottom edge is aligned with the top edge of the anchor.\par
     * The popup's left edge is aligned with the left edge of the anchor.\par
     */\par
    ABOVE: 3,  // p: bottom, a: top, p: left, a: left\par
\par
    /**\par
     * The popop's top edge is aligned with the bottom edge of the anchor.\par
     * The popup's left edge is aligned with the left edge of the anchor.\par
     */\par
    BELOW: 4  // p: top, a: bottom, p: left, a: left\par
  \};\par
\par
  /**\par
   * Helper function for positionPopupAroundElement and positionPopupAroundRect.\par
   * @param \{!Rect\} anchorRect The rect for the anchor.\par
   * @param \{!HTMLElement\} popupElement The element used for the popup.\par
   * @param \{AnchorType\} type The type of anchoring to do.\par
   * @param \{boolean\} invertLeftRight Whether to invert the right/left\par
   *     alignment.\par
   */\par
  function positionPopupAroundRect(anchorRect, popupElement, type,\par
                                   invertLeftRight) \{\par
    var popupRect = popupElement.getBoundingClientRect();\par
    var availRect;\par
    var ownerDoc = popupElement.ownerDocument;\par
    var cs = ownerDoc.defaultView.getComputedStyle(popupElement);\par
    var docElement = ownerDoc.documentElement;\par
\par
    if (cs.position == 'fixed') \{\par
      // For 'fixed' positioned popups, the available rectangle should be based\par
      // on the viewport rather than the document.\par
      availRect = \{\par
        height: docElement.clientHeight,\par
        width: docElement.clientWidth,\par
        top: 0,\par
        bottom: docElement.clientHeight,\par
        left: 0,\par
        right: docElement.clientWidth\par
      \};\par
    \} else \{\par
      availRect = popupElement.offsetParent.getBoundingClientRect();\par
    \}\par
\par
    if (cs.direction == 'rtl')\par
      invertLeftRight = !invertLeftRight;\par
\par
    // Flip BEFORE, AFTER based on alignment.\par
    if (invertLeftRight) \{\par
      if (type == AnchorType.BEFORE)\par
        type = AnchorType.AFTER;\par
      else if (type == AnchorType.AFTER)\par
        type = AnchorType.BEFORE;\par
    \}\par
\par
    // Flip type based on available size\par
    switch (type) \{\par
      case AnchorType.BELOW:\par
        if (anchorRect.bottom + popupRect.height > availRect.height &&\par
            popupRect.height <= anchorRect.top) \{\par
          type = AnchorType.ABOVE;\par
        \}\par
        break;\par
      case AnchorType.ABOVE:\par
        if (popupRect.height > anchorRect.top &&\par
            anchorRect.bottom + popupRect.height <= availRect.height) \{\par
          type = AnchorType.BELOW;\par
        \}\par
        break;\par
      case AnchorType.AFTER:\par
        if (anchorRect.right + popupRect.width > availRect.width &&\par
            popupRect.width <= anchorRect.left) \{\par
          type = AnchorType.BEFORE;\par
        \}\par
        break;\par
      case AnchorType.BEFORE:\par
        if (popupRect.width > anchorRect.left &&\par
            anchorRect.right + popupRect.width <= availRect.width) \{\par
          type = AnchorType.AFTER;\par
        \}\par
        break;\par
    \}\par
    // flipping done\par
\par
    var style = popupElement.style;\par
    // Reset all directions.\par
    style.left = style.right = style.top = style.bottom = 'auto'\par
\par
    // Primary direction\par
    switch (type) \{\par
      case AnchorType.BELOW:\par
        if (anchorRect.bottom + popupRect.height <= availRect.height)\par
          style.top = anchorRect.bottom + 'px';\par
        else\par
          style.bottom = '0';\par
        break;\par
      case AnchorType.ABOVE:\par
        if (availRect.height - anchorRect.top >= 0)\par
          style.bottom = availRect.height - anchorRect.top + 'px';\par
        else\par
          style.top = '0';\par
        break;\par
      case AnchorType.AFTER:\par
        if (anchorRect.right + popupRect.width <= availRect.width)\par
          style.left = anchorRect.right + 'px';\par
        else\par
          style.right = '0';\par
        break;\par
      case AnchorType.BEFORE:\par
        if (availRect.width - anchorRect.left >= 0)\par
          style.right = availRect.width - anchorRect.left + 'px';\par
        else\par
          style.left = '0';\par
        break;\par
    \}\par
\par
    // Secondary direction\par
    switch (type) \{\par
      case AnchorType.BELOW:\par
      case AnchorType.ABOVE:\par
        if (invertLeftRight) \{\par
          // align right edges\par
          if (anchorRect.right - popupRect.width >= 0) \{\par
            style.right = availRect.width - anchorRect.right + 'px';\par
\par
          // align left edges\par
          \} else if (anchorRect.left + popupRect.width <= availRect.width) \{\par
            style.left = anchorRect.left + 'px';\par
\par
          // not enough room on either side\par
          \} else \{\par
            style.right = '0';\par
          \}\par
        \} else \{\par
          // align left edges\par
          if (anchorRect.left + popupRect.width <= availRect.width) \{\par
            style.left = anchorRect.left + 'px';\par
\par
          // align right edges\par
          \} else if (anchorRect.right - popupRect.width >= 0) \{\par
            style.right = availRect.width - anchorRect.right + 'px';\par
\par
          // not enough room on either side\par
          \} else \{\par
            style.left = '0';\par
          \}\par
        \}\par
        break;\par
\par
      case AnchorType.AFTER:\par
      case AnchorType.BEFORE:\par
        // align top edges\par
        if (anchorRect.top + popupRect.height <= availRect.height) \{\par
          style.top = anchorRect.top + 'px';\par
\par
        // align bottom edges\par
        \} else if (anchorRect.bottom - popupRect.height >= 0) \{\par
          style.bottom = availRect.height - anchorRect.bottom + 'px';\par
\par
          // not enough room on either side\par
        \} else \{\par
          style.top = '0';\par
        \}\par
        break;\par
    \}\par
  \}\par
\par
  /**\par
   * Positions a popup element relative to an anchor element. The popup element\par
   * should have position set to absolute and it should be a child of the body\par
   * element.\par
   * @param \{!HTMLElement\} anchorElement The element that the popup is anchored\par
   *     to.\par
   * @param \{!HTMLElement\} popupElement The popup element we are positioning.\par
   * @param \{AnchorType\} type The type of anchoring we want.\par
   * @param \{boolean\} invertLeftRight Whether to invert the right/left\par
   *     alignment.\par
   */\par
  function positionPopupAroundElement(anchorElement, popupElement, type,\par
                                      invertLeftRight) \{\par
    var anchorRect = anchorElement.getBoundingClientRect();\par
    positionPopupAroundRect(anchorRect, popupElement, type, invertLeftRight);\par
  \}\par
\par
  /**\par
   * Positions a popup around a point.\par
   * @param \{number\} x The client x position.\par
   * @param \{number\} y The client y position.\par
   * @param \{!HTMLElement\} popupElement The popup element we are positioning.\par
   */\par
  function positionPopupAtPoint(x, y, popupElement) \{\par
    var rect = \{\par
      left: x,\par
      top: y,\par
      width: 0,\par
      height: 0,\par
      right: x,\par
      bottom: y\par
    \};\par
    positionPopupAroundRect(rect, popupElement, AnchorType.BELOW);\par
  \}\par
\par
  // Export\par
  return \{\par
    AnchorType: AnchorType,\par
    positionPopupAroundElement: positionPopupAroundElement,\par
    positionPopupAtPoint: positionPopupAtPoint\par
  \};\par
\});\par
</script>\par
<script>// Copyright (c) 2011 The Chromium Authors. All rights reserved.\par
// Use of this source code is governed by a BSD-style license that can be\par
// found in the LICENSE file.\par
\par
cr.define('cr.ui', function() \{\par
  const Menu = cr.ui.Menu;\par
  const positionPopupAroundElement = cr.ui.positionPopupAroundElement;\par
\par
  /**\par
   * Creates a new menu button element.\par
   * @param \{Object=\} opt_propertyBag Optional properties.\par
   * @constructor\par
   * @extends \{HTMLButtonElement\}\par
   */\par
  var MenuButton = cr.ui.define('button');\par
\par
  MenuButton.prototype = \{\par
    __proto__: HTMLButtonElement.prototype,\par
\par
    /**\par
     * Initializes the menu button.\par
     */\par
    decorate: function() \{\par
      this.addEventListener('mousedown', this);\par
      this.addEventListener('keydown', this);\par
\par
      // Adding the 'custom-appearance' class prevents button.css from changing\par
      // the appearance of this element.\par
      this.classList.add('custom-appearance');\par
\par
      var menu;\par
      if ((menu = this.getAttribute('menu')))\par
        this.menu = menu;\par
\par
      // An event tracker for events we only connect to while the menu is\par
      // displayed.\par
      this.showingEvents_ = new EventTracker();\par
\par
      this.anchorType = cr.ui.AnchorType.BELOW;\par
      this.invertLeftRight = false;\par
    \},\par
\par
    /**\par
     * The menu associated with the menu button.\par
     * @type \{cr.ui.Menu\}\par
     */\par
    get menu() \{\par
      return this.menu_;\par
    \},\par
    set menu(menu) \{\par
      if (typeof menu == 'string' && menu[0] == '#') \{\par
        menu = this.ownerDocument.getElementById(menu.slice(1));\par
        cr.ui.decorate(menu, Menu);\par
      \}\par
\par
      this.menu_ = menu;\par
      if (menu) \{\par
        if (menu.id)\par
          this.setAttribute('menu', '#' + menu.id);\par
      \}\par
    \},\par
\par
    /**\par
     * Handles event callbacks.\par
     * @param \{Event\} e The event object.\par
     */\par
    handleEvent: function(e) \{\par
      if (!this.menu)\par
        return;\par
\par
      switch (e.type) \{\par
        case 'mousedown':\par
          if (e.currentTarget == this.ownerDocument) \{\par
            if (!this.contains(e.target) && !this.menu.contains(e.target))\par
              this.hideMenu();\par
            else\par
              e.preventDefault();\par
          \} else \{\par
            if (this.isMenuShown()) \{\par
              this.hideMenu();\par
            \} else if (e.button == 0) \{  // Only show the menu when using left\par
                                         // mouse button.\par
              this.showMenu();\par
              // Prevent the button from stealing focus on mousedown.\par
              e.preventDefault();\par
            \}\par
          \}\par
          break;\par
        case 'keydown':\par
          this.handleKeyDown(e);\par
          // If the menu is visible we let it handle all the keyboard events.\par
          if (this.isMenuShown() && e.currentTarget == this.ownerDocument) \{\par
            this.menu.handleKeyDown(e);\par
            e.preventDefault();\par
            e.stopPropagation();\par
          \}\par
          break;\par
\par
        case 'activate':\par
        case 'blur':\par
        case 'resize':\par
          this.hideMenu();\par
          break;\par
      \}\par
    \},\par
\par
    /**\par
     * Shows the menu.\par
     */\par
    showMenu: function() \{\par
      this.hideMenu();\par
\par
      this.menu.style.display = 'block';\par
      this.setAttribute('menu-shown', '');\par
\par
      // when the menu is shown we steal all keyboard events.\par
      var doc = this.ownerDocument;\par
      var win = doc.defaultView;\par
      this.showingEvents_.add(doc, 'keydown', this, true);\par
      this.showingEvents_.add(doc, 'mousedown', this, true);\par
      this.showingEvents_.add(doc, 'blur', this, true);\par
      this.showingEvents_.add(win, 'resize', this);\par
      this.showingEvents_.add(this.menu, 'activate', this);\par
      this.positionMenu_();\par
    \},\par
\par
    /**\par
     * Hides the menu. If your menu can go out of scope, make sure to call this\par
     * first.\par
     */\par
    hideMenu: function() \{\par
      if (!this.isMenuShown())\par
        return;\par
\par
      this.removeAttribute('menu-shown');\par
      this.menu.style.display = 'none';\par
\par
      this.showingEvents_.removeAll();\par
      this.menu.selectedIndex = -1;\par
    \},\par
\par
    /**\par
     * Whether the menu is shown.\par
     */\par
    isMenuShown: function() \{\par
      return this.hasAttribute('menu-shown');\par
    \},\par
\par
    /**\par
     * Positions the menu below the menu button. At this point we do not use any\par
     * advanced positioning logic to ensure the menu fits in the viewport.\par
     * @private\par
     */\par
    positionMenu_: function() \{\par
      positionPopupAroundElement(this, this.menu, this.anchorType,\par
                                 this.invertLeftRight);\par
    \},\par
\par
    /**\par
     * Handles the keydown event for the menu button.\par
     */\par
    handleKeyDown: function(e) \{\par
      switch (e.keyIdentifier) \{\par
        case 'Down':\par
        case 'Up':\par
        case 'Enter':\par
        case 'U+0020': // Space\par
          if (!this.isMenuShown())\par
            this.showMenu();\par
          e.preventDefault();\par
          break;\par
        case 'Esc':\par
        case 'U+001B': // Maybe this is remote desktop playing a prank?\par
          this.hideMenu();\par
          break;\par
      \}\par
    \}\par
  \};\par
\par
  // Export\par
  return \{\par
    MenuButton: MenuButton\par
  \};\par
\});\par
</script>\par
<script>// Copyright (c) 2011 The Chromium Authors. All rights reserved.\par
// Use of this source code is governed by a BSD-style license that can be\par
// found in the LICENSE file.\par
\par
/**\par
 * @fileoverview Touch Handler. Class that handles all touch events and\par
 * uses them to interpret higher level gestures and behaviors. TouchEvent is a\par
 * built in mobile safari type:\par
 * {{\field{\*\fldinst{HYPERLINK http://developer.apple.com/safari/library/documentation/UserExperience/Reference/TouchEventClassReference/TouchEvent/TouchEvent.html }}{\fldrslt{http://developer.apple.com/safari/library/documentation/UserExperience/Reference/TouchEventClassReference/TouchEvent/TouchEvent.html\ul0\cf0}}}}\f0\fs22 .\par
 * This class is intended to work with all webkit browsers, tested on Chrome and\par
 * iOS.\par
 *\par
 * The following types of gestures are currently supported.  See the definition\par
 * of TouchHandler.EventType for details.\par
 *\par
 * Single Touch:\par
 *      This provides simple single-touch events.  Any secondary touch is\par
 *      ignored.\par
 *\par
 * Drag:\par
 *      A single touch followed by some movement. This behavior will handle all\par
 *      of the required events and report the properties of the drag to you\par
 *      while the touch is happening and at the end of the drag sequence. This\par
 *      behavior will NOT perform the actual dragging (redrawing the element)\par
 *      for you, this responsibility is left to the client code.\par
 *\par
 * Long press:\par
 *     When your element is touched and held without any drag occuring, the\par
 *     LONG_PRESS event will fire.\par
 */\par
\par
// Use an anonymous function to enable strict mode just for this file (which\par
// will be concatenated with other files when embedded in Chrome)\par
cr.define('cr.ui', function() \{\par
  'use strict';\par
\par
  /**\par
   * A TouchHandler attaches to an Element, listents for low-level touch (or\par
   * mouse) events and dispatching higher-level events on the element.\par
   * @param \{!Element\} element The element to listen on and fire events\par
   * for.\par
   * @constructor\par
   */\par
  function TouchHandler(element) \{\par
    /**\par
     * @type \{!Element\}\par
     * @private\par
     */\par
    this.element_ = element;\par
\par
    /**\par
     * The absolute sum of all touch y deltas.\par
     * @type \{number\}\par
     * @private\par
     */\par
    this.totalMoveY_ = 0;\par
\par
    /**\par
     * The absolute sum of all touch x deltas.\par
     * @type \{number\}\par
     * @private\par
     */\par
    this.totalMoveX_ = 0;\par
\par
    /**\par
     * An array of tuples where the first item is the horizontal component of a\par
     * recent relevant touch and the second item is the touch's time stamp. Old\par
     * touches are removed based on the max tracking time and when direction\par
     * changes.\par
      * @type \{!Array.<number>\}\par
      * @private\par
      */\par
    this.recentTouchesX_ = [];\par
\par
    /**\par
     * An array of tuples where the first item is the vertical component of a\par
     * recent relevant touch and the second item is the touch's time stamp. Old\par
     * touches are removed based on the max tracking time and when direction\par
     * changes.\par
     * @type \{!Array.<number>\}\par
     * @private\par
     */\par
    this.recentTouchesY_ = [];\par
\par
    /**\par
     * Used to keep track of all events we subscribe to so we can easily clean\par
     * up\par
     * @type \{EventTracker\}\par
     * @private\par
     */\par
    this.events_ = new EventTracker();\par
  \}\par
\par
\par
  /**\par
   * DOM Events that may be fired by the TouchHandler at the element\par
   */\par
  TouchHandler.EventType = \{\par
    // Fired whenever the element is touched as the only touch to the device.\par
    // enableDrag defaults to false, set to true to permit dragging.\par
    TOUCH_START: 'touchHandler:touch_start',\par
\par
    // Fired when an element is held for a period of time.  Prevents dragging\par
    // from occuring (even if enableDrag was set to true).\par
    LONG_PRESS: 'touchHandler:long_press',\par
\par
    // If enableDrag was set to true at TOUCH_START, DRAG_START will fire when\par
    // the touch first moves sufficient distance.  enableDrag is set to true but\par
    // can be reset to false to cancel the drag.\par
    DRAG_START: 'touchHandler:drag_start',\par
\par
    // If enableDrag was true after DRAG_START, DRAG_MOVE will fire whenever the\par
    // touch is moved.\par
    DRAG_MOVE: 'touchHandler:drag_move',\par
\par
    // Fired just before TOUCH_END when a drag is released.  Correlates 1:1 with\par
    // a DRAG_START.\par
    DRAG_END: 'touchHandler:drag_end',\par
\par
    // Fired whenever a touch that is being tracked has been released.\par
    // Correlates 1:1 with a TOUCH_START.\par
    TOUCH_END: 'touchHandler:touch_end'\par
  \};\par
\par
\par
  /**\par
   * The type of event sent by TouchHandler\par
   * @constructor\par
   * @param \{string\} type The type of event (one of cr.ui.Grabber.EventType).\par
   * @param \{boolean\} bubbles Whether or not the event should bubble.\par
   * @param \{number\} clientX The X location of the touch.\par
   * @param \{number\} clientY The Y location of the touch.\par
   * @param \{!Element\} touchedElement The element at the current location of the\par
   *        touch.\par
   */\par
  TouchHandler.Event = function(type, bubbles, clientX, clientY,\par
      touchedElement) \{\par
    var event = document.createEvent('Event');\par
    event.initEvent(type, bubbles, true);\par
    event.__proto__ = TouchHandler.Event.prototype;\par
\par
    /**\par
     * The X location of the touch affected\par
     * @type \{number\}\par
     */\par
    event.clientX = clientX;\par
\par
    /**\par
     * The Y location of the touch affected\par
     * @type \{number\}\par
     */\par
    event.clientY = clientY;\par
\par
    /**\par
     * The element at the current location of the touch.\par
     * @type \{!Element\}\par
     */\par
    event.touchedElement = touchedElement;\par
\par
    return event;\par
  \};\par
\par
  TouchHandler.Event.prototype = \{\par
    __proto__: Event.prototype,\par
\par
    /**\par
     * For TOUCH_START and DRAG START events, set to true to enable dragging or\par
     * false to disable dragging.\par
     * @type \{boolean|undefined\}\par
     */\par
    enableDrag: undefined,\par
\par
    /**\par
     * For DRAG events, provides the horizontal component of the\par
     * drag delta. Drag delta is defined as the delta of the start touch\par
     * position and the current drag position.\par
     * @type \{number|undefined\}\par
     */\par
    dragDeltaX: undefined,\par
\par
    /**\par
     * For DRAG events, provides the vertical component of the\par
     * drag delta.\par
     * @type \{number|undefined\}\par
     */\par
    dragDeltaY: undefined\par
  \};\par
\par
  /**\par
   * Minimum movement of touch required to be considered a drag.\par
   * @type \{number\}\par
   * @private\par
   */\par
  TouchHandler.MIN_TRACKING_FOR_DRAG_ = 8;\par
\par
\par
  /**\par
   * The maximum number of ms to track a touch event. After an event is older\par
   * than this value, it will be ignored in velocity calculations.\par
   * @type \{number\}\par
   * @private\par
   */\par
  TouchHandler.MAX_TRACKING_TIME_ = 250;\par
\par
\par
  /**\par
   * The maximum number of touches to track.\par
   * @type \{number\}\par
   * @private\par
   */\par
  TouchHandler.MAX_TRACKING_TOUCHES_ = 5;\par
\par
\par
  /**\par
   * The maximum velocity to return, in pixels per millisecond, that is used\par
   * to guard against errors in calculating end velocity of a drag. This is a\par
   * very fast drag velocity.\par
   * @type \{number\}\par
   * @private\par
   */\par
  TouchHandler.MAXIMUM_VELOCITY_ = 5;\par
\par
\par
  /**\par
   * The velocity to return, in pixel per millisecond, when the time stamps on\par
   * the events are erroneous. The browser can return bad time stamps if the\par
   * thread is blocked for the duration of the drag. This is a low velocity to\par
   * prevent the content from moving quickly after a slow drag. It is less\par
   * jarring if the content moves slowly after a fast drag.\par
   * @type \{number\}\par
   * @private\par
   */\par
  TouchHandler.VELOCITY_FOR_INCORRECT_EVENTS_ = 1;\par
\par
  /**\par
   * The time, in milliseconds, that a touch must be held to be considered\par
   * 'long'.\par
   * @type \{number\}\par
   * @private\par
   */\par
  TouchHandler.TIME_FOR_LONG_PRESS_ = 500;\par
\par
  TouchHandler.prototype = \{\par
    /**\par
     * If defined, the identifer of the single touch that is active.  Note that\par
     * 0 is a valid touch identifier - it should not be treated equivalently to\par
     * undefined.\par
     * @type \{number|undefined\}\par
     * @private\par
     */\par
    activeTouch_: undefined,\par
\par
    /**\par
     * @type \{boolean|undefined\}\par
     * @private\par
     */\par
    tracking_: undefined,\par
\par
    /**\par
     * @type \{number|undefined\}\par
     * @private\par
     */\par
    startTouchX_: undefined,\par
\par
    /**\par
     * @type \{number|undefined\}\par
     * @private\par
     */\par
    startTouchY_: undefined,\par
\par
    /**\par
     * @type \{number|undefined\}\par
     * @private\par
     */\par
    endTouchX_: undefined,\par
\par
    /**\par
     * @type \{number|undefined\}\par
     * @private\par
     */\par
    endTouchY_: undefined,\par
\par
    /**\par
     * Time of the touchstart event.\par
     * @type \{number|undefined\}\par
     * @private\par
     */\par
    startTime_: undefined,\par
\par
    /**\par
     * The time of the touchend event.\par
     * @type \{number|undefined\}\par
     * @private\par
     */\par
    endTime_: undefined,\par
\par
    /**\par
     * @type \{number|undefined\}\par
     * @private\par
     */\par
    lastTouchX_: undefined,\par
\par
    /**\par
     * @type \{number|undefined\}\par
     * @private\par
     */\par
    lastTouchY_: undefined,\par
\par
    /**\par
     * @type \{number|undefined\}\par
     * @private\par
     */\par
    lastMoveX_: undefined,\par
\par
    /**\par
     * @type \{number|undefined\}\par
     * @private\par
     */\par
    lastMoveY_: undefined,\par
\par
    /**\par
     * @type \{number|undefined\}\par
     * @private\par
     */\par
    longPressTimeout_: undefined,\par
\par
    /**\par
     * If defined and true, the next click event should be swallowed\par
     * @type \{boolean|undefined\}\par
     * @private\par
     */\par
    swallowNextClick_: undefined,\par
\par
    /**\par
     * Start listenting for events.\par
     * @param \{boolean=\} opt_capture True if the TouchHandler should listen to\par
     *      during the capture phase.\par
     * @param \{boolean=\} opt_mouse True if the TouchHandler should generate\par
     *      events for mouse input (in addition to touch input).\par
     */\par
    enable: function(opt_capture, opt_mouse) \{\par
      var capture = !!opt_capture;\par
\par
      // Just listen to start events for now. When a touch is occuring we'll\par
      // want to be subscribed to move and end events on the document, but we\par
      // don't want to incur the cost of lots of no-op handlers on the document.\par
      this.events_.add(this.element_, 'touchstart', this.onStart_.bind(this),\par
                       capture);\par
      if (opt_mouse) \{\par
        this.events_.add(this.element_, 'mousedown',\par
                         this.mouseToTouchCallback_(this.onStart_.bind(this)),\par
                         capture);\par
      \}\par
\par
      // If the element is long-pressed, we may need to swallow a click\par
      this.events_.add(this.element_, 'click', this.onClick_.bind(this), true);\par
    \},\par
\par
    /**\par
     * Stop listening to all events.\par
     */\par
    disable: function() \{\par
      this.stopTouching_();\par
      this.events_.removeAll();\par
    \},\par
\par
    /**\par
     * Wraps a callback with translations of mouse events to touch events.\par
     * NOTE: These types really should be function(Event) but then we couldn't\par
     * use this with bind (which operates on any type of function).  Doesn't\par
     * JSDoc support some sort of polymorphic types?\par
     * @param \{Function\} callback The event callback.\par
     * @return \{Function\} The wrapping callback.\par
     * @private\par
     */\par
    mouseToTouchCallback_: function(callback) \{\par
      return function(e) \{\par
        // Note that there may be synthesizes mouse events caused by touch\par
        // events (a mouseDown after a touch-click).  We leave it up to the\par
        // client to worry about this if it matters to them (typically a short\par
        // mouseDown/mouseUp without a click is no big problem and it's not\par
        // obvious how we identify such synthesized events in a general way).\par
        var touch = \{\par
          // any fixed value will do for the identifier - there will only\par
          // ever be a single active 'touch' when using the mouse.\par
          identifier: 0,\par
          clientX: e.clientX,\par
          clientY: e.clientY,\par
          target: e.target\par
        \};\par
        e.touches = [];\par
        e.targetTouches = [];\par
        e.changedTouches = [touch];\par
        if (e.type != 'mouseup') \{\par
          e.touches[0] = touch;\par
          e.targetTouches[0] = touch;\par
        \}\par
        callback(e);\par
      \};\par
    \},\par
\par
    /**\par
     * Begin tracking the touchable element, it is eligible for dragging.\par
     * @private\par
     */\par
    beginTracking_: function() \{\par
      this.tracking_ = true;\par
    \},\par
\par
    /**\par
     * Stop tracking the touchable element, it is no longer dragging.\par
     * @private\par
     */\par
    endTracking_: function() \{\par
      this.tracking_ = false;\par
      this.dragging_ = false;\par
      this.totalMoveY_ = 0;\par
      this.totalMoveX_ = 0;\par
    \},\par
\par
    /**\par
     * Reset the touchable element as if we never saw the touchStart\par
     * Doesn't dispatch any end events - be careful of existing listeners.\par
     */\par
    cancelTouch: function() \{\par
      this.stopTouching_();\par
      this.endTracking_();\par
      // If clients needed to be aware of this, we could fire a cancel event\par
      // here.\par
    \},\par
\par
    /**\par
     * Record that touching has stopped\par
     * @private\par
     */\par
    stopTouching_: function() \{\par
      // Mark as no longer being touched\par
      this.activeTouch_ = undefined;\par
\par
      // If we're waiting for a long press, stop\par
      window.clearTimeout(this.longPressTimeout_);\par
\par
      // Stop listening for move/end events until there's another touch.\par
      // We don't want to leave handlers piled up on the document.\par
      // Note that there's no harm in removing handlers that weren't added, so\par
      // rather than track whether we're using mouse or touch we do both.\par
      this.events_.remove(document, 'touchmove');\par
      this.events_.remove(document, 'touchend');\par
      this.events_.remove(document, 'touchcancel');\par
      this.events_.remove(document, 'mousemove');\par
      this.events_.remove(document, 'mouseup');\par
    \},\par
\par
    /**\par
     * Touch start handler.\par
     * @param \{!TouchEvent\} e The touchstart event.\par
     * @private\par
     */\par
    onStart_: function(e) \{\par
      // Only process single touches.  If there is already a touch happening, or\par
      // two simultaneous touches then just ignore them.\par
      if (e.touches.length > 1)\par
        // Note that we could cancel an active touch here.  That would make\par
        // simultaneous touch behave similar to near-simultaneous. However, if\par
        // the user is dragging something, an accidental second touch could be\par
        // quite disruptive if it cancelled their drag.  Better to just ignore\par
        // it.\par
        return;\par
\par
      // It's still possible there could be an active "touch" if the user is\par
      // simultaneously using a mouse and a touch input.\par
      if (this.activeTouch_ !== undefined)\par
        return;\par
\par
      var touch = e.targetTouches[0];\par
      this.activeTouch_ = touch.identifier;\par
\par
      // We've just started touching so shouldn't swallow any upcoming click\par
      if (this.swallowNextClick_)\par
        this.swallowNextClick_ = false;\par
\par
      // Sign up for end/cancel notifications for this touch.\par
      // Note that we do this on the document so that even if the user drags\par
      // their finger off the element, we'll still know what they're doing.\par
      if (e.type == 'mousedown') \{\par
        this.events_.add(document, 'mouseup',\par
            this.mouseToTouchCallback_(this.onEnd_.bind(this)), false);\par
      \} else \{\par
        this.events_.add(document, 'touchend', this.onEnd_.bind(this), false);\par
        this.events_.add(document, 'touchcancel', this.onEnd_.bind(this),\par
            false);\par
      \}\par
\par
      // This timeout is cleared on touchEnd and onDrag\par
      // If we invoke the function then we have a real long press\par
      window.clearTimeout(this.longPressTimeout_);\par
      this.longPressTimeout_ = window.setTimeout(\par
          this.onLongPress_.bind(this),\par
          TouchHandler.TIME_FOR_LONG_PRESS_);\par
\par
      // Dispatch the TOUCH_START event\par
      if (!this.dispatchEvent_(TouchHandler.EventType.TOUCH_START, touch))\par
        // Dragging was not enabled, nothing more to do\par
        return;\par
\par
      // We want dragging notifications\par
      if (e.type == 'mousedown') \{\par
        this.events_.add(document, 'mousemove',\par
            this.mouseToTouchCallback_(this.onMove_.bind(this)), false);\par
      \} else \{\par
        this.events_.add(document, 'touchmove', this.onMove_.bind(this), false);\par
      \}\par
\par
      this.startTouchX_ = this.lastTouchX_ = touch.clientX;\par
      this.startTouchY_ = this.lastTouchY_ = touch.clientY;\par
      this.startTime_ = e.timeStamp;\par
\par
      this.recentTouchesX_ = [];\par
      this.recentTouchesY_ = [];\par
      this.recentTouchesX_.push(touch.clientX, e.timeStamp);\par
      this.recentTouchesY_.push(touch.clientY, e.timeStamp);\par
\par
      this.beginTracking_();\par
    \},\par
\par
    /**\par
     * Given a list of Touches, find the one matching our activeTouch\par
     * identifier. Note that Chrome currently always uses 0 as the identifier.\par
     * In that case we'll end up always choosing the first element in the list.\par
     * @param \{TouchList\} touches The list of Touch objects to search.\par
     * @return \{!Touch|undefined\} The touch matching our active ID if any.\par
     * @private\par
     */\par
    findActiveTouch_: function(touches) \{\par
      assert(this.activeTouch_ !== undefined, 'Expecting an active touch');\par
      // A TouchList isn't actually an array, so we shouldn't use\par
      // Array.prototype.filter/some, etc.\par
      for (var i = 0; i < touches.length; i++) \{\par
        if (touches[i].identifier == this.activeTouch_)\par
          return touches[i];\par
      \}\par
      return undefined;\par
    \},\par
\par
    /**\par
     * Touch move handler.\par
     * @param \{!TouchEvent\} e The touchmove event.\par
     * @private\par
     */\par
    onMove_: function(e) \{\par
      if (!this.tracking_)\par
        return;\par
\par
      // Our active touch should always be in the list of touches still active\par
      assert(this.findActiveTouch_(e.touches), 'Missing touchEnd');\par
\par
      var that = this;\par
      var touch = this.findActiveTouch_(e.changedTouches);\par
      if (!touch)\par
        return;\par
\par
      var clientX = touch.clientX;\par
      var clientY = touch.clientY;\par
\par
      var moveX = this.lastTouchX_ - clientX;\par
      var moveY = this.lastTouchY_ - clientY;\par
      this.totalMoveX_ += Math.abs(moveX);\par
      this.totalMoveY_ += Math.abs(moveY);\par
      this.lastTouchX_ = clientX;\par
      this.lastTouchY_ = clientY;\par
\par
      if (!this.dragging_ && (this.totalMoveY_ >\par
          TouchHandler.MIN_TRACKING_FOR_DRAG_ ||\par
          this.totalMoveX_ >\par
          TouchHandler.MIN_TRACKING_FOR_DRAG_)) \{\par
        // If we're waiting for a long press, stop\par
        window.clearTimeout(this.longPressTimeout_);\par
\par
        // Dispatch the DRAG_START event and record whether dragging should be\par
        // allowed or not.  Note that this relies on the current value of\par
        // startTouchX/Y - handlers may use the initial drag delta to determine\par
        // if dragging should be permitted.\par
        this.dragging_ = this.dispatchEvent_(\par
            TouchHandler.EventType.DRAG_START, touch);\par
\par
        if (this.dragging_) \{\par
          // Update the start position here so that drag deltas have better\par
          // values but don't touch the recent positions so that velocity\par
          // calculations can still use touchstart position in the time and\par
          // distance delta.\par
          this.startTouchX_ = clientX;\par
          this.startTouchY_ = clientY;\par
          this.startTime_ = e.timeStamp;\par
        \} else \{\par
          this.endTracking_();\par
        \}\par
      \}\par
\par
      if (this.dragging_) \{\par
        this.dispatchEvent_(TouchHandler.EventType.DRAG_MOVE, touch);\par
\par
        this.removeTouchesInWrongDirection_(this.recentTouchesX_,\par
            this.lastMoveX_, moveX);\par
        this.removeTouchesInWrongDirection_(this.recentTouchesY_,\par
            this.lastMoveY_, moveY);\par
        this.removeOldTouches_(this.recentTouchesX_, e.timeStamp);\par
        this.removeOldTouches_(this.recentTouchesY_, e.timeStamp);\par
        this.recentTouchesX_.push(clientX, e.timeStamp);\par
        this.recentTouchesY_.push(clientY, e.timeStamp);\par
      \}\par
\par
      this.lastMoveX_ = moveX;\par
      this.lastMoveY_ = moveY;\par
    \},\par
\par
    /**\par
     * Filters the provided recent touches array to remove all touches except\par
     * the last if the move direction has changed.\par
     * @param \{!Array.<number>\} recentTouches An array of tuples where the first\par
     *     item is the x or y component of the recent touch and the second item\par
     *     is the touch time stamp.\par
     * @param \{number|undefined\} lastMove The x or y component of the previous\par
     *     move.\par
     * @param \{number\} recentMove The x or y component of the most recent move.\par
     * @private\par
     */\par
    removeTouchesInWrongDirection_: function(recentTouches, lastMove,\par
        recentMove) \{\par
      if (lastMove && recentMove && recentTouches.length > 2 &&\par
          (lastMove > 0 ^ recentMove > 0)) \{\par
        recentTouches.splice(0, recentTouches.length - 2);\par
      \}\par
    \},\par
\par
    /**\par
     * Filters the provided recent touches array to remove all touches older\par
     * than the max tracking time or the 5th most recent touch.\par
     * @param \{!Array.<number>\} recentTouches An array of tuples where the first\par
     *     item is the x or y component of the recent touch and the second item\par
     *     is the touch time stamp.\par
     * @param \{number\} recentTime The time of the most recent event.\par
     * @private\par
     */\par
    removeOldTouches_: function(recentTouches, recentTime) \{\par
      while (recentTouches.length && recentTime - recentTouches[1] >\par
          TouchHandler.MAX_TRACKING_TIME_ ||\par
          recentTouches.length >\par
              TouchHandler.MAX_TRACKING_TOUCHES_ * 2) \{\par
        recentTouches.splice(0, 2);\par
      \}\par
    \},\par
\par
    /**\par
     * Touch end handler.\par
     * @param \{!TouchEvent\} e The touchend event.\par
     * @private\par
     */\par
    onEnd_: function(e) \{\par
      var that = this;\par
      assert(this.activeTouch_ !== undefined, 'Expect to already be touching');\par
\par
      // If the touch we're tracking isn't changing here, ignore this touch end.\par
      var touch = this.findActiveTouch_(e.changedTouches);\par
      if (!touch) \{\par
        // In most cases, our active touch will be in the 'touches' collection,\par
        // but we can't assert that because occasionally two touchend events can\par
        // occur at almost the same time with both having empty 'touches' lists.\par
        // I.e., 'touches' seems like it can be a bit more up-to-date than the\par
        // current event.\par
        return;\par
      \}\par
\par
      // This is touchEnd for the touch we're monitoring\par
      assert(!this.findActiveTouch_(e.touches),\par
             'Touch ended also still active');\par
\par
      // Indicate that touching has finished\par
      this.stopTouching_();\par
\par
      if (this.tracking_) \{\par
        var clientX = touch.clientX;\par
        var clientY = touch.clientY;\par
\par
        if (this.dragging_) \{\par
          this.endTime_ = e.timeStamp;\par
          this.endTouchX_ = clientX;\par
          this.endTouchY_ = clientY;\par
\par
          this.removeOldTouches_(this.recentTouchesX_, e.timeStamp);\par
          this.removeOldTouches_(this.recentTouchesY_, e.timeStamp);\par
\par
          this.dispatchEvent_(TouchHandler.EventType.DRAG_END, touch);\par
\par
          // Note that in some situations we can get a click event here as well.\par
          // For now this isn't a problem, but we may want to consider having\par
          // some logic that hides clicks that appear to be caused by a touchEnd\par
          // used for dragging.\par
        \}\par
\par
        this.endTracking_();\par
      \}\par
\par
      // Note that we dispatch the touchEnd event last so that events at\par
      // different levels of semantics nest nicely (similar to how DOM\par
      // drag-and-drop events are nested inside of the mouse events that trigger\par
      // them).\par
      this.dispatchEvent_(TouchHandler.EventType.TOUCH_END, touch);\par
    \},\par
\par
    /**\par
     * Get end velocity of the drag. This method is specific to drag behavior,\par
     * so if touch behavior and drag behavior is split then this should go with\par
     * drag behavior. End velocity is defined as deltaXY / deltaTime where\par
     * deltaXY is the difference between endPosition and the oldest recent\par
     * position, and deltaTime is the difference between endTime and the oldest\par
     * recent time stamp.\par
     * @return \{Object\} The x and y velocity.\par
     */\par
    getEndVelocity: function() \{\par
      // Note that we could move velocity to just be an end-event parameter.\par
      var velocityX = this.recentTouchesX_.length ?\par
          (this.endTouchX_ - this.recentTouchesX_[0]) /\par
          (this.endTime_ - this.recentTouchesX_[1]) : 0;\par
      var velocityY = this.recentTouchesY_.length ?\par
          (this.endTouchY_ - this.recentTouchesY_[0]) /\par
          (this.endTime_ - this.recentTouchesY_[1]) : 0;\par
\par
      velocityX = this.correctVelocity_(velocityX);\par
      velocityY = this.correctVelocity_(velocityY);\par
\par
      return \{\par
        x: velocityX,\par
        y: velocityY\par
      \};\par
    \},\par
\par
    /**\par
     * Correct erroneous velocities by capping the velocity if we think it's too\par
     * high, or setting it to a default velocity if know that the event data is\par
     * bad.\par
     * @param \{number\} velocity The x or y velocity component.\par
     * @return \{number\} The corrected velocity.\par
     * @private\par
     */\par
    correctVelocity_: function(velocity) \{\par
      var absVelocity = Math.abs(velocity);\par
\par
      // We add to recent touches for each touchstart and touchmove. If we have\par
      // fewer than 3 touches (6 entries), we assume that the thread was blocked\par
      // for the duration of the drag and we received events in quick succession\par
      // with the wrong time stamps.\par
      if (absVelocity > TouchHandler.MAXIMUM_VELOCITY_) \{\par
        absVelocity = this.recentTouchesY_.length < 3 ?\par
            TouchHandler.VELOCITY_FOR_INCORRECT_EVENTS_ :\par
                TouchHandler.MAXIMUM_VELOCITY_;\par
      \}\par
      return absVelocity * (velocity < 0 ? -1 : 1);\par
    \},\par
\par
    /**\par
     * Handler when an element has been pressed for a long time\par
     * @private\par
     */\par
    onLongPress_: function() \{\par
      // Swallow any click that occurs on this element without an intervening\par
      // touch start event.  This simple click-busting technique should be\par
      // sufficient here since a real click should have a touchstart first.\par
      this.swallowNextClick_ = true;\par
\par
      // Dispatch to the LONG_PRESS\par
      this.dispatchEventXY_(TouchHandler.EventType.LONG_PRESS, this.element_,\par
          this.startTouchX_, this.startTouchY_);\par
    \},\par
\par
    /**\par
     * Click handler - used to swallow clicks after a long-press\par
     * @param \{!Event\} e The click event.\par
     * @private\par
     */\par
    onClick_: function(e) \{\par
      if (this.swallowNextClick_) \{\par
        e.preventDefault();\par
        e.stopPropagation();\par
        this.swallowNextClick_ = false;\par
      \}\par
    \},\par
\par
    /**\par
     * Dispatch a TouchHandler event to the element\par
     * @param \{string\} eventType The event to dispatch.\par
     * @param \{Touch\} touch The touch triggering this event.\par
     * @return \{boolean|undefined\} The value of enableDrag after dispatching\par
     *         the event.\par
     * @private\par
     */\par
    dispatchEvent_: function(eventType, touch) \{\par
\par
      // Determine which element was touched.  For mouse events, this is always\par
      // the event/touch target.  But for touch events, the target is always the\par
      // target of the touchstart (and it's unlikely we can change this\par
      // since the common implementation of touch dragging relies on it). Since\par
      // touch is our primary scenario (which we want to emulate with mouse),\par
      // we'll treat both cases the same and not depend on the target.\par
      var touchedElement;\par
      if (eventType == TouchHandler.EventType.TOUCH_START) \{\par
        touchedElement = touch.target;\par
      \} else \{\par
        touchedElement = this.element_.ownerDocument.\par
            elementFromPoint(touch.clientX, touch.clientY);\par
      \}\par
\par
      return this.dispatchEventXY_(eventType, touchedElement, touch.clientX,\par
          touch.clientY);\par
    \},\par
\par
    /**\par
     * Dispatch a TouchHandler event to the element\par
     * @param \{string\} eventType The event to dispatch.\par
       @param \{number\} clientX The X location for the event.\par
       @param \{number\} clientY The Y location for the event.\par
     * @return \{boolean|undefined\} The value of enableDrag after dispatching\par
     *         the event.\par
     * @private\par
     */\par
    dispatchEventXY_: function(eventType, touchedElement, clientX, clientY) \{\par
      var isDrag = (eventType == TouchHandler.EventType.DRAG_START ||\par
          eventType == TouchHandler.EventType.DRAG_MOVE ||\par
          eventType == TouchHandler.EventType.DRAG_END);\par
\par
      // Drag events don't bubble - we're really just dragging the element,\par
      // not affecting its parent at all.\par
      var bubbles = !isDrag;\par
\par
      var event = new TouchHandler.Event(eventType, bubbles, clientX, clientY,\par
          touchedElement);\par
\par
      // Set enableDrag when it can be overridden\par
      if (eventType == TouchHandler.EventType.TOUCH_START)\par
        event.enableDrag = false;\par
      else if (eventType == TouchHandler.EventType.DRAG_START)\par
        event.enableDrag = true;\par
\par
      if (isDrag) \{\par
        event.dragDeltaX = clientX - this.startTouchX_;\par
        event.dragDeltaY = clientY - this.startTouchY_;\par
      \}\par
\par
      this.element_.dispatchEvent(event);\par
      return event.enableDrag;\par
    \}\par
  \};\par
\par
  return \{\par
    TouchHandler: TouchHandler\par
  \};\par
\});\par
</script>\par
\par
<script>// Copyright (c) 2012 The Chromium Authors. All rights reserved.\par
// Use of this source code is governed by a BSD-style license that can be\par
// found in the LICENSE file.\par
\par
cr.define('ntp4', function() \{\par
  'use strict';\par
\par
  // We can't pass the currently dragging tile via dataTransfer because of\par
  // {{\field{\*\fldinst{HYPERLINK http://crbug.com/31037 }}{\fldrslt{http://crbug.com/31037\ul0\cf0}}}}\f0\fs22\par
  var currentlyDraggingTile = null;\par
  function getCurrentlyDraggingTile() \{\par
    return currentlyDraggingTile;\par
  \}\par
  function setCurrentlyDraggingTile(tile) \{\par
    currentlyDraggingTile = tile;\par
    if (tile)\par
      ntp4.enterRearrangeMode();\par
    else\par
      ntp4.leaveRearrangeMode();\par
  \}\par
\par
  /**\par
   * Changes the current dropEffect of a drag. This modifies the native cursor\par
   * and serves as an indicator of what we should do at the end of the drag as\par
   * well as give indication to the user if a drop would succeed if they let go.\par
   * @param \{DataTransfer\} dataTransfer A dataTransfer object from a drag event.\par
   * @param \{string\} effect A drop effect to change to (i.e. copy, move, none).\par
   */\par
  function setCurrentDropEffect(dataTransfer, effect) \{\par
    dataTransfer.dropEffect = effect;\par
    if (currentlyDraggingTile)\par
      currentlyDraggingTile.lastDropEffect = dataTransfer.dropEffect;\par
  \}\par
\par
  /**\par
   * Creates a new Tile object. Tiles wrap content on a TilePage, providing\par
   * some styling and drag functionality.\par
   * @constructor\par
   * @extends \{HTMLDivElement\}\par
   */\par
  function Tile(contents) \{\par
    var tile = cr.doc.createElement('div');\par
    tile.__proto__ = Tile.prototype;\par
    tile.initialize(contents);\par
\par
    return tile;\par
  \}\par
\par
  Tile.prototype = \{\par
    __proto__: HTMLDivElement.prototype,\par
\par
    initialize: function(contents) \{\par
      // 'real' as opposed to doppleganger.\par
      this.className = 'tile real';\par
      this.appendChild(contents);\par
      contents.tile = this;\par
\par
      this.addEventListener('dragstart', this.onDragStart_);\par
      this.addEventListener('drag', this.onDragMove_);\par
      this.addEventListener('dragend', this.onDragEnd_);\par
\par
      this.firstChild.addEventListener(\par
          'webkitAnimationEnd', this.onContentsAnimationEnd_.bind(this));\par
\par
      this.eventTracker = new EventTracker();\par
    \},\par
\par
    get index() \{\par
      return Array.prototype.indexOf.call(this.parentNode.children, this);\par
    \},\par
\par
    get tilePage() \{\par
      return findAncestorByClass(this, 'tile-page');\par
    \},\par
\par
    /**\par
     * Position the tile at |x, y|, and store this as the grid location, i.e.\par
     * where the tile 'belongs' when it's not being dragged.\par
     * @param \{number\} x The x coordinate, in pixels.\par
     * @param \{number\} y The y coordinate, in pixels.\par
     */\par
    setGridPosition: function(x, y) \{\par
      this.gridX = x;\par
      this.gridY = y;\par
      this.moveTo(x, y);\par
    \},\par
\par
    /**\par
     * Position the tile at |x, y|.\par
     * @param \{number\} x The x coordinate, in pixels.\par
     * @param \{number\} y The y coordinate, in pixels.\par
     */\par
    moveTo: function(x, y) \{\par
      // left overrides right in LTR, and right takes precedence in RTL.\par
      this.style.left = x + 'px';\par
      this.style.right = x + 'px';\par
      this.style.top = y + 'px';\par
    \},\par
\par
    /**\par
     * The handler for dragstart events fired on |this|.\par
     * @param \{Event\} e The event for the drag.\par
     * @private\par
     */\par
    onDragStart_: function(e) \{\par
      // The user may start dragging again during a previous drag's finishing\par
      // animation.\par
      if (this.classList.contains('dragging'))\par
        this.finalizeDrag_();\par
\par
      setCurrentlyDraggingTile(this);\par
\par
      e.dataTransfer.effectAllowed = 'copyMove';\par
      this.firstChild.setDragData(e.dataTransfer);\par
\par
      // The drag clone is the node we use as a representation during the drag.\par
      // It's attached to the top level document element so that it floats above\par
      // image masks.\par
      this.dragClone = this.cloneNode(true);\par
      this.dragClone.style.right = '';\par
      this.dragClone.classList.add('drag-representation');\par
      $('card-slider-frame').appendChild(this.dragClone);\par
      this.eventTracker.add(this.dragClone, 'webkitTransitionEnd',\par
                            this.onDragCloneTransitionEnd_.bind(this));\par
\par
      this.classList.add('dragging');\par
      // offsetLeft is mirrored in RTL. Un-mirror it.\par
      var offsetLeft = isRTL() ?\par
          this.parentNode.clientWidth - this.offsetLeft :\par
          this.offsetLeft;\par
      this.dragOffsetX = e.x - offsetLeft - this.parentNode.offsetLeft;\par
      this.dragOffsetY = e.y - this.offsetTop -\par
          // Unlike offsetTop, this value takes scroll position into account.\par
          this.parentNode.getBoundingClientRect().top;\par
\par
      this.onDragMove_(e);\par
    \},\par
\par
    /**\par
     * The handler for drag events fired on |this|.\par
     * @param \{Event\} e The event for the drag.\par
     * @private\par
     */\par
    onDragMove_: function(e) \{\par
      if (e.view != window || (e.x == 0 && e.y == 0)) \{\par
        this.dragClone.hidden = true;\par
        return;\par
      \}\par
\par
      this.dragClone.hidden = false;\par
      this.dragClone.style.left = (e.x - this.dragOffsetX) + 'px';\par
      this.dragClone.style.top = (e.y - this.dragOffsetY) + 'px';\par
    \},\par
\par
    /**\par
     * The handler for dragend events fired on |this|.\par
     * @param \{Event\} e The event for the drag.\par
     * @private\par
     */\par
    onDragEnd_: function(e) \{\par
      this.dragClone.hidden = false;\par
      this.dragClone.classList.add('placing');\par
\par
      setCurrentlyDraggingTile(null);\par
\par
      // tilePage will be null if we've already been removed.\par
      var tilePage = this.tilePage;\par
      if (tilePage)\par
        tilePage.positionTile_(this.index);\par
\par
      // Take an appropriate action with the drag clone.\par
      if (this.landedOnTrash) \{\par
        this.dragClone.classList.add('deleting');\par
      \} else if (tilePage) \{\par
        // TODO(dbeam): Until we fix dropEffect to the correct behavior it will\par
        // differ on windows - crbug.com/39399.  That's why we use the custom\par
        // this.lastDropEffect instead of e.dataTransfer.dropEffect.\par
        if (tilePage.selected && this.lastDropEffect != 'copy') \{\par
          // The drag clone can still be hidden from the last drag move event.\par
          this.dragClone.hidden = false;\par
          // The tile's contents may have moved following the respositioning;\par
          // adjust for that.\par
          var contentDiffX = this.dragClone.firstChild.offsetLeft -\par
              this.firstChild.offsetLeft;\par
          var contentDiffY = this.dragClone.firstChild.offsetTop -\par
              this.firstChild.offsetTop;\par
          this.dragClone.style.left = (this.gridX + this.parentNode.offsetLeft -\par
              contentDiffX) + 'px';\par
          this.dragClone.style.top =\par
              (this.gridY + this.parentNode.getBoundingClientRect().top -\par
              contentDiffY) + 'px';\par
        \} else if (this.dragClone.hidden) \{\par
          this.finalizeDrag_();\par
        \} else \{\par
          // The CSS3 transitions spec intentionally leaves it up to individual\par
          // user agents to determine when styles should be applied. On some\par
          // platforms (at the moment, Windows), when you apply both classes\par
          // immediately a transition may not occur correctly. That's why we're\par
          // using a setTimeout here to queue adding the class until the\par
          // previous class (currently: .placing) sets up a transition.\par
          // {{\field{\*\fldinst{HYPERLINK http://dev.w3.org/csswg/css3-transitions/#starting }}{\fldrslt{http://dev.w3.org/csswg/css3-transitions/#starting\ul0\cf0}}}}\f0\fs22\par
          window.setTimeout(function() \{\par
            if (this.dragClone)\par
              this.dragClone.classList.add('dropped-on-other-page');\par
          \}.bind(this), 0);\par
        \}\par
      \}\par
\par
      delete this.lastDropEffect;\par
      this.landedOnTrash = false;\par
    \},\par
\par
    /**\par
     * Creates a clone of this node offset by the coordinates. Used for the\par
     * dragging effect where a tile appears to float off one side of the grid\par
     * and re-appear on the other.\par
     * @param \{number\} x x-axis offset, in pixels.\par
     * @param \{number\} y y-axis offset, in pixels.\par
     */\par
    showDoppleganger: function(x, y) \{\par
      // We always have to clear the previous doppleganger to make sure we get\par
      // style updates for the contents of this tile.\par
      this.clearDoppleganger();\par
\par
      var clone = this.cloneNode(true);\par
      clone.classList.remove('real');\par
      clone.classList.add('doppleganger');\par
      var clonelets = clone.querySelectorAll('.real');\par
      for (var i = 0; i < clonelets.length; i++) \{\par
        clonelets[i].classList.remove('real');\par
      \}\par
\par
      this.appendChild(clone);\par
      this.doppleganger_ = clone;\par
\par
      if (isRTL())\par
        x *= -1;\par
\par
      this.doppleganger_.style.WebkitTransform = 'translate(' + x + 'px, ' +\par
                                                                y + 'px)';\par
    \},\par
\par
    /**\par
     * Destroys the current doppleganger.\par
     */\par
    clearDoppleganger: function() \{\par
      if (this.doppleganger_) \{\par
        this.removeChild(this.doppleganger_);\par
        this.doppleganger_ = null;\par
      \}\par
    \},\par
\par
    /**\par
     * Returns status of doppleganger.\par
     * @return \{boolean\} True if there is a doppleganger showing for |this|.\par
     */\par
    hasDoppleganger: function() \{\par
      return !!this.doppleganger_;\par
    \},\par
\par
    /**\par
     * Cleans up after the drag is over. This is either called when the\par
     * drag representation finishes animating to the final position, or when\par
     * the next drag starts (if the user starts a 2nd drag very quickly).\par
     * @private\par
     */\par
    finalizeDrag_: function() \{\par
      assert(this.classList.contains('dragging'));\par
\par
      var clone = this.dragClone;\par
      this.dragClone = null;\par
\par
      clone.parentNode.removeChild(clone);\par
      this.eventTracker.remove(clone, 'webkitTransitionEnd');\par
      this.classList.remove('dragging');\par
      if (this.firstChild.finalizeDrag)\par
        this.firstChild.finalizeDrag();\par
    \},\par
\par
    /**\par
     * Called when the drag representation node is done migrating to its final\par
     * resting spot.\par
     * @param \{Event\} e The transition end event.\par
     */\par
    onDragCloneTransitionEnd_: function(e) \{\par
      if (this.classList.contains('dragging') &&\par
          (e.propertyName == 'left' || e.propertyName == 'top' ||\par
           e.propertyName == '-webkit-transform')) \{\par
        this.finalizeDrag_();\par
      \}\par
    \},\par
\par
    /**\par
     * Called when an app is removed from Chrome. Animates its disappearance.\par
     * @param \{boolean=\} opt_animate Whether the animation should be animated.\par
     */\par
    doRemove: function(opt_animate) \{\par
      if (opt_animate)\par
        this.firstChild.classList.add('removing-tile-contents');\par
      else\par
        this.tilePage.removeTile(this, false);\par
    \},\par
\par
    /**\par
     * Callback for the webkitAnimationEnd event on the tile's contents.\par
     * @param \{Event\} e The event object.\par
     */\par
    onContentsAnimationEnd_: function(e) \{\par
      if (this.firstChild.classList.contains('new-tile-contents'))\par
        this.firstChild.classList.remove('new-tile-contents');\par
      if (this.firstChild.classList.contains('removing-tile-contents'))\par
        this.tilePage.removeTile(this, true);\par
    \},\par
  \};\par
\par
  /**\par
   * Gives the proportion of the row width that is devoted to a single icon.\par
   * @param \{number\} rowTileCount The number of tiles in a row.\par
   * @param \{number\} tileSpacingFraction The proportion of the tile width which\par
   *     will be used as spacing between tiles.\par
   * @return \{number\} The ratio between icon width and row width.\par
   */\par
  function tileWidthFraction(rowTileCount, tileSpacingFraction) \{\par
    return rowTileCount + (rowTileCount - 1) * tileSpacingFraction;\par
  \}\par
\par
  /**\par
   * Calculates an assortment of tile-related values for a grid with the\par
   * given dimensions.\par
   * @param \{number\} width The pixel width of the grid.\par
   * @param \{number\} numRowTiles The number of tiles in a row.\par
   * @param \{number\} tileSpacingFraction The proportion of the tile width which\par
   *     will be used as spacing between tiles.\par
   * @return \{Object\} A mapping of pixel values.\par
   */\par
  function tileValuesForGrid(width, numRowTiles, tileSpacingFraction) \{\par
    var tileWidth = width / tileWidthFraction(numRowTiles, tileSpacingFraction);\par
    var offsetX = tileWidth * (1 + tileSpacingFraction);\par
    var interTileSpacing = offsetX - tileWidth;\par
\par
    return \{\par
      tileWidth: tileWidth,\par
      offsetX: offsetX,\par
      interTileSpacing: interTileSpacing,\par
    \};\par
  \}\par
\par
  // The smallest amount of horizontal blank space to display on the sides when\par
  // displaying a wide arrangement. There is an additional 26px of margin from\par
  // the tile page padding.\par
  var MIN_WIDE_MARGIN = 18;\par
\par
  /**\par
   * Creates a new TilePage object. This object contains tiles and controls\par
   * their layout.\par
   * @param \{Object\} gridValues Pixel values that define the size and layout\par
   *     of the tile grid.\par
   * @constructor\par
   * @extends \{HTMLDivElement\}\par
   */\par
  function TilePage(gridValues) \{\par
    var el = cr.doc.createElement('div');\par
    el.gridValues_ = gridValues;\par
    el.__proto__ = TilePage.prototype;\par
    el.initialize();\par
\par
    return el;\par
  \}\par
\par
  /**\par
   * Takes a collection of grid layout pixel values and updates them with\par
   * additional tiling values that are calculated from TilePage constants.\par
   * @param \{Object\} grid The grid layout pixel values to update.\par
   */\par
  TilePage.initGridValues = function(grid) \{\par
    // The amount of space we need to display a narrow grid (all narrow grids\par
    // are this size).\par
    grid.narrowWidth =\par
        grid.minTileWidth * tileWidthFraction(grid.minColCount,\par
                                              grid.tileSpacingFraction);\par
    // The minimum amount of space we need to display a wide grid.\par
    grid.minWideWidth =\par
        grid.minTileWidth * tileWidthFraction(grid.maxColCount,\par
                                              grid.tileSpacingFraction);\par
    // The largest we will ever display a wide grid.\par
    grid.maxWideWidth =\par
        grid.maxTileWidth * tileWidthFraction(grid.maxColCount,\par
                                              grid.tileSpacingFraction);\par
    // Tile-related pixel values for the narrow display.\par
    grid.narrowTileValues = tileValuesForGrid(grid.narrowWidth,\par
                                              grid.minColCount,\par
                                              grid.tileSpacingFraction);\par
    // Tile-related pixel values for the minimum narrow display.\par
    grid.wideTileValues = tileValuesForGrid(grid.minWideWidth,\par
                                            grid.maxColCount,\par
                                            grid.tileSpacingFraction);\par
  \};\par
\par
  TilePage.prototype = \{\par
    __proto__: HTMLDivElement.prototype,\par
\par
    initialize: function() \{\par
      this.className = 'tile-page';\par
\par
      // Div that acts as a custom scrollbar. The scrollbar has to live\par
      // outside the content div so it doesn't flicker when scrolling (due to\par
      // repainting after the scroll, then repainting again when moved in the\par
      // onScroll handler). |scrollbar_| is only aesthetic, and it only\par
      // represents the thumb. Actual events are still handled by the invisible\par
      // native scrollbars. This div gives us more flexibility with the visuals.\par
      this.scrollbar_ = this.ownerDocument.createElement('div');\par
      this.scrollbar_.className = 'tile-page-scrollbar';\par
      this.scrollbar_.hidden = true;\par
      this.appendChild(this.scrollbar_);\par
\par
      // This contains everything but the scrollbar.\par
      this.content_ = this.ownerDocument.createElement('div');\par
      this.content_.className = 'tile-page-content';\par
      this.appendChild(this.content_);\par
\par
      // Div that sets the vertical position of the tile grid.\par
      this.topMargin_ = this.ownerDocument.createElement('div');\par
      this.topMargin_.className = 'top-margin';\par
      this.content_.appendChild(this.topMargin_);\par
\par
      // Div that holds the tiles.\par
      this.tileGrid_ = this.ownerDocument.createElement('div');\par
      this.tileGrid_.className = 'tile-grid';\par
      this.tileGrid_.style.minWidth = this.gridValues_.narrowWidth + 'px';\par
      this.content_.appendChild(this.tileGrid_);\par
\par
      // Ordered list of our tiles.\par
      this.tileElements_ = this.tileGrid_.getElementsByClassName('tile real');\par
      // Ordered list of the elements which want to accept keyboard focus. These\par
      // elements will not be a part of the normal tab order; the tile grid\par
      // initially gets focused and then these elements can be focused via the\par
      // arrow keys.\par
      this.focusableElements_ =\par
          this.tileGrid_.getElementsByClassName('focusable');\par
\par
      // These are properties used in updateTopMargin.\par
      this.animatedTopMarginPx_ = 0;\par
      this.topMarginPx_ = 0;\par
\par
      this.eventTracker = new EventTracker();\par
      this.eventTracker.add(window, 'resize', this.onResize_.bind(this));\par
\par
      this.addEventListener('DOMNodeInsertedIntoDocument',\par
                            this.onNodeInsertedIntoDocument_);\par
\par
      this.addEventListener('mousewheel', this.onMouseWheel_);\par
      this.content_.addEventListener('scroll', this.onScroll_.bind(this));\par
\par
      this.dragWrapper_ = new cr.ui.DragWrapper(this.tileGrid_, this);\par
\par
      this.addEventListener('cardselected', this.handleCardSelection_);\par
      this.addEventListener('carddeselected', this.handleCardDeselection_);\par
      this.addEventListener('focus', this.handleFocus_);\par
      this.addEventListener('keydown', this.handleKeyDown_);\par
      this.addEventListener('mousedown', this.handleMouseDown_);\par
\par
      this.focusElementIndex_ = -1;\par
    \},\par
\par
    get tiles() \{\par
      return this.tileElements_;\par
    \},\par
\par
    get tileCount() \{\par
      return this.tileElements_.length;\par
    \},\par
\par
    get selected() \{\par
      return Array.prototype.indexOf.call(this.parentNode.children, this) ==\par
          ntp4.getCardSlider().currentCard;\par
    \},\par
\par
    /**\par
     * The size of the margin (unused space) on the sides of the tile grid, in\par
     * pixels.\par
     * @type \{number\}\par
     */\par
    get sideMargin() \{\par
      return this.layoutValues_.leftMargin;\par
    \},\par
\par
    /**\par
     * Returns the width of the scrollbar, in pixels, if it is active, or 0\par
     * otherwise.\par
     * @type \{number\}\par
     */\par
    get scrollbarWidth() \{\par
      return this.scrollbar_.hidden ? 0 : 13;\par
    \},\par
\par
    /**\par
     * Returns any extra padding to insert to the bottom of a tile page.  By\par
     * default there is none, but subclasses can override.\par
     * @type \{number\}\par
     */\par
    get extraBottomPadding() \{\par
      return 0;\par
    \},\par
\par
    /**\par
     * Removes the tilePage from the DOM and cleans up event handlers.\par
     */\par
    remove: function() \{\par
      // This checks arguments.length as most remove functions have a boolean\par
      // |opt_animate| argument, but that's not necesarilly applicable to\par
      // removing a tilePage. Selecting a different card in an animated way and\par
      // deleting the card afterward is probably a better choice.\par
      assert(typeof arguments[0] != 'boolean',\par
             'This function takes no |opt_animate| argument.');\par
      this.tearDown_();\par
      this.parentNode.removeChild(this);\par
    \},\par
\par
    /**\par
     * Cleans up resources that are no longer needed after this TilePage\par
     * instance is removed from the DOM.\par
     * @private\par
     */\par
    tearDown_: function() \{\par
      this.eventTracker.removeAll();\par
    \},\par
\par
    /**\par
     * Appends a tile to the end of the tile grid.\par
     * @param \{HTMLElement\} tileElement The contents of the tile.\par
     * @param \{?boolean\} animate If true, the append will be animated.\par
     * @protected\par
     */\par
    appendTile: function(tileElement, animate) \{\par
      this.addTileAt(tileElement, this.tileElements_.length, animate);\par
    \},\par
\par
    /**\par
     * Adds the given element to the tile grid.\par
     * @param \{Node\} tileElement The tile object/node to insert.\par
     * @param \{number\} index The location in the tile grid to insert it at.\par
     * @param \{boolean=\} opt_animate If true, the tile in question will be\par
     *     animated (other tiles, if they must reposition, do not animate).\par
     * @protected\par
     */\par
    addTileAt: function(tileElement, index, opt_animate) \{\par
      this.classList.remove('animating-tile-page');\par
      if (opt_animate)\par
        tileElement.classList.add('new-tile-contents');\par
\par
      // Make sure the index is positive and either in the the bounds of\par
      // this.tileElements_ or at the end (meaning append).\par
      assert(index >= 0 && index <= this.tileElements_.length);\par
\par
      var wrapperDiv = new Tile(tileElement);\par
      // If is out of the bounds of the tile element list, .insertBefore() will\par
      // act just like appendChild().\par
      this.tileGrid_.insertBefore(wrapperDiv, this.tileElements_[index]);\par
      this.calculateLayoutValues_();\par
      this.heightChanged_();\par
\par
      this.positionTile_(index);\par
      this.fireAddedEvent(wrapperDiv, index, !!opt_animate);\par
    \},\par
\par
    /**\par
     * Notify interested subscribers that a tile has been removed from this\par
     * page.\par
     * @param \{Tile\} tile The newly added tile.\par
     * @param \{number\} index The index of the tile that was added.\par
     * @param \{boolean\} wasAnimated Whether the removal was animated.\par
     */\par
    fireAddedEvent: function(tile, index, wasAnimated) \{\par
      var e = document.createEvent('Event');\par
      e.initEvent('tilePage:tile_added', true, true);\par
      e.addedIndex = index;\par
      e.addedTile = tile;\par
      e.wasAnimated = wasAnimated;\par
      this.dispatchEvent(e);\par
    \},\par
\par
    /**\par
     * Removes the given tile and animates the repositioning of the other tiles.\par
     * @param \{boolean=\} opt_animate Whether the removal should be animated.\par
     * @param \{boolean=\} opt_dontNotify Whether a page should be removed if the\par
     *     last tile is removed from it.\par
     */\par
    removeTile: function(tile, opt_animate, opt_dontNotify) \{\par
      if (opt_animate)\par
        this.classList.add('animating-tile-page');\par
      var index = tile.index;\par
      tile.parentNode.removeChild(tile);\par
      this.calculateLayoutValues_();\par
      this.cleanupDrag();\par
\par
      if (!opt_dontNotify)\par
        this.fireRemovedEvent(tile, index, !!opt_animate);\par
    \},\par
\par
    /**\par
     * Notify interested subscribers that a tile has been removed from this\par
     * page.\par
     * @param \{Tile\} tile The tile that was removed.\par
     * @param \{number\} oldIndex Where the tile was positioned before removal.\par
     * @param \{boolean\} wasAnimated Whether the removal was animated.\par
     */\par
    fireRemovedEvent: function(tile, oldIndex, wasAnimated) \{\par
      var e = document.createEvent('Event');\par
      e.initEvent('tilePage:tile_removed', true, true);\par
      e.removedIndex = oldIndex;\par
      e.removedTile = tile;\par
      e.wasAnimated = wasAnimated;\par
      this.dispatchEvent(e);\par
    \},\par
\par
    /**\par
     * Removes all tiles from the page.\par
     */\par
    removeAllTiles: function() \{\par
      this.tileGrid_.innerHTML = '';\par
    \},\par
\par
    /**\par
     * Called when the page is selected (in the card selector).\par
     * @param \{Event\} e A custom cardselected event.\par
     * @private\par
     */\par
    handleCardSelection_: function(e) \{\par
      this.tabIndex = 1;\par
\par
      // When we are selected, we re-calculate the layout values. (See comment\par
      // in doDrop.)\par
      this.calculateLayoutValues_();\par
    \},\par
\par
    /**\par
     * Called when the page loses selection (in the card selector).\par
     * @param \{Event\} e A custom carddeselected event.\par
     * @private\par
     */\par
    handleCardDeselection_: function(e) \{\par
      this.tabIndex = -1;\par
      if (this.currentFocusElement_)\par
        this.currentFocusElement_.tabIndex = -1;\par
    \},\par
\par
    /**\par
     * When we get focus, pass it on to the focus element.\par
     * @param \{Event\} e The focus event.\par
     * @private\par
     */\par
    handleFocus_: function(e) \{\par
      if (this.focusableElements_.length == 0)\par
        return;\par
\par
      this.updateFocusElement_();\par
    \},\par
\par
    /**\par
     * Since we are doing custom focus handling, we have to manually\par
     * set focusability on click (as well as keyboard nav above).\par
     * @param \{Event\} e The focus event.\par
     * @private\par
     */\par
    handleMouseDown_: function(e) \{\par
      var focusable = findAncestorByClass(e.target, 'focusable');\par
      if (focusable) \{\par
        this.focusElementIndex_ =\par
            Array.prototype.indexOf.call(this.focusableElements_,\par
                                         focusable);\par
        this.updateFocusElement_();\par
      \} else \{\par
        // This prevents the tile page from getting focus when the user clicks\par
        // inside the grid but outside of any tile.\par
        e.preventDefault();\par
      \}\par
    \},\par
\par
    /**\par
     * Handle arrow key focus nav.\par
     * @param \{Event\} e The focus event.\par
     * @private\par
     */\par
    handleKeyDown_: function(e) \{\par
      // We only handle up, down, left, right without control keys.\par
      if (e.metaKey || e.shiftKey || e.altKey || e.ctrlKey)\par
        return;\par
\par
      // Wrap the given index to |this.focusableElements_|.\par
      var wrap = function(idx) \{\par
        return (idx + this.focusableElements_.length) %\par
            this.focusableElements_.length;\par
      \}.bind(this);\par
\par
      switch (e.keyIdentifier) \{\par
        case 'Right':\par
        case 'Left':\par
          var direction = e.keyIdentifier == 'Right' ? 1 : -1;\par
          this.focusElementIndex_ = wrap(this.focusElementIndex_ + direction);\par
          break;\par
        case 'Up':\par
        case 'Down':\par
          // Look through all focusable elements. Find the first one that is\par
          // in the same column.\par
          var direction = e.keyIdentifier == 'Up' ? -1 : 1;\par
          var currentIndex =\par
              Array.prototype.indexOf.call(this.focusableElements_,\par
                                           this.currentFocusElement_);\par
          var newFocusIdx = wrap(currentIndex + direction)\par
          var tile = this.currentFocusElement_.parentNode;\par
          for (;; newFocusIdx = wrap(newFocusIdx + direction)) \{\par
            var newTile = this.focusableElements_[newFocusIdx].parentNode;\par
            var rowTiles = this.layoutValues_.numRowTiles;\par
            if ((newTile.index - tile.index) % rowTiles == 0)\par
              break;\par
          \}\par
\par
          this.focusElementIndex_ = newFocusIdx;\par
          break;\par
\par
        default:\par
          return;\par
      \}\par
\par
      this.updateFocusElement_();\par
\par
      e.preventDefault();\par
      e.stopPropagation();\par
    \},\par
\par
    /**\par
     * Focuses the element for |this.focusElementIndex_|. Makes the current\par
     * focus element, if any, no longer eligible for focus.\par
     * @private\par
     */\par
    updateFocusElement_: function() \{\par
      this.focusElementIndex_ = Math.min(this.focusableElements_.length - 1,\par
                                         this.focusElementIndex_);\par
      this.focusElementIndex_ = Math.max(0, this.focusElementIndex_);\par
\par
      var newFocusElement = this.focusableElements_[this.focusElementIndex_];\par
      var lastFocusElement = this.currentFocusElement_;\par
      if (lastFocusElement && lastFocusElement != newFocusElement)\par
        lastFocusElement.tabIndex = -1;\par
\par
      newFocusElement.tabIndex = 1;\par
      newFocusElement.focus();\par
      this.tabIndex = -1;\par
    \},\par
\par
    /**\par
     * The current focus element is that element which is eligible for focus.\par
     * @type \{HTMLElement\} The node.\par
     * @private\par
     */\par
    get currentFocusElement_() \{\par
      return this.querySelector('.focusable[tabindex="1"]');\par
    \},\par
\par
    /**\par
     * Makes some calculations for tile layout. These change depending on\par
     * height, width, and the number of tiles.\par
     * TODO(estade): optimize calls to this function. Do nothing if the page is\par
     * hidden, but call before being shown.\par
     * @private\par
     */\par
    calculateLayoutValues_: function() \{\par
      var grid = this.gridValues_;\par
      var availableSpace = this.tileGrid_.clientWidth - 2 * MIN_WIDE_MARGIN;\par
      var wide = availableSpace >= grid.minWideWidth;\par
      var numRowTiles = wide ? grid.maxColCount : grid.minColCount;\par
\par
      var effectiveGridWidth = wide ?\par
          Math.min(Math.max(availableSpace, grid.minWideWidth),\par
                   grid.maxWideWidth) :\par
          grid.narrowWidth;\par
      var realTileValues = tileValuesForGrid(effectiveGridWidth, numRowTiles,\par
                                             grid.tileSpacingFraction);\par
\par
      // leftMargin centers the grid within the avaiable space.\par
      var minMargin = wide ? MIN_WIDE_MARGIN : 0;\par
      var leftMargin =\par
          Math.max(minMargin,\par
                   (this.tileGrid_.clientWidth - effectiveGridWidth) / 2);\par
\par
      var rowHeight = this.heightForWidth(realTileValues.tileWidth) +\par
          realTileValues.interTileSpacing;\par
\par
      this.layoutValues_ = \{\par
        numRowTiles: numRowTiles,\par
        leftMargin: leftMargin,\par
        colWidth: realTileValues.offsetX,\par
        rowHeight: rowHeight,\par
        tileWidth: realTileValues.tileWidth,\par
        wide: wide,\par
      \};\par
\par
      // We need to update the top margin as well.\par
      this.updateTopMargin_();\par
\par
      this.firePageLayoutEvent_();\par
    \},\par
\par
    /**\par
     * Dispatches the custom pagelayout event.\par
     * @private\par
     */\par
    firePageLayoutEvent_: function() \{\par
      cr.dispatchSimpleEvent(this, 'pagelayout', true, true);\par
    \},\par
\par
    /**\par
     * Calculates the x/y coordinates for an element and moves it there.\par
     * @param \{number\} index The index of the element to be positioned.\par
     * @param \{number\} indexOffset If provided, this is added to |index| when\par
     *     positioning the tile. The effect is that the tile will be positioned\par
     *     in a non-default location.\par
     * @private\par
     */\par
    positionTile_: function(index, indexOffset) \{\par
      var grid = this.gridValues_;\par
      var layout = this.layoutValues_;\par
\par
      indexOffset = typeof indexOffset != 'undefined' ? indexOffset : 0;\par
      // Add the offset _after_ the modulus division. We might want to show the\par
      // tile off the side of the grid.\par
      var col = index % layout.numRowTiles + indexOffset;\par
      var row = Math.floor(index / layout.numRowTiles);\par
      // Calculate the final on-screen position for the tile.\par
      var realX = col * layout.colWidth + layout.leftMargin;\par
      var realY = row * layout.rowHeight;\par
\par
      // Calculate the portion of the tile's position that should be animated.\par
      var animatedTileValues = layout.wide ?\par
          grid.wideTileValues : grid.narrowTileValues;\par
      // Animate the difference between three-wide and six-wide.\par
      var animatedLeftMargin = layout.wide ?\par
          0 : (grid.minWideWidth - MIN_WIDE_MARGIN - grid.narrowWidth) / 2;\par
      var animatedX = col * animatedTileValues.offsetX + animatedLeftMargin;\par
      var animatedY = row * (this.heightForWidth(animatedTileValues.tileWidth) +\par
                             animatedTileValues.interTileSpacing);\par
\par
      var tile = this.tileElements_[index];\par
      tile.setGridPosition(animatedX, animatedY);\par
      tile.firstChild.setBounds(layout.tileWidth,\par
                                realX - animatedX,\par
                                realY - animatedY);\par
\par
      // This code calculates whether the tile needs to show a clone of itself\par
      // wrapped around the other side of the tile grid.\par
      var offTheRight = col == layout.numRowTiles ||\par
          (col == layout.numRowTiles - 1 && tile.hasDoppleganger());\par
      var offTheLeft = col == -1 || (col == 0 && tile.hasDoppleganger());\par
      if (this.isCurrentDragTarget && (offTheRight || offTheLeft)) \{\par
        var sign = offTheRight ? 1 : -1;\par
        tile.showDoppleganger(-layout.numRowTiles * layout.colWidth * sign,\par
                              layout.rowHeight * sign);\par
      \} else \{\par
        tile.clearDoppleganger();\par
      \}\par
\par
      if (index == this.tileElements_.length - 1) \{\par
        this.tileGrid_.style.height = (realY + layout.rowHeight) + 'px';\par
        this.queueUpdateScrollbars_();\par
      \}\par
    \},\par
\par
    /**\par
     * Gets the index of the tile that should occupy coordinate (x, y). Note\par
     * that this function doesn't care where the tiles actually are, and will\par
     * return an index even for the space between two tiles. This function is\par
     * effectively the inverse of |positionTile_|.\par
     * @param \{number\} x The x coordinate, in pixels, relative to the left of\par
     *     |this|.\par
     * @param \{number\} y The y coordinate, in pixels, relative to the top of\par
     *     |this|.\par
     * @private\par
     */\par
    getWouldBeIndexForPoint_: function(x, y) \{\par
      var grid = this.gridValues_;\par
      var layout = this.layoutValues_;\par
\par
      var gridClientRect = this.tileGrid_.getBoundingClientRect();\par
      var col = Math.floor((x - gridClientRect.left - layout.leftMargin) /\par
                           layout.colWidth);\par
      if (col < 0 || col >= layout.numRowTiles)\par
        return -1;\par
\par
      if (isRTL())\par
        col = layout.numRowTiles - 1 - col;\par
\par
      var row = Math.floor((y - gridClientRect.top) / layout.rowHeight);\par
      return row * layout.numRowTiles + col;\par
    \},\par
\par
    /**\par
     * Window resize event handler. Window resizes may trigger re-layouts.\par
     * @param \{Object\} e The resize event.\par
     */\par
    onResize_: function(e) \{\par
      if (this.lastWidth_ == this.clientWidth &&\par
          this.lastHeight_ == this.clientHeight) \{\par
        return;\par
      \}\par
\par
      this.calculateLayoutValues_();\par
\par
      this.lastWidth_ = this.clientWidth;\par
      this.lastHeight_ = this.clientHeight;\par
      this.classList.add('animating-tile-page');\par
      this.heightChanged_();\par
\par
      this.repositionTiles_();\par
    \},\par
\par
    /**\par
     * The tile grid has an image mask which fades at the edges. We only show\par
     * the mask when there is an active drag; it obscures doppleganger tiles\par
     * as they enter or exit the grid.\par
     * @private\par
     */\par
    updateMask_: function() \{\par
      if (!this.isCurrentDragTarget) \{\par
        this.tileGrid_.style.WebkitMaskBoxImage = '';\par
        return;\par
      \}\par
\par
      var leftMargin = this.layoutValues_.leftMargin;\par
      // The fade distance is the space between tiles.\par
      var fadeDistance = (this.gridValues_.tileSpacingFraction *\par
          this.layoutValues_.tileWidth);\par
      fadeDistance = Math.min(leftMargin, fadeDistance);\par
      // On Skia we don't use any fade because it works very poorly. See\par
      // {{\field{\*\fldinst{HYPERLINK http://crbug.com/99373 }}{\fldrslt{http://crbug.com/99373\ul0\cf0}}}}\f0\fs22\par
      if (!cr.isMac)\par
        fadeDistance = 1;\par
      var gradient =\par
          '-webkit-linear-gradient(left,' +\par
              'transparent, ' +\par
              'transparent ' + (leftMargin - fadeDistance) + 'px, ' +\par
              'black ' + leftMargin + 'px, ' +\par
              'black ' + (this.tileGrid_.clientWidth - leftMargin) + 'px, ' +\par
              'transparent ' + (this.tileGrid_.clientWidth - leftMargin +\par
                                fadeDistance) + 'px, ' +\par
              'transparent)';\par
      this.tileGrid_.style.WebkitMaskBoxImage = gradient;\par
    \},\par
\par
    updateTopMargin_: function() \{\par
      var layout = this.layoutValues_;\par
\par
      // The top margin is set so that the vertical midpoint of the grid will\par
      // be 1/3 down the page.\par
      var numTiles = this.tileCount +\par
          (this.isCurrentDragTarget && !this.withinPageDrag_ ? 1 : 0);\par
      var numRows = Math.ceil(numTiles / layout.numRowTiles);\par
      var usedHeight = layout.rowHeight * numRows;\par
      // 60 matches the top padding of tile-page (which acts as the minimum).\par
      var newMargin = document.documentElement.clientHeight / 3 -\par
          usedHeight / 3 - 60;\par
      newMargin = Math.max(newMargin, 0);\par
\par
      // |newMargin| is the final margin we actually want to show. However,\par
      // part of that should be animated and part should not (for the same\par
      // reason as with leftMargin). The approach is to consider differences\par
      // when the layout changes from wide to narrow or vice versa as\par
      // 'animatable'. These differences accumulate in animatedTopMarginPx_,\par
      // while topMarginPx_ caches the real (total) margin. Either of these\par
      // calculations may come out to be negative, so we use margins as the\par
      // css property.\par
\par
      if (typeof this.topMarginIsForWide_ == 'undefined')\par
        this.topMarginIsForWide_ = layout.wide;\par
      if (this.topMarginIsForWide_ != layout.wide) \{\par
        this.animatedTopMarginPx_ += newMargin - this.topMarginPx_;\par
        this.topMargin_.style.marginBottom =\par
            this.animatedTopMarginPx_ + 'px';\par
      \}\par
\par
      this.topMarginIsForWide_ = layout.wide;\par
      this.topMarginPx_ = newMargin;\par
      this.topMargin_.style.marginTop =\par
          (this.topMarginPx_ - this.animatedTopMarginPx_) + 'px';\par
    \},\par
\par
    /**\par
     * Handles final setup that can only happen after |this| is inserted into\par
     * the page.\par
     * @private\par
     */\par
    onNodeInsertedIntoDocument_: function(e) \{\par
      this.calculateLayoutValues_();\par
      this.heightChanged_();\par
    \},\par
\par
    /**\par
     * Called when the height of |this| has changed: update the size of\par
     * tileGrid.\par
     * @private\par
     */\par
    heightChanged_: function() \{\par
      // The tile grid will expand to the bottom footer, or enough to hold all\par
      // the tiles, whichever is greater. It would be nicer if tilePage were\par
      // a flex box, and the tile grid could be box-flex: 1, but this exposes a\par
      // bug where repositioning tiles will cause the scroll position to reset.\par
      this.tileGrid_.style.minHeight = (this.clientHeight -\par
          this.tileGrid_.offsetTop - this.content_.offsetTop -\par
          this.extraBottomPadding) + 'px';\par
    \},\par
\par
    /**\par
     * Scrolls the page in response to a mousewheel event.\par
     * @param \{Event\} e The mousewheel event.\par
     */\par
    handleMouseWheel: function(e) \{\par
      this.content_.scrollTop -= e.wheelDeltaY / 3;\par
    \},\par
\par
    /**\par
     * Handles mouse wheels on |this|. We handle this explicitly because we want\par
     * a consistent experience whether the user scrolls on the page or on the\par
     * page switcher (handleMouseWheel provides a common conversion factor\par
     * between wheel delta and scroll delta).\par
     * @param \{Event\} e The mousewheel event.\par
     * @private\par
     */\par
    onMouseWheel_: function(e) \{\par
      if (e.wheelDeltaY == 0)\par
        return;\par
\par
      this.handleMouseWheel(e);\par
      e.preventDefault();\par
      e.stopPropagation();\par
    \},\par
\par
    /**\par
     * Handler for the 'scroll' event on |content_|.\par
     * @param \{Event\} e The scroll event.\par
     * @private\par
     */\par
    onScroll_: function(e) \{\par
      this.queueUpdateScrollbars_();\par
    \},\par
\par
    /**\par
     * ID of scrollbar update timer. If 0, there's no scrollbar re-calc queued.\par
     * @private\par
     */\par
    scrollbarUpdate_: 0,\par
\par
    /**\par
     * Queues an update on the custom scrollbar. Used for two reasons: first,\par
     * coalescing of multiple updates, and second, because action like\par
     * repositioning a tile can require a delay before they affect values\par
     * like clientHeight.\par
     * @private\par
     */\par
    queueUpdateScrollbars_: function() \{\par
      if (this.scrollbarUpdate_)\par
        return;\par
\par
      this.scrollbarUpdate_ = window.setTimeout(\par
          this.doUpdateScrollbars_.bind(this), 0);\par
    \},\par
\par
    /**\par
     * Does the work of calculating the visibility, height and position of the\par
     * scrollbar thumb (there is no track or buttons).\par
     * @private\par
     */\par
    doUpdateScrollbars_: function() \{\par
      this.scrollbarUpdate_ = 0;\par
\par
      var content = this.content_;\par
\par
      // Adjust scroll-height to account for possible header-bar.\par
      var adjustedScrollHeight = content.scrollHeight - content.offsetTop;\par
\par
      if (adjustedScrollHeight <= content.clientHeight) \{\par
        this.scrollbar_.hidden = true;\par
        return;\par
      \} else \{\par
        this.scrollbar_.hidden = false;\par
      \}\par
\par
      var thumbTop = content.offsetTop +\par
          content.scrollTop / adjustedScrollHeight * content.clientHeight;\par
      var thumbHeight = content.clientHeight / adjustedScrollHeight *\par
          this.clientHeight;\par
\par
      this.scrollbar_.style.top = thumbTop + 'px';\par
      this.scrollbar_.style.height = thumbHeight + 'px';\par
      this.firePageLayoutEvent_();\par
    \},\par
\par
    /**\par
     * Get the height for a tile of a certain width. Override this function to\par
     * get non-square tiles.\par
     * @param \{number\} width The pixel width of a tile.\par
     * @return \{number\} The height for |width|.\par
     */\par
    heightForWidth: function(width) \{\par
      return width;\par
    \},\par
\par
    /** Dragging **/\par
\par
    get isCurrentDragTarget() \{\par
      return this.dragWrapper_.isCurrentDragTarget;\par
    \},\par
\par
    /**\par
     * Thunk for dragleave events fired on |tileGrid_|.\par
     * @param \{Event\} e A MouseEvent for the drag.\par
     */\par
    doDragLeave: function(e) \{\par
      this.cleanupDrag();\par
    \},\par
\par
    /**\par
     * Performs all actions necessary when a drag enters the tile page.\par
     * @param \{Event\} e A mouseover event for the drag enter.\par
     */\par
    doDragEnter: function(e) \{\par
\par
      // Applies the mask so doppleganger tiles disappear into the fog.\par
      this.updateMask_();\par
\par
      this.classList.add('animating-tile-page');\par
      this.withinPageDrag_ = this.contains(currentlyDraggingTile);\par
      this.dragItemIndex_ = this.withinPageDrag_ ?\par
          currentlyDraggingTile.index : this.tileElements_.length;\par
      this.currentDropIndex_ = this.dragItemIndex_;\par
\par
      // The new tile may change the number of rows, hence the top margin\par
      // will change.\par
      if (!this.withinPageDrag_)\par
        this.updateTopMargin_();\par
\par
      this.doDragOver(e);\par
    \},\par
\par
    /**\par
     * Performs all actions necessary when the user moves the cursor during\par
     * a drag over the tile page.\par
     * @param \{Event\} e A mouseover event for the drag over.\par
     */\par
    doDragOver: function(e) \{\par
      e.preventDefault();\par
\par
      this.setDropEffect(e.dataTransfer);\par
      var newDragIndex = this.getWouldBeIndexForPoint_(e.pageX, e.pageY);\par
      if (newDragIndex < 0 || newDragIndex >= this.tileElements_.length)\par
        newDragIndex = this.dragItemIndex_;\par
      this.updateDropIndicator_(newDragIndex);\par
    \},\par
\par
    /**\par
     * Performs all actions necessary when the user completes a drop.\par
     * @param \{Event\} e A mouseover event for the drag drop.\par
     */\par
    doDrop: function(e) \{\par
      e.stopPropagation();\par
\par
      var index = this.currentDropIndex_;\par
      // Only change data if this was not a 'null drag'.\par
      if (!((index == this.dragItemIndex_) && this.withinPageDrag_)) \{\par
        var adjustedIndex = this.currentDropIndex_ +\par
            (index > this.dragItemIndex_ ? 1 : 0);\par
        if (this.withinPageDrag_) \{\par
          this.tileGrid_.insertBefore(\par
              currentlyDraggingTile,\par
              this.tileElements_[adjustedIndex]);\par
          this.tileMoved(currentlyDraggingTile, this.dragItemIndex_);\par
        \} else \{\par
          var originalPage = currentlyDraggingTile ?\par
              currentlyDraggingTile.tilePage : null;\par
          this.addDragData(e.dataTransfer, adjustedIndex);\par
          if (originalPage)\par
            originalPage.cleanupDrag();\par
        \}\par
\par
        // Dropping the icon may cause topMargin to change, but changing it\par
        // now would cause everything to move (annoying), so we leave it\par
        // alone. The top margin will be re-calculated next time the window is\par
        // resized or the page is selected.\par
      \}\par
\par
      this.classList.remove('animating-tile-page');\par
      this.cleanupDrag();\par
    \},\par
\par
    /**\par
     * Appends the currently dragged tile to the end of the page. Called\par
     * from outside the page, e.g. when dropping on a nav dot.\par
     */\par
    appendDraggingTile: function() \{\par
      var originalPage = currentlyDraggingTile.tilePage;\par
      if (originalPage == this)\par
        return;\par
\par
      this.addDragData(null, this.tileElements_.length);\par
      if (originalPage)\par
        originalPage.cleanupDrag();\par
    \},\par
\par
    /**\par
     * Makes sure all the tiles are in the right place after a drag is over.\par
     */\par
    cleanupDrag: function() \{\par
      this.repositionTiles_(currentlyDraggingTile);\par
      // Remove the drag mask.\par
      this.updateMask_();\par
    \},\par
\par
    /**\par
     * Reposition all the tiles (possibly ignoring one).\par
     * @param \{?Node\} ignoreNode An optional node to ignore.\par
     * @private\par
     */\par
    repositionTiles_: function(ignoreNode) \{\par
      for (var i = 0; i < this.tileElements_.length; i++) \{\par
        if (!ignoreNode || ignoreNode !== this.tileElements_[i])\par
          this.positionTile_(i);\par
      \}\par
    \},\par
\par
    /**\par
     * Updates the visual indicator for the drop location for the active drag.\par
     * @param \{Event\} e A MouseEvent for the drag.\par
     * @private\par
     */\par
    updateDropIndicator_: function(newDragIndex) \{\par
      var oldDragIndex = this.currentDropIndex_;\par
      if (newDragIndex == oldDragIndex)\par
        return;\par
\par
      var repositionStart = Math.min(newDragIndex, oldDragIndex);\par
      var repositionEnd = Math.max(newDragIndex, oldDragIndex);\par
\par
      for (var i = repositionStart; i <= repositionEnd; i++) \{\par
        if (i == this.dragItemIndex_)\par
          continue;\par
        else if (i > this.dragItemIndex_)\par
          var adjustment = i <= newDragIndex ? -1 : 0;\par
        else\par
          var adjustment = i >= newDragIndex ? 1 : 0;\par
\par
        this.positionTile_(i, adjustment);\par
      \}\par
      this.currentDropIndex_ = newDragIndex;\par
    \},\par
\par
    /**\par
     * Checks if a page can accept a drag with the given data.\par
     * @param \{Event\} e The drag event if the drag object. Implementations will\par
     *     likely want to check |e.dataTransfer|.\par
     * @return \{boolean\} True if this page can handle the drag.\par
     */\par
    shouldAcceptDrag: function(e) \{\par
      return false;\par
    \},\par
\par
    /**\par
     * Called to accept a drag drop. Will not be called for in-page drops.\par
     * @param \{Object\} dataTransfer The data transfer object that holds the drop\par
     *     data. This should only be used if currentlyDraggingTile is null.\par
     * @param \{number\} index The tile index at which the drop occurred.\par
     */\par
    addDragData: function(dataTransfer, index) \{\par
      assert(false);\par
    \},\par
\par
    /**\par
     * Called when a tile has been moved (via dragging). Override this to make\par
     * backend updates.\par
     * @param \{Node\} draggedTile The tile that was dropped.\par
     * @param \{number\} prevIndex The previous index of the tile.\par
     */\par
    tileMoved: function(draggedTile, prevIndex) \{\par
    \},\par
\par
    /**\par
     * Sets the drop effect on |dataTransfer| to the desired value (e.g.\par
     * 'copy').\par
     * @param \{Object\} dataTransfer The drag event dataTransfer object.\par
     */\par
    setDropEffect: function(dataTransfer) \{\par
      assert(false);\par
    \},\par
  \};\par
\par
  return \{\par
    getCurrentlyDraggingTile: getCurrentlyDraggingTile,\par
    setCurrentDropEffect: setCurrentDropEffect,\par
    TilePage: TilePage,\par
  \};\par
\});\par
</script>\par
<script>// Copyright (c) 2012 The Chromium Authors. All rights reserved.\par
// Use of this source code is governed by a BSD-style license that can be\par
// found in the LICENSE file.\par
\par
cr.define('ntp4', function() \{\par
  'use strict';\par
\par
  var localStrings = new LocalStrings;\par
\par
  var APP_LAUNCH = \{\par
    // The histogram buckets (keep in sync with extension_constants.h).\par
    NTP_APPS_MAXIMIZED: 0,\par
    NTP_APPS_COLLAPSED: 1,\par
    NTP_APPS_MENU: 2,\par
    NTP_MOST_VISITED: 3,\par
    NTP_RECENTLY_CLOSED: 4,\par
    NTP_APP_RE_ENABLE: 16,\par
    NTP_WEBSTORE_FOOTER: 18,\par
  \};\par
\par
  // Histogram buckets for UMA tracking of where a DnD drop came from.\par
  var DRAG_SOURCE = \{\par
    SAME_APPS_PANE: 0,\par
    OTHER_APPS_PANE: 1,\par
    MOST_VISITED_PANE: 2,\par
    BOOKMARKS_PANE: 3,\par
    OUTSIDE_NTP: 4\par
  \};\par
  var DRAG_SOURCE_LIMIT = DRAG_SOURCE.OUTSIDE_NTP + 1;\par
\par
  /**\par
   * App context menu. The class is designed to be used as a singleton with\par
   * the app that is currently showing a context menu stored in this.app_.\par
   * @constructor\par
   */\par
  function AppContextMenu() \{\par
    this.__proto__ = AppContextMenu.prototype;\par
    this.initialize();\par
  \}\par
  cr.addSingletonGetter(AppContextMenu);\par
\par
  AppContextMenu.prototype = \{\par
    initialize: function() \{\par
      var menu = new cr.ui.Menu;\par
      cr.ui.decorate(menu, cr.ui.Menu);\par
      menu.classList.add('app-context-menu');\par
      this.menu = menu;\par
\par
      this.launch_ = this.appendMenuItem_();\par
      this.launch_.addEventListener('activate', this.onLaunch_.bind(this));\par
\par
      menu.appendChild(cr.ui.MenuItem.createSeparator());\par
      this.launchRegularTab_ = this.appendMenuItem_('applaunchtyperegular');\par
      this.launchPinnedTab_ = this.appendMenuItem_('applaunchtypepinned');\par
      if (!cr.isMac)\par
        this.launchNewWindow_ = this.appendMenuItem_('applaunchtypewindow');\par
      this.launchFullscreen_ = this.appendMenuItem_('applaunchtypefullscreen');\par
\par
      var self = this;\par
      this.forAllLaunchTypes_(function(launchTypeButton, id) \{\par
        launchTypeButton.addEventListener('activate',\par
            self.onLaunchTypeChanged_.bind(self));\par
      \});\par
\par
      menu.appendChild(cr.ui.MenuItem.createSeparator());\par
      this.options_ = this.appendMenuItem_('appoptions');\par
      this.disableNotifications_ =\par
          this.appendMenuItem_('appdisablenotifications');\par
      this.uninstall_ = this.appendMenuItem_('appuninstall');\par
      this.options_.addEventListener('activate',\par
                                     this.onShowOptions_.bind(this));\par
      this.disableNotifications_.addEventListener(\par
          'activate', this.onDisableNotifications_.bind(this));\par
      this.uninstall_.addEventListener('activate',\par
                                       this.onUninstall_.bind(this));\par
\par
      if (!cr.isMac && !cr.isChromeOS) \{\par
        menu.appendChild(cr.ui.MenuItem.createSeparator());\par
        this.createShortcut_ = this.appendMenuItem_('appcreateshortcut');\par
        this.createShortcut_.addEventListener(\par
            'activate', this.onCreateShortcut_.bind(this));\par
      \}\par
\par
      document.body.appendChild(menu);\par
    \},\par
\par
    /**\par
     * Appends a menu item to |this.menu|.\par
     * @param \{?String\} textId If non-null, the ID for the localized string\par
     *     that acts as the item's label.\par
     */\par
    appendMenuItem_: function(textId) \{\par
      var button = cr.doc.createElement('button');\par
      this.menu.appendChild(button);\par
      cr.ui.decorate(button, cr.ui.MenuItem);\par
      if (textId)\par
        button.textContent = localStrings.getString(textId);\par
      return button;\par
    \},\par
\par
    /**\par
     * Iterates over all the launch type menu items.\par
     * @param \{function(cr.ui.MenuItem, number)\} f The function to call for each\par
     *     menu item. The parameters to the function include the menu item and\par
     *     the associated launch ID.\par
     */\par
    forAllLaunchTypes_: function(f) \{\par
      // Order matters: index matches launchType id.\par
      var launchTypes = [ this.launchPinnedTab_,\par
                          this.launchRegularTab_,\par
                          this.launchFullscreen_,\par
                          this.launchNewWindow_ ];\par
\par
      for (var i = 0; i < launchTypes.length; ++i) \{\par
        if (!launchTypes[i])\par
          continue;\par
\par
        f(launchTypes[i], i);\par
      \}\par
    \},\par
\par
    /**\par
     * Does all the necessary setup to show the menu for the given app.\par
     * @param \{App\} app The App object that will be showing a context menu.\par
     */\par
    setupForApp: function(app) \{\par
      this.app_ = app;\par
\par
      this.launch_.textContent = app.appData.title;\par
\par
      this.forAllLaunchTypes_(function(launchTypeButton, id) \{\par
        launchTypeButton.disabled = false;\par
        launchTypeButton.checked = app.appData.launch_type == id;\par
      \});\par
\par
      this.options_.disabled = !app.appData.options_url || !app.appData.enabled;\par
      this.uninstall_.disabled = !app.appData.can_uninstall;\par
\par
      this.disableNotifications_.hidden = true;\par
      var notificationsDisabled = app.appData.notifications_disabled;\par
      if (typeof notificationsDisabled != 'undefined') \{\par
        this.disableNotifications_.hidden = false;\par
        this.disableNotifications_.checked = notificationsDisabled;\par
      \}\par
    \},\par
\par
    /**\par
     * Handlers for menu item activation.\par
     * @param \{Event\} e The activation event.\par
     * @private\par
     */\par
    onLaunch_: function(e) \{\par
      chrome.send('launchApp', [this.app_.appId, APP_LAUNCH.NTP_APPS_MENU]);\par
    \},\par
    onLaunchTypeChanged_: function(e) \{\par
      var pressed = e.currentTarget;\par
      var app = this.app_;\par
      this.forAllLaunchTypes_(function(launchTypeButton, id) \{\par
        if (launchTypeButton == pressed) \{\par
          chrome.send('setLaunchType', [app.appId, id]);\par
          // Manually update the launch type. We will only get\par
          // appsPrefChangeCallback calls after changes to other NTP instances.\par
          app.appData.launch_type = id;\par
        \}\par
      \});\par
    \},\par
    onShowOptions_: function(e) \{\par
      window.location = this.app_.appData.options_url;\par
    \},\par
    onDisableNotifications_: function(e) \{\par
      var app = this.app_;\par
      app.removeBubble();\par
      // Toggle the current disable setting.\par
      var newSetting = !this.disableNotifications_.checked;\par
      app.appData.notifications_disabled = newSetting;\par
      chrome.send('setNotificationsDisabled', [app.appData.id, newSetting]);\par
    \},\par
    onUninstall_: function(e) \{\par
      chrome.send('uninstallApp', [this.app_.appData.id]);\par
    \},\par
    onCreateShortcut_: function(e) \{\par
      chrome.send('createAppShortcut', [this.app_.appData.id]);\par
    \},\par
  \};\par
\par
  /**\par
   * Creates a new App object.\par
   * @param \{Object\} appData The data object that describes the app.\par
   * @constructor\par
   * @extends \{HTMLDivElement\}\par
   */\par
  function App(appData) \{\par
    var el = cr.doc.createElement('div');\par
    el.__proto__ = App.prototype;\par
    el.initialize(appData);\par
\par
    return el;\par
  \}\par
\par
  App.prototype = \{\par
    __proto__: HTMLDivElement.prototype,\par
\par
    /**\par
     * Initialize the app object.\par
     * @param \{Object\} appData The data object that describes the app.\par
     */\par
    initialize: function(appData) \{\par
      this.appData = appData;\par
      assert(this.appData_.id, 'Got an app without an ID');\par
      this.id = this.appData_.id;\par
\par
      this.className = 'app focusable';\par
\par
      if (!this.appData_.icon_big_exists && this.appData_.icon_small_exists)\par
        this.useSmallIcon_ = true;\par
\par
      this.appContents_ = this.useSmallIcon_ ?\par
          $('app-small-icon-template').cloneNode(true) :\par
          $('app-large-icon-template').cloneNode(true);\par
      this.appContents_.id = '';\par
      this.appendChild(this.appContents_);\par
\par
      this.appImgContainer_ = this.querySelector('.app-img-container');\par
      this.appImg_ = this.appImgContainer_.querySelector('img');\par
      this.setIcon();\par
\par
      if (this.useSmallIcon_) \{\par
        this.imgDiv_ = this.querySelector('.app-icon-div');\par
        this.addLaunchClickTarget_(this.imgDiv_);\par
        this.imgDiv_.title = this.appData_.title;\par
        chrome.send('getAppIconDominantColor', [this.id]);\par
      \} else \{\par
        this.addLaunchClickTarget_(this.appImgContainer_);\par
        this.appImgContainer_.title = this.appData_.title;\par
      \}\par
\par
      var appSpan = this.appContents_.querySelector('.title');\par
      appSpan.textContent = appSpan.title = this.appData_.title;\par
      this.addLaunchClickTarget_(appSpan);\par
\par
      var notification = this.appData_.notification;\par
      var hasNotification = typeof notification != 'undefined' &&\par
                            typeof notification['title'] != 'undefined' &&\par
                            typeof notification['body'] != 'undefined' &&\par
                            !this.appData_.notifications_disabled;\par
      if (hasNotification)\par
        this.setupNotification_(notification);\par
\par
      this.addEventListener('keydown', cr.ui.contextMenuHandler);\par
      this.addEventListener('keyup', cr.ui.contextMenuHandler);\par
\par
      // This hack is here so that appContents.contextMenu will be the same as\par
      // this.contextMenu.\par
      var self = this;\par
      this.appContents_.__defineGetter__('contextMenu', function() \{\par
        return self.contextMenu;\par
      \});\par
      this.appContents_.addEventListener('contextmenu',\par
                                         cr.ui.contextMenuHandler);\par
\par
      if (this.appData_.is_webstore)\par
        this.createAppsPromoExtras_();\par
\par
      this.addEventListener('mousedown', this.onMousedown_, true);\par
      this.addEventListener('keydown', this.onKeydown_);\par
      this.addEventListener('blur', this.onBlur_, true);\par
    \},\par
\par
    /**\par
     * Sets the color of the favicon dominant color bar.\par
     * @param \{string\} color The css-parsable value for the color.\par
     */\par
    set stripeColor(color) \{\par
      this.querySelector('.color-stripe').style.backgroundColor = color;\par
    \},\par
\par
    /**\par
     * Removes the app tile from the page. Should be called after the app has\par
     * been uninstalled.\par
     */\par
    remove: function(opt_animate) \{\par
      // Unset the ID immediately, because the app is already gone. But leave\par
      // the tile on the page as it animates out.\par
      this.id = '';\par
      this.tile.doRemove(opt_animate);\par
    \},\par
\par
    /**\par
     * Set the URL of the icon from |appData_|. This won't actually show the\par
     * icon until loadIcon() is called (for performance reasons; we don't want\par
     * to load icons until we have to).\par
     */\par
    setIcon: function() \{\par
      var src = this.useSmallIcon_ ? this.appData_.icon_small :\par
                                     this.appData_.icon_big;\par
      if (!this.appData_.enabled ||\par
          (!this.appData_.offline_enabled && !navigator.onLine)) \{\par
        src += '?grayscale=true';\par
      \}\par
\par
      this.appImgSrc_ = src;\par
      this.classList.add('icon-loading');\par
    \},\par
\par
    /**\par
     * Shows the icon for the app. That is, it causes chrome to load the app\par
     * icon resource.\par
     */\par
    loadIcon: function() \{\par
      if (this.appImgSrc_) \{\par
        this.appImg_.src = this.appImgSrc_;\par
        this.appImg_.classList.remove('invisible');\par
        this.appImgSrc_ = null;\par
      \}\par
      this.classList.remove('icon-loading');\par
    \},\par
\par
    /**\par
     * Creates a bubble node.\par
     * @param \{Object\} notification The notification to show in the bubble.\par
     * @param \{boolean\} full Whether we want the headline or just the content.\par
     * @private\par
     */\par
    createBubbleNode_: function(notification, full) \{\par
      if (!full) \{\par
        var titleItem = this.ownerDocument.createElement('span');\par
        titleItem.textContent = notification['title'];\par
        return titleItem;\par
      \} else \{\par
        var container = this.ownerDocument.createElement('div');\par
\par
        var messageItem = this.ownerDocument.createElement('div');\par
        messageItem.textContent = notification['body'];\par
        container.appendChild(messageItem);\par
\par
        if (notification['linkUrl'] && notification['linkText']) \{\par
          var anchor = this.ownerDocument.createElement('a');\par
          anchor.href = notification['linkUrl'];\par
          anchor.textContent = notification['linkText'];\par
          container.appendChild(anchor);\par
        \}\par
\par
        return container;\par
      \}\par
    \},\par
\par
    /**\par
     * Sets up a notification for the app icon.\par
     * @param \{Object\} notification The notification to show in the bubble.\par
     * @private\par
     */\par
    setupNotification_: function(notification) \{\par
      if (notification) \{\par
        var infoBubble;\par
        if (!this.currentBubbleShowing_) \{\par
          // Create a new bubble.\par
          infoBubble = new cr.ui.ExpandableBubble;\par
          infoBubble.anchorNode = this;\par
          infoBubble.appId = this.appData_.id;\par
          infoBubble.handleCloseEvent = function() \{\par
            chrome.send('closeNotification', [this.appId]);\par
            infoBubble.hide();\par
          \};\par
        \} else \{\par
          // Reuse the old bubble instead of popping up a new bubble over\par
          // the old one.\par
          infoBubble = this.currentBubbleShowing_;\par
          infoBubble.collapseBubble_();\par
        \}\par
        infoBubble.contentTitle = this.createBubbleNode_(notification, false);\par
        infoBubble.content = this.createBubbleNode_(notification, true);\par
        infoBubble.show();\par
        infoBubble.resizeAndReposition();\par
\par
        this.currentBubbleShowing_ = infoBubble;\par
      \}\par
    \},\par
\par
    /**\par
     *  Removes the info bubble if there is one.\par
     */\par
    removeBubble: function() \{\par
      if (this.currentBubbleShowing_) \{\par
        this.currentBubbleShowing_.hide();\par
        this.currentBubbleShowing_ = null;\par
      \}\par
    \},\par
\par
    /**\par
     * Creates the apps-promo section of the app (should only be called for the\par
     * webstore app).\par
     * @private\par
     */\par
    createAppsPromoExtras_: function() \{\par
      this.classList.add('webstore');\par
\par
      this.appsPromoExtras_ = $('apps-promo-extras-template').cloneNode(true);\par
      this.appsPromoExtras_.id = '';\par
      this.appsPromoHeading_ =\par
          this.appsPromoExtras_.querySelector('.apps-promo-heading');\par
      this.appsPromoLink_ =\par
          this.appsPromoExtras_.querySelector('.apps-promo-link');\par
      this.appsPromoLink_.addEventListener('click', this.onClick_.bind(this));\par
\par
      this.appsPromoLogo_ = this.ownerDocument.createElement('img');\par
      this.appsPromoLogo_.className = 'apps-promo-logo';\par
      this.appImgContainer_.appendChild(this.appsPromoLogo_);\par
\par
      this.appendChild(this.appsPromoExtras_);\par
    \},\par
\par
    /**\par
     * Sets the apps promo appearance. If |data| is null, there is no promo. If\par
     * |data| is non-null, it contains strings to be shown for the promo. The\par
     * promo is only shown when the webstore app icon is alone on a page.\par
     * @param \{Object\} data A dictionary that contains apps promo strings.\par
     */\par
    setAppsPromoData: function(data) \{\par
      if (data) \{\par
        this.classList.add('has-promo');\par
      \} else \{\par
        this.classList.remove('has-promo');\par
        return;\par
      \}\par
\par
      this.appsPromoHeading_.textContent = data.promoHeader;\par
      this.appsPromoLink_.href = data.promoLink;\par
      this.appsPromoLink_.textContent = data.promoButton;\par
      this.appsPromoLogo_.src = data.promoLogo;\par
    \},\par
\par
    /**\par
     * Set the size and position of the app tile.\par
     * @param \{number\} size The total size of |this|.\par
     * @param \{number\} x The x-position.\par
     * @param \{number\} y The y-position.\par
     *     animate.\par
     */\par
    setBounds: function(size, x, y) \{\par
      var imgSize = size * APP_IMG_SIZE_FRACTION;\par
      this.appImgContainer_.style.width = this.appImgContainer_.style.height =\par
          this.useSmallIcon_ ? '16px' : imgSize + 'px';\par
      if (this.useSmallIcon_) \{\par
        // 3/4 is the ratio of 96px to 128px (the used height and full height\par
        // of icons in apps).\par
        var iconSize = imgSize * 3/4;\par
        // The -2 is for the div border to improve the visual alignment for the\par
        // icon div.\par
        this.imgDiv_.style.width = this.imgDiv_.style.height =\par
            (iconSize - 2) + 'px';\par
        // Margins set to get the icon placement right and the text to line up.\par
        this.imgDiv_.style.marginTop = this.imgDiv_.style.marginBottom =\par
            ((imgSize - iconSize) / 2) + 'px';\par
      \}\par
\par
      this.style.width = this.style.height = size + 'px';\par
      this.style.left = x + 'px';\par
      this.style.right = x + 'px';\par
      this.style.top = y + 'px';\par
\par
      if (this.currentBubbleShowing_)\par
        this.currentBubbleShowing_.resizeAndReposition();\par
    \},\par
\par
    /**\par
     * Invoked when an app is clicked.\par
     * @param \{Event\} e The click event.\par
     * @private\par
     */\par
    onClick_: function(e) \{\par
      var is_promo = this.appsPromoExtras_ &&\par
          window.getComputedStyle(this.appsPromoExtras_).display != 'none';\par
      var url = !this.appData_.is_webstore ? '' :\par
          is_promo ? this.appsPromoLink_.href :\par
                     appendParam(this.appData_.url,\par
                                 'utm_source',\par
                                 'chrome-ntp-icon');\par
\par
      chrome.send('launchApp',\par
                  [this.appId, APP_LAUNCH.NTP_APPS_MAXIMIZED, url,\par
                   e.button, e.altKey, e.ctrlKey, e.metaKey, e.shiftKey]);\par
\par
      // Don't allow the click to trigger a link or anything\par
      e.preventDefault();\par
    \},\par
\par
    /**\par
     * Invoked when the user presses a key while the app is focused.\par
     * @param \{Event\} e The key event.\par
     * @private\par
     */\par
    onKeydown_: function(e) \{\par
      if (e.keyIdentifier == 'Enter') \{\par
        chrome.send('launchApp',\par
                    [this.appId, APP_LAUNCH.NTP_APPS_MAXIMIZED, '',\par
                     0, e.altKey, e.ctrlKey, e.metaKey, e.shiftKey]);\par
        e.preventDefault();\par
        e.stopPropagation();\par
      \}\par
    \},\par
\par
    /**\par
     * Adds a node to the list of targets that will launch the app. This list\par
     * is also used in onMousedown to determine whether the app contents should\par
     * be shown as active (if we don't do this, then clicking anywhere in\par
     * appContents, even a part that is outside the ideally clickable region,\par
     * will cause the app icon to look active).\par
     * @param \{HTMLElement\} node The node that should be clickable.\par
     */\par
    addLaunchClickTarget_: function(node) \{\par
      node.classList.add('launch-click-target');\par
      node.addEventListener('click', this.onClick_.bind(this));\par
    \},\par
\par
    /**\par
     * Handler for mousedown on the App. Adds a class that allows us to\par
     * not display as :active for right clicks and clicks on app notifications\par
     * (specifically, don't pulse on these occasions). Also, we don't pulse\par
     * for clicks that aren't within the clickable regions.\par
     * @param \{Event\} e The mousedown event.\par
     */\par
    onMousedown_: function(e) \{\par
      if (e.button == 2 ||\par
          !findAncestorByClass(e.target, 'launch-click-target')) \{\par
        this.appContents_.classList.add('suppress-active');\par
      \} else \{\par
        this.appContents_.classList.remove('suppress-active');\par
      \}\par
\par
      // This class is here so we don't show the focus state for apps that\par
      // gain keyboard focus via mouse clicking.\par
      this.classList.add('click-focus');\par
    \},\par
\par
    /**\par
     * This app is losing keyboard focus.\par
     * @param \{Event\} e The event.\par
     */\par
    onBlur_: function(e) \{\par
      this.classList.remove('click-focus');\par
    \},\par
\par
    /**\par
     * Change the appData and update the appearance of the app.\par
     * @param \{Object\} appData The new data object that describes the app.\par
     */\par
    replaceAppData: function(appData) \{\par
      this.appData_ = appData;\par
      this.setIcon();\par
      this.loadIcon();\par
    \},\par
\par
    /**\par
     * The data and preferences for this app.\par
     * @type \{Object\}\par
     */\par
    set appData(data) \{\par
      this.appData_ = data;\par
    \},\par
    get appData() \{\par
      return this.appData_;\par
    \},\par
\par
    get appId() \{\par
      return this.appData_.id;\par
    \},\par
\par
    /**\par
     * Returns a pointer to the context menu for this app. All apps share the\par
     * singleton AppContextMenu. This function is called by the\par
     * ContextMenuHandler in response to the 'contextmenu' event.\par
     * @type \{cr.ui.Menu\}\par
     */\par
    get contextMenu() \{\par
      var menu = AppContextMenu.getInstance();\par
      menu.setupForApp(this);\par
      return menu.menu;\par
    \},\par
\par
    /**\par
     * Returns whether this element can be 'removed' from chrome (i.e. whether\par
     * the user can drag it onto the trash and expect something to happen).\par
     * @return \{boolean\} True if the app can be uninstalled.\par
     */\par
    canBeRemoved: function() \{\par
      return this.appData_.can_uninstall;\par
    \},\par
\par
    /**\par
     * Uninstalls the app after it's been dropped on the trash.\par
     */\par
    removeFromChrome: function() \{\par
      chrome.send('uninstallApp', [this.appData_.id, true]);\par
      this.tile.tilePage.removeTile(this.tile, true);\par
      if (this.currentBubbleShowing_)\par
        currentBubbleShowing_.hide();\par
    \},\par
\par
    /**\par
     * Called when a drag is starting on the tile. Updates dataTransfer with\par
     * data for this tile.\par
     */\par
    setDragData: function(dataTransfer) \{\par
      dataTransfer.setData('Text', this.appData_.title);\par
      dataTransfer.setData('URL', this.appData_.url);\par
    \},\par
  \};\par
\par
  var TilePage = ntp4.TilePage;\par
\par
  // The fraction of the app tile size that the icon uses.\par
  var APP_IMG_SIZE_FRACTION = 4 / 5;\par
\par
  var appsPageGridValues = \{\par
    // The fewest tiles we will show in a row.\par
    minColCount: 3,\par
    // The most tiles we will show in a row.\par
    maxColCount: 6,\par
\par
    // The smallest a tile can be.\par
    minTileWidth: 64 / APP_IMG_SIZE_FRACTION,\par
    // The biggest a tile can be.\par
    maxTileWidth: 128 / APP_IMG_SIZE_FRACTION,\par
\par
    // The padding between tiles, as a fraction of the tile width.\par
    tileSpacingFraction: 1 / 8,\par
  \};\par
  TilePage.initGridValues(appsPageGridValues);\par
\par
  /**\par
   * Creates a new AppsPage object.\par
   * @constructor\par
   * @extends \{TilePage\}\par
   */\par
  function AppsPage() \{\par
    var el = new TilePage(appsPageGridValues);\par
    el.__proto__ = AppsPage.prototype;\par
    el.initialize();\par
\par
    return el;\par
  \}\par
\par
  AppsPage.prototype = \{\par
    __proto__: TilePage.prototype,\par
\par
    initialize: function() \{\par
      this.classList.add('apps-page');\par
\par
      this.addEventListener('cardselected', this.onCardSelected_);\par
      // Add event listeners for two events, so we can temporarily suppress\par
      // the app notification bubbles when the app card slides in and out of\par
      // view.\par
      this.addEventListener('carddeselected', this.onCardDeselected_);\par
      this.addEventListener('cardSlider:card_change_ended',\par
                            this.onCardChangeEnded_);\par
\par
      this.addEventListener('tilePage:tile_added', this.onTileAdded_);\par
\par
      this.content_.addEventListener('scroll', this.onScroll_.bind(this));\par
    \},\par
\par
    /**\par
     * Creates an app DOM element and places it at the last position on the\par
     * page.\par
     * @param \{Object\} appData The data object that describes the app.\par
     * @param \{boolean=\} animate If true, the app tile plays an animation.\par
     */\par
    appendApp: function(appData, animate) \{\par
      if (animate) \{\par
        // Select the page and scroll all the way down so the animation is\par
        // visible.\par
        ntp4.getCardSlider().selectCardByValue(this);\par
        this.content_.scrollTop = this.content_.scrollHeight;\par
      \}\par
      this.appendTile(new App(appData), animate);\par
    \},\par
\par
    /**\par
     * Handler for 'cardselected' event, fired when |this| is selected. The\par
     * first time this is called, we load all the app icons.\par
     * @private\par
     */\par
    onCardSelected_: function(e) \{\par
      var apps = this.querySelectorAll('.app.icon-loading');\par
      for (var i = 0; i < apps.length; i++) \{\par
        apps[i].loadIcon();\par
        if (apps[i].currentBubbleShowing_)\par
          apps[i].currentBubbleShowing_.suppressed = false;\par
      \}\par
    \},\par
\par
    /**\par
     * Handler for tile additions to this page.\par
     * @param \{Event\} e The tilePage:tile_added event.\par
     */\par
    onTileAdded_: function(e) \{\par
      assert(e.currentTarget == this);\par
      assert(e.addedTile.firstChild instanceof App);\par
      if (this.classList.contains('selected-card'))\par
        e.addedTile.firstChild.loadIcon();\par
    \},\par
\par
    /**\par
     * Handler for the when this.cardSlider ends change its card. If animated,\par
     * this happens when the -webkit-transition is done, otherwise happens\par
     * immediately (but after cardSlider:card_changed).\par
     * @private\par
     */\par
    onCardChangeEnded_: function(e) \{\par
      for (var i = 0; i < this.tileElements_.length; i++) \{\par
        var app = this.tileElements_[i].firstChild;\par
        assert(app instanceof App);\par
        if (app.currentBubbleShowing_)\par
          app.currentBubbleShowing_.suppressed = false;\par
      \}\par
    \},\par
\par
    /**\par
     * Handler for the 'carddeselected' event, fired when the user switches\par
     * to another 'card' than the App 'card' on the NTP (|this| gets\par
     * deselected).\par
     * @private\par
     */\par
    onCardDeselected_: function(e) \{\par
      for (var i = 0; i < this.tileElements_.length; i++) \{\par
        var app = this.tileElements_[i].firstChild;\par
        assert(app instanceof App);\par
        if (app.currentBubbleShowing_)\par
          app.currentBubbleShowing_.suppressed = true;\par
      \}\par
    \},\par
\par
    /**\par
     * A handler for when the apps page is scrolled (then we need to reposition\par
     * the bubbles.\par
     * @private\par
     */\par
    onScroll_: function(e) \{\par
      if (!this.selected)\par
        return;\par
      for (var i = 0; i < this.tileElements_.length; i++) \{\par
        var app = this.tileElements_[i].firstChild;\par
        assert(app instanceof App);\par
        if (app.currentBubbleShowing_)\par
          app.currentBubbleShowing_.resizeAndReposition();\par
        \}\par
    \},\par
\par
    /** @inheritdoc */\par
    doDragOver: function(e) \{\par
      var tile = ntp4.getCurrentlyDraggingTile();\par
      if (tile && !tile.querySelector('.app')) \{\par
        e.preventDefault();\par
        this.setDropEffect(e.dataTransfer);\par
      \} else \{\par
        TilePage.prototype.doDragOver.call(this, e);\par
      \}\par
    \},\par
\par
    /** @inheritDoc */\par
    shouldAcceptDrag: function(e) \{\par
      return !!ntp4.getCurrentlyDraggingTile() ||\par
          (e.dataTransfer && e.dataTransfer.types.indexOf('url') != -1);\par
    \},\par
\par
    /** @inheritDoc */\par
    addDragData: function(dataTransfer, index) \{\par
      var sourceId = -1;\par
      var currentlyDraggingTile = ntp4.getCurrentlyDraggingTile();\par
      if (currentlyDraggingTile) \{\par
        var tileContents = currentlyDraggingTile.firstChild;\par
        if (tileContents.classList.contains('app')) \{\par
          var originalPage = currentlyDraggingTile.tilePage;\par
          var samePageDrag = originalPage == this;\par
          sourceId = samePageDrag ? DRAG_SOURCE.SAME_APPS_PANE :\par
                                    DRAG_SOURCE.OTHER_APPS_PANE;\par
          this.tileGrid_.insertBefore(currentlyDraggingTile,\par
                                      this.tileElements_[index]);\par
          this.tileMoved(currentlyDraggingTile);\par
          if (!samePageDrag) \{\par
            originalPage.fireRemovedEvent(currentlyDraggingTile, index, true);\par
            this.fireAddedEvent(currentlyDraggingTile, index, true);\par
          \}\par
        \} else if (currentlyDraggingTile.querySelector('.most-visited')) \{\par
          this.generateAppForLink(tileContents.data);\par
          sourceId = DRAG_SOURCE.MOST_VISITED_PANE;\par
        \}\par
      \} else \{\par
        this.addOutsideData_(dataTransfer);\par
        sourceId = DRAG_SOURCE.OUTSIDE_NTP;\par
      \}\par
\par
      assert(sourceId != -1);\par
      chrome.send('metricsHandler:recordInHistogram',\par
          ['NewTabPage.AppsPageDragSource', sourceId, DRAG_SOURCE_LIMIT]);\par
    \},\par
\par
    /**\par
     * Adds drag data that has been dropped from a source that is not a tile.\par
     * @param \{Object\} dataTransfer The data transfer object that holds drop\par
     *     data.\par
     * @private\par
     */\par
    addOutsideData_: function(dataTransfer) \{\par
      var url = dataTransfer.getData('url');\par
      assert(url);\par
\par
      // If the dataTransfer has html data, use that html's text contents as the\par
      // title of the new link.\par
      var html = dataTransfer.getData('text/html');\par
      var title;\par
      if (html) \{\par
        // It's important that we don't attach this node to the document\par
        // because it might contain scripts.\par
        var node = this.ownerDocument.createElement('div');\par
        node.innerHTML = html;\par
        title = node.textContent;\par
      \}\par
\par
      // Make sure title is >=1 and <=45 characters for Chrome app limits.\par
      if (!title)\par
        title = url;\par
      if (title.length > 45)\par
        title = title.substring(0, 45);\par
      var data = \{url: url, title: title\};\par
\par
      // Synthesize an app.\par
      this.generateAppForLink(data);\par
    \},\par
\par
    /**\par
     * Creates a new crx-less app manifest and installs it.\par
     * @param \{Object\} data The data object describing the link. Must have |url|\par
     *     and |title| members.\par
     */\par
    generateAppForLink: function(data) \{\par
      assert(data.url != undefined);\par
      assert(data.title != undefined);\par
      var pageIndex = ntp4.getAppsPageIndex(this);\par
      chrome.send('generateAppForLink', [data.url, data.title, pageIndex]);\par
    \},\par
\par
    /** @inheritDoc */\par
    tileMoved: function(draggedTile) \{\par
      if (!(draggedTile.firstChild instanceof App))\par
        return;\par
\par
      var pageIndex = ntp4.getAppsPageIndex(this);\par
      chrome.send('setPageIndex', [draggedTile.firstChild.appId, pageIndex]);\par
\par
      var appIds = [];\par
      for (var i = 0; i < this.tileElements_.length; i++) \{\par
        var tileContents = this.tileElements_[i].firstChild;\par
        if (tileContents instanceof App)\par
          appIds.push(tileContents.appId);\par
      \}\par
\par
      chrome.send('reorderApps', [draggedTile.firstChild.appId, appIds]);\par
    \},\par
\par
    /** @inheritDoc */\par
    setDropEffect: function(dataTransfer) \{\par
      var tile = ntp4.getCurrentlyDraggingTile();\par
      if (tile && tile.querySelector('.app'))\par
        ntp4.setCurrentDropEffect(dataTransfer, 'move');\par
      else\par
        ntp4.setCurrentDropEffect(dataTransfer, 'copy');\par
    \},\par
  \};\par
\par
  AppsPage.setPromo = function(data) \{\par
    var store = document.querySelector('.webstore');\par
    if (store)\par
      store.setAppsPromoData(data);\par
  \};\par
\par
  /**\par
   * Launches the specified app using the APP_LAUNCH_NTP_APP_RE_ENABLE\par
   * histogram. This should only be invoked from the AppLauncherHandler.\par
   * @param \{String\} appID The ID of the app.\par
   */\par
  function launchAppAfterEnable(appId) \{\par
    chrome.send('launchApp', [appId, APP_LAUNCH.NTP_APP_RE_ENABLE]);\par
  \}\par
\par
  function appNotificationChanged(id, notification) \{\par
    var app = $(id);\par
    // The app might have been uninstalled, or notifications might be disabled.\par
    if (app && !app.appData.notifications_disabled)\par
      app.setupNotification_(notification);\par
  \}\par
\par
  return \{\par
    APP_LAUNCH: APP_LAUNCH,\par
    appNotificationChanged: appNotificationChanged,\par
    AppsPage: AppsPage,\par
    launchAppAfterEnable: launchAppAfterEnable,\par
  \};\par
\});\par
\par
// TODO(estade): update the content handlers to use ntp namespace instead of\par
// making these global.\par
var appNotificationChanged = ntp4.appNotificationChanged;\par
var launchAppAfterEnable = ntp4.launchAppAfterEnable;\par
</script>\par
<script>// Copyright (c) 2011 The Chromium Authors. All rights reserved.\par
// Use of this source code is governed by a BSD-style license that can be\par
// found in the LICENSE file.\par
\par
/**\par
 * @fileoverview DotList implementation\par
 */\par
\par
cr.define('ntp4', function() \{\par
  'use strict';\par
\par
  /**\par
   * Live list of the navigation dots.\par
   * @type \{!NodeList|undefined\}\par
   */\par
  var navDots;\par
\par
  /**\par
   * Creates a new DotList object.\par
   * @constructor\par
   * @extends \{HTMLUListElement\}\par
   */\par
  var DotList = cr.ui.define('ul');\par
\par
  DotList.prototype = \{\par
    __proto__: HTMLUListElement.prototype,\par
\par
    /** @inheritDoc */\par
    decorate: function() \{\par
      this.addEventListener('keydown', this.onKeyDown_.bind(this));\par
      navDots = this.getElementsByClassName('dot');\par
    \},\par
\par
    /**\par
     * Live list of the navigation dots.\par
     * @type \{!NodeList|undefined\}\par
     */\par
    get dots() \{\par
      return navDots;\par
    \},\par
\par
    /**\par
     * Handler for key events on the dot list. These keys will change the focus\par
     * element.\par
     * @param \{Event\} e The KeyboardEvent.\par
     */\par
    onKeyDown_: function(e) \{\par
      if (e.metaKey || e.shiftKey || e.altKey || e.ctrlKey)\par
        return;\par
\par
      var direction = 0;\par
      if (e.keyIdentifier == 'Left')\par
        direction = -1;\par
      else if (e.keyIdentifier == 'Right')\par
        direction = 1;\par
      else\par
        return;\par
\par
      var focusDot = this.querySelector('.dot:focus');\par
      if (!focusDot)\par
        return;\par
      var focusIndex = Array.prototype.indexOf.call(navDots, focusDot);\par
      var newFocusIndex = focusIndex + direction;\par
      if (focusIndex == newFocusIndex)\par
        return;\par
\par
      newFocusIndex = (newFocusIndex + navDots.length) % navDots.length;\par
      navDots[newFocusIndex].tabIndex = 3;\par
      navDots[newFocusIndex].focus();\par
      focusDot.tabIndex = -1;\par
\par
      e.stopPropagation();\par
      e.preventDefault();\par
    \}\par
  \};\par
\par
  return \{\par
    DotList: DotList\par
  \};\par
\});\par
</script>\par
<script>// Copyright (c) 2012 The Chromium Authors. All rights reserved.\par
// Use of this source code is governed by a BSD-style license that can be\par
// found in the LICENSE file.\par
\par
cr.define('ntp4', function() \{\par
  'use strict';\par
\par
  var TilePage = ntp4.TilePage;\par
\par
  /**\par
   * A counter for generating unique tile IDs.\par
   */\par
  var tileID = 0;\par
\par
  /**\par
   * Creates a new Most Visited object for tiling.\par
   * @constructor\par
   * @extends \{HTMLAnchorElement\}\par
   */\par
  function MostVisited() \{\par
    var el = cr.doc.createElement('a');\par
    el.__proto__ = MostVisited.prototype;\par
    el.initialize();\par
\par
    return el;\par
  \}\par
\par
  MostVisited.prototype = \{\par
    __proto__: HTMLAnchorElement.prototype,\par
\par
    initialize: function() \{\par
      this.reset();\par
\par
      this.addEventListener('click', this.handleClick_);\par
      this.addEventListener('keydown', this.handleKeyDown_);\par
    \},\par
\par
    get index() \{\par
      assert(this.tile);\par
      return this.tile.index;\par
    \},\par
\par
    get data() \{\par
      return this.data_;\par
    \},\par
\par
    /**\par
     * Clears the DOM hierarchy for this node, setting it back to the default\par
     * for a blank thumbnail.\par
     */\par
    reset: function() \{\par
      this.className = 'most-visited filler real';\par
      this.innerHTML =\par
          '<span class="thumbnail-wrapper fills-parent">' +\par
            '<div class="close-button"></div>' +\par
            '<span class="thumbnail fills-parent">' +\par
              // thumbnail-shield provides a gradient fade effect.\par
              '<div class="thumbnail-shield fills-parent"></div>' +\par
            '</span>' +\par
            '<span class="favicon"></span>' +\par
          '</span>' +\par
          '<div class="color-stripe"></div>' +\par
          '<span class="title"></span>';\par
\par
      this.querySelector('.close-button').title =\par
          templateData.removethumbnailtooltip;\par
\par
      this.tabIndex = -1;\par
      this.data_ = null;\par
      this.removeAttribute('id');\par
      this.title = '';\par
    \},\par
\par
    /**\par
     * Update the appearance of this tile according to |data|.\par
     * @param \{Object\} data A dictionary of relevant data for the page.\par
     */\par
    updateForData: function(data) \{\par
      if (this.classList.contains('blacklisted') && data) \{\par
        // Animate appearance of new tile.\par
        this.classList.add('new-tile-contents');\par
      \}\par
      this.classList.remove('blacklisted');\par
\par
      if (!data || data.filler) \{\par
        if (this.data_)\par
          this.reset();\par
        return;\par
      \}\par
\par
      var id = tileID++;\par
      this.id = 'most-visited-tile-' + id;\par
      this.data_ = data;\par
      this.classList.add('focusable');\par
\par
      var faviconDiv = this.querySelector('.favicon');\par
      var faviconUrl = 'chrome://favicon/size/16/' + data.url;\par
      faviconDiv.style.backgroundImage = url(faviconUrl);\par
      chrome.send('getFaviconDominantColor', [faviconUrl, this.id]);\par
\par
      var title = this.querySelector('.title');\par
      title.textContent = data.title;\par
      title.dir = data.direction;\par
\par
      // Sets the tooltip.\par
      this.title = data.title;\par
\par
      var thumbnailUrl = 'chrome://thumb/' + data.url;\par
      this.querySelector('.thumbnail').style.backgroundImage =\par
          url(thumbnailUrl);\par
\par
      this.href = data.url;\par
\par
      this.classList.remove('filler');\par
    \},\par
\par
    /**\par
     * Sets the color of the favicon dominant color bar.\par
     * @param \{string\} color The css-parsable value for the color.\par
     */\par
    set stripeColor(color) \{\par
      this.querySelector('.color-stripe').style.backgroundColor = color;\par
    \},\par
\par
    /**\par
     * Handles a click on the tile.\par
     * @param \{Event\} e The click event.\par
     */\par
    handleClick_: function(e) \{\par
      if (e.target.classList.contains('close-button')) \{\par
        this.blacklist_();\par
        e.preventDefault();\par
      \} else \{\par
        // Records an app launch from the most visited page (Chrome will decide\par
        // whether the url is an app). TODO(estade): this only works for clicks;\par
        // other actions like "open in new tab" from the context menu won't be\par
        // recorded. Can this be fixed?\par
        chrome.send('recordAppLaunchByURL',\par
                    [encodeURIComponent(this.href),\par
                     ntp4.APP_LAUNCH.NTP_MOST_VISITED]);\par
        // Records the index of this tile.\par
        chrome.send('metricsHandler:recordInHistogram',\par
                    ['NTP_MostVisited', this.index, 8]);\par
      \}\par
    \},\par
\par
    /**\par
     * Allow blacklisting most visited site using the keyboard.\par
     */\par
    handleKeyDown_: function(e) \{\par
      if (!cr.isMac && e.keyCode == 46 || // Del\par
          cr.isMac && e.metaKey && e.keyCode == 8) \{ // Cmd + Backspace\par
        this.blacklist_();\par
      \}\par
    \},\par
\par
    /**\par
     * Permanently removes a page from Most Visited.\par
     */\par
    blacklist_: function() \{\par
      this.showUndoNotification_();\par
      chrome.send('blacklistURLFromMostVisited', [this.data_.url]);\par
      this.reset();\par
      chrome.send('getMostVisited');\par
      this.classList.add('blacklisted');\par
    \},\par
\par
    showUndoNotification_: function() \{\par
      var data = this.data_;\par
      var self = this;\par
      var doUndo = function () \{\par
        chrome.send('removeURLsFromMostVisitedBlacklist', [data.url]);\par
        self.updateForData(data);\par
      \}\par
\par
      var undo = \{\par
        action: doUndo,\par
        text: templateData.undothumbnailremove,\par
      \}\par
\par
      var undoAll = \{\par
        action: function() \{\par
          chrome.send('clearMostVisitedURLsBlacklist', []);\par
        \},\par
        text: templateData.restoreThumbnailsShort,\par
      \}\par
\par
      ntp4.showNotification(templateData.thumbnailremovednotification,\par
                            [undo, undoAll]);\par
    \},\par
\par
    /**\par
     * Set the size and position of the most visited tile.\par
     * @param \{number\} size The total size of |this|.\par
     * @param \{number\} x The x-position.\par
     * @param \{number\} y The y-position.\par
     *     animate.\par
     */\par
    setBounds: function(size, x, y) \{\par
      this.style.width = size + 'px';\par
      this.style.height = heightForWidth(size) + 'px';\par
\par
      this.style.left = x + 'px';\par
      this.style.right = x + 'px';\par
      this.style.top = y + 'px';\par
    \},\par
\par
    /**\par
     * Returns whether this element can be 'removed' from chrome (i.e. whether\par
     * the user can drag it onto the trash and expect something to happen).\par
     * @return \{boolean\} True, since most visited pages can always be\par
     *     blacklisted.\par
     */\par
    canBeRemoved: function() \{\par
      return true;\par
    \},\par
\par
    /**\par
     * Removes this element from chrome, i.e. blacklists it.\par
     */\par
    removeFromChrome: function() \{\par
      this.blacklist_();\par
      this.parentNode.classList.add('finishing-drag');\par
    \},\par
\par
    /**\par
     * Called when a drag of this tile has ended (after all animations have\par
     * finished).\par
     */\par
    finalizeDrag: function() \{\par
      this.parentNode.classList.remove('finishing-drag');\par
    \},\par
\par
    /**\par
     * Called when a drag is starting on the tile. Updates dataTransfer with\par
     * data for this tile (for dragging outside of the NTP).\par
     */\par
    setDragData: function(dataTransfer) \{\par
      dataTransfer.setData('Text', this.data_.title);\par
      dataTransfer.setData('URL', this.data_.url);\par
    \},\par
  \};\par
\par
  var mostVisitedPageGridValues = \{\par
    // The fewest tiles we will show in a row.\par
    minColCount: 2,\par
    // The most tiles we will show in a row.\par
    maxColCount: 4,\par
\par
    // The smallest a tile can be.\par
    minTileWidth: 122,\par
    // The biggest a tile can be. 212 (max thumbnail width) + 2.\par
    maxTileWidth: 214,\par
\par
    // The padding between tiles, as a fraction of the tile width.\par
    tileSpacingFraction: 1 / 8,\par
  \};\par
  TilePage.initGridValues(mostVisitedPageGridValues);\par
\par
  /**\par
   * Calculates the height for a Most Visited tile for a given width. The size\par
   * is based on the thumbnail, which should have a 212:132 ratio.\par
   * @return \{number\} The height.\par
   */\par
  function heightForWidth(width) \{\par
    // The 2s are for borders, the 31 is for the title.\par
    return (width - 2) * 132 / 212 + 2 + 31;\par
  \}\par
\par
  var THUMBNAIL_COUNT = 8;\par
\par
  /**\par
   * Creates a new MostVisitedPage object.\par
   * @constructor\par
   * @extends \{TilePage\}\par
   */\par
  function MostVisitedPage() \{\par
    var el = new TilePage(mostVisitedPageGridValues);\par
    el.__proto__ = MostVisitedPage.prototype;\par
    el.initialize();\par
\par
    return el;\par
  \}\par
\par
  MostVisitedPage.prototype = \{\par
    __proto__: TilePage.prototype,\par
\par
    initialize: function() \{\par
      this.classList.add('most-visited-page');\par
      this.data_ = null;\par
      this.mostVisitedTiles_ = this.getElementsByClassName('most-visited real');\par
    \},\par
\par
    /**\par
     * Create blank (filler) tiles.\par
     * @private\par
     */\par
    createTiles_: function() \{\par
      for (var i = 0; i < THUMBNAIL_COUNT; i++) \{\par
        this.appendTile(new MostVisited());\par
      \}\par
    \},\par
\par
    /**\par
     * Update the tiles after a change to |data_|.\par
     */\par
    updateTiles_: function() \{\par
      for (var i = 0; i < THUMBNAIL_COUNT; i++) \{\par
        var page = this.data_[i];\par
        var tile = this.mostVisitedTiles_[i];\par
\par
        if (i >= this.data_.length)\par
          tile.reset();\par
        else\par
          tile.updateForData(page);\par
      \}\par
    \},\par
\par
    /**\par
     * Array of most visited data objects.\par
     * @type \{Array\}\par
     */\par
    get data() \{\par
      return this.data_;\par
    \},\par
    set data(data) \{\par
      var startTime = Date.now();\par
\par
      // The first time data is set, create the tiles.\par
      if (!this.data_) \{\par
        this.createTiles_();\par
        this.data_ = data.slice(0, THUMBNAIL_COUNT);\par
      \} else \{\par
        this.data_ = refreshData(this.data_, data);\par
      \}\par
\par
      this.updateTiles_();\par
      logEvent('mostVisited.layout: ' + (Date.now() - startTime));\par
    \},\par
\par
    /** @inheritDoc */\par
    shouldAcceptDrag: function(e) \{\par
      return false;\par
    \},\par
\par
    /** @inheritDoc */\par
    heightForWidth: heightForWidth,\par
  \};\par
\par
  /**\par
   * We've gotten additional Most Visited data. Update our old data with the\par
   * new data. The ordering of the new data is not important, except when a\par
   * page is pinned. Thus we try to minimize re-ordering.\par
   * @param \{Object\} oldData The current Most Visited page list.\par
   * @param \{Object\} newData The new Most Visited page list.\par
   * @return The merged page list that should replace the current page list.\par
   */\par
  function refreshData(oldData, newData) \{\par
    oldData = oldData.slice(0, THUMBNAIL_COUNT);\par
    newData = newData.slice(0, THUMBNAIL_COUNT);\par
\par
    // Copy over pinned sites directly.\par
    for (var j = 0; j < newData.length; j++) \{\par
      if (newData[j].pinned) \{\par
        oldData[j] = newData[j];\par
        // Mark the entry as 'updated' so we don't try to update again.\par
        oldData[j].updated = true;\par
        // Mark the newData page as 'used' so we don't try to re-use it.\par
        newData[j].used = true;\par
      \}\par
    \}\par
\par
    // Look through old pages; if they exist in the newData list, keep them\par
    // where they are.\par
    for (var i = 0; i < oldData.length; i++) \{\par
      if (!oldData[i] || oldData[i].updated)\par
        continue;\par
\par
      for (var j = 0; j < newData.length; j++) \{\par
        if (newData[j].used)\par
          continue;\par
\par
        if (newData[j].url == oldData[i].url) \{\par
          // The background image and other data may have changed.\par
          oldData[i] = newData[j];\par
          oldData[i].updated = true;\par
          newData[j].used = true;\par
          break;\par
        \}\par
      \}\par
    \}\par
\par
    // Look through old pages that haven't been updated yet; replace them.\par
    for (var i = 0; i < oldData.length; i++) \{\par
      if (oldData[i] && oldData[i].updated)\par
        continue;\par
\par
      for (var j = 0; j < newData.length; j++) \{\par
        if (newData[j].used)\par
          continue;\par
\par
        oldData[i] = newData[j];\par
        oldData[i].updated = true;\par
        newData[j].used = true;\par
        break;\par
      \}\par
\par
      if (oldData[i] && !oldData[i].updated)\par
        oldData[i] = null;\par
    \}\par
\par
    // Clear 'updated' flags so this function will work next time it's called.\par
    for (var i = 0; i < THUMBNAIL_COUNT; i++) \{\par
      if (oldData[i])\par
        oldData[i].updated = false;\par
    \}\par
\par
    return oldData;\par
  \};\par
\par
  return \{\par
    MostVisitedPage: MostVisitedPage,\par
    refreshData: refreshData,\par
  \};\par
\});\par
</script>\par
<script>// Copyright (c) 2011 The Chromium Authors. All rights reserved.\par
// Use of this source code is governed by a BSD-style license that can be\par
// found in the LICENSE file.\par
\par
/**\par
 * @fileoverview Trash\par
 * This is the class for the trash can that appears when dragging an app.\par
 */\par
\par
cr.define('ntp4', function() \{\par
  'use strict';\par
\par
  function Trash(trash) \{\par
    trash.__proto__ = Trash.prototype;\par
    trash.initialize();\par
    return trash;\par
  \}\par
\par
  Trash.prototype = \{\par
    __proto__: HTMLDivElement.prototype,\par
\par
    initialize: function(element) \{\par
      this.dragWrapper_ = new cr.ui.DragWrapper(this, this);\par
    \},\par
\par
    /**\par
     * Determines whether we are interested in the drag data for |e|.\par
     * @param \{Event\} e The event from drag enter.\par
     * @return \{bool\}\par
     */\par
    shouldAcceptDrag: function(e) \{\par
      var tile = ntp4.getCurrentlyDraggingTile();\par
      if (!tile)\par
        return false;\par
\par
      return tile.firstChild.canBeRemoved();\par
    \},\par
\par
    /**\par
     * Drag over handler.\par
     * @param \{Event\} e The drag event.\par
     */\par
    doDragOver: function(e) \{\par
      ntp4.getCurrentlyDraggingTile().dragClone.classList.add(\par
          'hovering-on-trash');\par
      ntp4.setCurrentDropEffect(e.dataTransfer, 'move');\par
      e.preventDefault();\par
    \},\par
\par
    /**\par
     * Drag enter handler.\par
     * @param \{Event\} e The drag event.\par
     */\par
    doDragEnter: function(e) \{\par
      this.doDragOver(e);\par
    \},\par
\par
    /**\par
     * Drop handler.\par
     * @param \{Event\} e The drag event.\par
     */\par
    doDrop: function(e) \{\par
      e.preventDefault();\par
\par
      var tile = ntp4.getCurrentlyDraggingTile();\par
      tile.firstChild.removeFromChrome();\par
      tile.landedOnTrash = true;\par
    \},\par
\par
    /**\par
     * Drag leave handler.\par
     * @param \{Event\} e The drag event.\par
     */\par
    doDragLeave: function(e) \{\par
      ntp4.getCurrentlyDraggingTile().dragClone.classList.remove(\par
          'hovering-on-trash');\par
    \},\par
  \};\par
\par
  return \{\par
    Trash: Trash,\par
  \};\par
\});\par
</script>\par
<script>// Copyright (c) 2012 The Chromium Authors. All rights reserved.\par
// Use of this source code is governed by a BSD-style license that can be\par
// found in the LICENSE file.\par
\par
/**\par
 * @fileoverview PageListView implementation.\par
 * PageListView manages page list, dot list, switcher buttons and handles apps\par
 * pages callbacks from backend.\par
 *\par
 * Note that you need to have AppLauncherHandler in your WebUI to use this code.\par
 */\par
\par
cr.define('ntp4', function() \{\par
  'use strict';\par
\par
  /**\par
   * Object for accessing localized strings.\par
   * @type \{!LocalStrings\}\par
   */\par
  var localStrings = new LocalStrings;\par
\par
  /**\par
   * Creates a PageListView object.\par
   * @constructor\par
   * @extends \{Object\}\par
   */\par
  function PageListView() \{\par
  \}\par
\par
  PageListView.prototype = \{\par
    /**\par
     * The CardSlider object to use for changing app pages.\par
     * @type \{CardSlider|undefined\}\par
     */\par
    cardSlider: undefined,\par
\par
    /**\par
     * The frame div for this.cardSlider.\par
     * @type \{!Element|undefined\}\par
     */\par
    sliderFrame: undefined,\par
\par
    /**\par
     * The 'page-list' element.\par
     * @type \{!Element|undefined\}\par
     */\par
    pageList: undefined,\par
\par
    /**\par
     * A list of all 'tile-page' elements.\par
     * @type \{!NodeList|undefined\}\par
     */\par
    tilePages: undefined,\par
\par
    /**\par
     * A list of all 'apps-page' elements.\par
     * @type \{!NodeList|undefined\}\par
     */\par
    appsPages: undefined,\par
\par
    /**\par
     * The Most Visited page.\par
     * @type \{!Element|undefined\}\par
     */\par
    mostVisitedPage: undefined,\par
\par
    /**\par
     * The 'dots-list' element.\par
     * @type \{!Element|undefined\}\par
     */\par
    dotList: undefined,\par
\par
    /**\par
     * The left and right paging buttons.\par
     * @type \{!Element|undefined\}\par
     */\par
    pageSwitcherStart: undefined,\par
    pageSwitcherEnd: undefined,\par
\par
    /**\par
     * The 'trash' element.  Note that technically this is unnecessary,\par
     * JavaScript creates the object for us based on the id.  But I don't want\par
     * to rely on the ID being the same, and JSCompiler doesn't know about it.\par
     * @type \{!Element|undefined\}\par
     */\par
    trash: undefined,\par
\par
    /**\par
     * The type of page that is currently shown. The value is a numerical ID.\par
     * @type \{number\}\par
     */\par
    shownPage: 0,\par
\par
    /**\par
     * The index of the page that is currently shown, within the page type.\par
     * For example if the third Apps page is showing, this will be 2.\par
     * @type \{number\}\par
     */\par
    shownPageIndex: 0,\par
\par
    /**\par
     * EventTracker for managing event listeners for page events.\par
     * @type \{!EventTracker\}\par
     */\par
    eventTracker: new EventTracker,\par
\par
    /**\par
     * If non-null, this is the ID of the app to highlight to the user the next\par
     * time getAppsCallback runs. "Highlight" in this case means to switch to\par
     * the page and run the new tile animation.\par
     * @type \{String\}\par
     */\par
    highlightAppId: null,\par
\par
    /**\par
     * Initializes page list view.\par
     * @param \{!Element\} pageList A DIV element to host all pages.\par
     * @param \{!Element\} dotList An UL element to host nav dots. Each dot\par
     *     represents a page.\par
     * @param \{!Element\} cardSliderFrame The card slider frame that hosts\par
     *     pageList and switcher buttons.\par
     * @param \{!Element|undefined\} opt_trash Optional trash element.\par
     * @param \{!Element|undefined\} opt_pageSwitcherStart Optional start page\par
     *     switcher button.\par
     * @param \{!Element|undefined\} opt_pageSwitcherEnd Optional end page\par
     *     switcher button.\par
     */\par
    initialize: function(pageList, dotList, cardSliderFrame, opt_trash,\par
                         opt_pageSwitcherStart, opt_pageSwitcherEnd) \{\par
      this.pageList = pageList;\par
\par
      this.dotList = dotList;\par
      cr.ui.decorate(this.dotList, ntp4.DotList);\par
\par
      this.trash = opt_trash;\par
      if (this.trash)\par
        new ntp4.Trash(this.trash);\par
\par
      this.pageSwitcherStart = opt_pageSwitcherStart;\par
      if (this.pageSwitcherStart)\par
        ntp4.initializePageSwitcher(this.pageSwitcherStart);\par
\par
      this.pageSwitcherEnd = opt_pageSwitcherEnd;\par
      if (this.pageSwitcherEnd)\par
        ntp4.initializePageSwitcher(this.pageSwitcherEnd);\par
\par
      this.shownPage = templateData.shown_page_type;\par
      this.shownPageIndex = templateData.shown_page_index;\par
\par
      // Request data on the apps so we can fill them in.\par
      // Note that this is kicked off asynchronously.  'getAppsCallback' will be\par
      // invoked at some point after this function returns.\par
      chrome.send('getApps');\par
\par
      document.addEventListener('keydown', this.onDocKeyDown_.bind(this));\par
      // Prevent touch events from triggering any sort of native scrolling\par
      document.addEventListener('touchmove', function(e) \{\par
        e.preventDefault();\par
      \}, true);\par
\par
      this.tilePages = this.pageList.getElementsByClassName('tile-page');\par
      this.appsPages = this.pageList.getElementsByClassName('apps-page');\par
\par
      // Initialize the cardSlider without any cards at the moment\par
      this.sliderFrame = cardSliderFrame;\par
      this.cardSlider = new cr.ui.CardSlider(this.sliderFrame, this.pageList,\par
          this.sliderFrame.offsetWidth);\par
      this.cardSlider.initialize();\par
\par
      // Handle events from the card slider.\par
      this.pageList.addEventListener('cardSlider:card_changed',\par
                                     this.onCardChanged_.bind(this));\par
      this.pageList.addEventListener('cardSlider:card_added',\par
                                     this.onCardAdded_.bind(this));\par
      this.pageList.addEventListener('cardSlider:card_removed',\par
                                     this.onCardRemoved_.bind(this));\par
\par
      // Ensure the slider is resized appropriately with the window\par
      window.addEventListener('resize', this.onWindowResize_.bind(this));\par
\par
      // Update apps when online state changes.\par
      window.addEventListener('online',\par
          this.updateOfflineEnabledApps_.bind(this));\par
      window.addEventListener('offline',\par
          this.updateOfflineEnabledApps_.bind(this));\par
    \},\par
\par
    /**\par
     * Appends a tile page.\par
     *\par
     * @param \{TilePage\} page The page element.\par
     * @param \{string\} title The title of the tile page.\par
     * @param \{bool\} titleIsEditable If true, the title can be changed.\par
     * @param \{TilePage\} opt_refNode Optional reference node to insert in front\par
     *     of.\par
     * When opt_refNode is falsey, |page| will just be appended to the end of\par
     * the page list.\par
     */\par
    appendTilePage: function(page, title, titleIsEditable, opt_refNode) \{\par
      if (opt_refNode) \{\par
        var refIndex = this.getTilePageIndex(opt_refNode);\par
        this.cardSlider.insertCardAtIndex(page, refIndex);\par
      \} else \{\par
        this.cardSlider.appendCard(page);\par
      \}\par
\par
      // Remember special MostVisitedPage.\par
      if (typeof ntp4.MostVisitedPage != 'undefined' &&\par
          page instanceof ntp4.MostVisitedPage) \{\par
        assert(this.tilePages.length == 1,\par
               'MostVisitedPage should be added as first tile page');\par
        this.mostVisitedPage = page;\par
      \}\par
\par
      // If we're appending an AppsPage and it's a temporary page, animate it.\par
      var animate = page instanceof ntp4.AppsPage &&\par
                    page.classList.contains('temporary');\par
      // Make a deep copy of the dot template to add a new one.\par
      var newDot = new ntp4.NavDot(page, title, titleIsEditable, animate);\par
      page.navigationDot = newDot;\par
      this.dotList.insertBefore(newDot, opt_refNode ? opt_refNode.navigationDot\par
                                                    : null);\par
      // Set a tab index on the first dot.\par
      if (this.dotList.dots.length == 1)\par
        newDot.tabIndex = 3;\par
\par
      this.eventTracker.add(page, 'pagelayout', this.onPageLayout_.bind(this));\par
    \},\par
\par
    /**\par
     * Called by chrome when an existing app has been disabled or\par
     * removed/uninstalled from chrome.\par
     * @param \{Object\} appData A data structure full of relevant information for\par
     *     the app.\par
     * @param \{boolean\} isUninstall True if the app is being uninstalled;\par
     *     false if the app is being disabled.\par
     * @param \{boolean\} fromPage True if the removal was from the current page.\par
     */\par
    appRemoved: function(appData, isUninstall, fromPage) \{\par
      var app = $(appData.id);\par
      assert(app, 'trying to remove an app that doesn\\'t exist');\par
\par
      if (!isUninstall)\par
        app.replaceAppData(appData);\par
      else\par
        app.remove(!!fromPage);\par
    \},\par
\par
    /**\par
     * @return \{boolean\} If the page is still starting up.\par
     * @private\par
     */\par
    isStartingUp_: function() \{\par
      return document.documentElement.classList.contains('starting-up');\par
    \},\par
\par
    /**\par
     * Callback invoked by chrome with the apps available.\par
     *\par
     * Note that calls to this function can occur at any time, not just in\par
     * response to a getApps request. For example, when a user\par
     * installs/uninstalls an app on another synchronized devices.\par
     * @param \{Object\} data An object with all the data on available\par
     *        applications.\par
     */\par
    getAppsCallback: function(data) \{\par
      var startTime = Date.now();\par
\par
      // Remember this to select the correct card when done rebuilding.\par
      var prevCurrentCard = this.cardSlider.currentCard;\par
\par
      // Make removal of pages and dots as quick as possible with less DOM\par
      // operations, reflows, or repaints. We set currentCard = 0 and remove\par
      // from the end to not encounter any auto-magic card selections in the\par
      // process and we hide the card slider throughout.\par
      this.cardSlider.currentCard = 0;\par
\par
      // Clear any existing apps pages and dots.\par
      // TODO(rbyers): It might be nice to preserve animation of dots after an\par
      // uninstall. Could we re-use the existing page and dot elements?  It\par
      // seems unfortunate to have Chrome send us the entire apps list after an\par
      // uninstall.\par
      while (this.appsPages.length > 0)\par
        this.removeTilePageAndDot_(this.appsPages[this.appsPages.length - 1]);\par
\par
      // Get the array of apps and add any special synthesized entries\par
      var apps = data.apps;\par
\par
      // Get a list of page names\par
      var pageNames = data.appPageNames;\par
\par
      function stringListIsEmpty(list) \{\par
        for (var i = 0; i < list.length; i++) \{\par
          if (list[i])\par
            return false;\par
        \}\par
        return true;\par
      \}\par
\par
      // Sort by launch ordinal\par
      apps.sort(function(a, b) \{\par
        return a.app_launch_ordinal > b.app_launch_ordinal ? 1 :\par
          a.app_launch_ordinal < b.app_launch_ordinal ? -1 : 0;\par
      \});\par
\par
      // An app to animate (in case it was just installed).\par
      var highlightApp;\par
\par
      // Add the apps, creating pages as necessary\par
      for (var i = 0; i < apps.length; i++) \{\par
        var app = apps[i];\par
        var pageIndex = app.page_index || 0;\par
        while (pageIndex >= this.appsPages.length) \{\par
          var pageName = localStrings.getString('appDefaultPageName');\par
          if (this.appsPages.length < pageNames.length)\par
            pageName = pageNames[this.appsPages.length];\par
\par
          var origPageCount = this.appsPages.length;\par
          this.appendTilePage(new ntp4.AppsPage(), pageName, true);\par
          // Confirm that appsPages is a live object, updated when a new page is\par
          // added (otherwise we'd have an infinite loop)\par
          assert(this.appsPages.length == origPageCount + 1,\par
                 'expected new page');\par
        \}\par
\par
        if (app.id == this.highlightAppId)\par
          highlightApp = app;\par
        else\par
          this.appsPages[pageIndex].appendApp(app);\par
      \}\par
\par
      ntp4.AppsPage.setPromo(data.showPromo ? data : null);\par
\par
      this.cardSlider.currentCard = prevCurrentCard;\par
\par
      // Tell the slider about the pages.\par
      this.updateSliderCards();\par
\par
      if (highlightApp)\par
        this.appAdded(highlightApp, true);\par
\par
      // Mark the current page.\par
      this.cardSlider.currentCardValue.navigationDot.classList.add('selected');\par
      logEvent('apps.layout: ' + (Date.now() - startTime));\par
\par
      document.documentElement.classList.remove('starting-up');\par
    \},\par
\par
    /**\par
     * Called by chrome when a new app has been added to chrome or has been\par
     * enabled if previously disabled.\par
     * @param \{Object\} appData A data structure full of relevant information for\par
     *     the app.\par
     */\par
    appAdded: function(appData, opt_highlight) \{\par
      if (appData.id == this.highlightAppId) \{\par
        opt_highlight = true;\par
        this.highlightAppId = null;\par
      \}\par
\par
      var pageIndex = appData.page_index || 0;\par
\par
      if (pageIndex >= this.appsPages.length) \{\par
        while (pageIndex >= this.appsPages.length) \{\par
          this.appendTilePage(new ntp4.AppsPage(),\par
                              localStrings.getString('appDefaultPageName'),\par
                              true);\par
        \}\par
        this.updateSliderCards();\par
      \}\par
\par
      var page = this.appsPages[pageIndex];\par
      var app = $(appData.id);\par
      if (app)\par
        app.replaceAppData(appData);\par
      else\par
        page.appendApp(appData, opt_highlight);\par
    \},\par
\par
    /**\par
     * Callback invoked by chrome whenever an app preference changes.\par
     * @param \{Object\} data An object with all the data on available\par
     *     applications.\par
     */\par
    appsPrefChangedCallback: function(data) \{\par
      for (var i = 0; i < data.apps.length; ++i) \{\par
        $(data.apps[i].id).appData = data.apps[i];\par
      \}\par
\par
      // Set the App dot names. Skip the first dot (Most Visited).\par
      var dots = this.dotList.getElementsByClassName('dot');\par
      var start = this.mostVisitedPage ? 1 : 0;\par
      for (var i = start; i < dots.length; ++i) \{\par
        dots[i].displayTitle = data.appPageNames[i - start] || '';\par
      \}\par
    \},\par
\par
    /**\par
     * Invoked whenever the pages in apps-page-list have changed so that\par
     * the Slider knows about the new elements.\par
     */\par
    updateSliderCards: function() \{\par
      var pageNo = Math.max(0, Math.min(this.cardSlider.currentCard,\par
                                        this.tilePages.length - 1));\par
      this.cardSlider.setCards(Array.prototype.slice.call(this.tilePages),\par
                               pageNo);\par
      switch (this.shownPage) \{\par
        case templateData['apps_page_id']:\par
          this.cardSlider.selectCardByValue(\par
              this.appsPages[Math.min(this.shownPageIndex,\par
                                      this.appsPages.length - 1)]);\par
          break;\par
        case templateData['most_visited_page_id']:\par
          if (this.mostVisitedPage)\par
            this.cardSlider.selectCardByValue(this.mostVisitedPage);\par
          break;\par
      \}\par
    \},\par
\par
    /**\par
     * Called whenever tiles should be re-arranging themselves out of the way\par
     * of a moving or insert tile.\par
     */\par
    enterRearrangeMode: function() \{\par
      var tempPage = new ntp4.AppsPage();\par
      tempPage.classList.add('temporary');\par
      var pageName = localStrings.getString('appDefaultPageName');\par
      this.appendTilePage(tempPage, pageName, true);\par
\par
      if (ntp4.getCurrentlyDraggingTile().firstChild.canBeRemoved())\par
        $('footer').classList.add('showing-trash-mode');\par
    \},\par
\par
    /**\par
     * Invoked whenever some app is released\par
     */\par
    leaveRearrangeMode: function() \{\par
      var tempPage = document.querySelector('.tile-page.temporary');\par
      var dot = tempPage.navigationDot;\par
      if (!tempPage.tileCount && tempPage != this.cardSlider.currentCardValue) \{\par
        this.removeTilePageAndDot_(tempPage, true);\par
      \} else \{\par
        tempPage.classList.remove('temporary');\par
        this.saveAppPageName(tempPage,\par
                             localStrings.getString('appDefaultPageName'));\par
      \}\par
\par
      $('footer').classList.remove('showing-trash-mode');\par
    \},\par
\par
    /**\par
     * Callback for the 'pagelayout' event.\par
     * @param \{Event\} e The event.\par
     */\par
    onPageLayout_: function(e) \{\par
      if (Array.prototype.indexOf.call(this.tilePages, e.currentTarget) !=\par
          this.cardSlider.currentCard) \{\par
        return;\par
      \}\par
\par
      this.updatePageSwitchers();\par
    \},\par
\par
    /**\par
     * Adjusts the size and position of the page switchers according to the\par
     * layout of the current card.\par
     */\par
    updatePageSwitchers: function() \{\par
      if (!this.pageSwitcherStart || !this.pageSwitcherEnd)\par
        return;\par
\par
      var page = this.cardSlider.currentCardValue;\par
\par
      this.pageSwitcherStart.hidden = !page ||\par
          (this.cardSlider.currentCard == 0);\par
      this.pageSwitcherEnd.hidden = !page ||\par
          (this.cardSlider.currentCard == this.cardSlider.cardCount - 1);\par
\par
      if (!page)\par
        return;\par
\par
      var pageSwitcherLeft = isRTL() ? this.pageSwitcherEnd\par
                                     : this.pageSwitcherStart;\par
      var pageSwitcherRight = isRTL() ? this.pageSwitcherStart\par
                                      : this.pageSwitcherEnd;\par
      var scrollbarWidth = page.scrollbarWidth;\par
      pageSwitcherLeft.style.width =\par
          (page.sideMargin + 13) + 'px';\par
      pageSwitcherLeft.style.left = '0';\par
      pageSwitcherRight.style.width =\par
          (page.sideMargin - scrollbarWidth + 13) + 'px';\par
      pageSwitcherRight.style.right = scrollbarWidth + 'px';\par
\par
      var offsetTop = page.querySelector('.tile-page-content').offsetTop + 'px';\par
      pageSwitcherLeft.style.top = offsetTop;\par
      pageSwitcherRight.style.top = offsetTop;\par
      pageSwitcherLeft.style.paddingBottom = offsetTop;\par
      pageSwitcherRight.style.paddingBottom = offsetTop;\par
    \},\par
\par
    /**\par
     * Returns the index of the given apps page.\par
     * @param \{AppsPage\} page The AppsPage we wish to find.\par
     * @return \{number\} The index of |page| or -1 if it is not in the\par
     *    collection.\par
     */\par
    getAppsPageIndex: function(page) \{\par
      return Array.prototype.indexOf.call(this.appsPages, page);\par
    \},\par
\par
    /**\par
     * Handler for cardSlider:card_changed events from this.cardSlider.\par
     * @param \{Event\} e The cardSlider:card_changed event.\par
     * @private\par
     */\par
    onCardChanged_: function(e) \{\par
      var page = e.cardSlider.currentCardValue;\par
\par
      // Don't change shownPage until startup is done (and page changes actually\par
      // reflect user actions).\par
      if (!this.isStartingUp_()) \{\par
        if (page.classList.contains('apps-page')) \{\par
          this.shownPage = templateData.apps_page_id;\par
          this.shownPageIndex = this.getAppsPageIndex(page);\par
        \} else if (page.classList.contains('most-visited-page')) \{\par
          this.shownPage = templateData.most_visited_page_id;\par
          this.shownPageIndex = 0;\par
        \} else \{\par
          console.error('unknown page selected');\par
        \}\par
        chrome.send('pageSelected', [this.shownPage, this.shownPageIndex]);\par
      \}\par
\par
      // Update the active dot\par
      var curDot = this.dotList.getElementsByClassName('selected')[0];\par
      if (curDot)\par
        curDot.classList.remove('selected');\par
      page.navigationDot.classList.add('selected');\par
      this.updatePageSwitchers();\par
    \},\par
\par
    /**\par
     * Listen for card additions to update the page switchers or the current\par
     * card accordingly.\par
     * @param \{Event\} e A card removed or added event.\par
     */\par
    onCardAdded_: function(e) \{\par
      // When the second arg passed to insertBefore is falsey, it acts just like\par
      // appendChild.\par
      this.pageList.insertBefore(e.addedCard, this.tilePages[e.addedIndex]);\par
      if (!this.isStartingUp_())\par
        this.updatePageSwitchers();\par
    \},\par
\par
    /**\par
     * Listen for card removals to update the page switchers or the current card\par
     * accordingly.\par
     * @param \{Event\} e A card removed or added event.\par
     */\par
    onCardRemoved_: function(e) \{\par
      e.removedCard.parentNode.removeChild(e.removedCard);\par
      if (!this.isStartingUp_())\par
        this.updatePageSwitchers();\par
    \},\par
\par
    /**\par
     * Save the name of an apps page.\par
     * Store the apps page name into the preferences store.\par
     * @param \{AppsPage\} appsPage The app page for which we wish to save.\par
     * @param \{string\} name The name of the page.\par
     */\par
    saveAppPageName: function(appPage, name) \{\par
      var index = this.getAppsPageIndex(appPage);\par
      assert(index != -1);\par
      chrome.send('saveAppPageName', [name, index]);\par
    \},\par
\par
    /**\par
     * Window resize handler.\par
     * @private\par
     */\par
    onWindowResize_: function(e) \{\par
      this.cardSlider.resize(this.sliderFrame.offsetWidth);\par
      this.updatePageSwitchers();\par
    \},\par
\par
    /**\par
     * Listener for offline status change events. Updates apps that are\par
     * not offline-enabled to be grayscale if the browser is offline.\par
     * @private\par
     */\par
    updateOfflineEnabledApps_: function() \{\par
      var apps = document.querySelectorAll('.app');\par
      for (var i = 0; i < apps.length; ++i) \{\par
        if (apps[i].appData.enabled && !apps[i].appData.offline_enabled) \{\par
          apps[i].setIcon();\par
          apps[i].loadIcon();\par
        \}\par
      \}\par
    \},\par
\par
    /**\par
     * Handler for key events on the page. Ctrl-Arrow will switch the visible\par
     * page.\par
     * @param \{Event\} e The KeyboardEvent.\par
     * @private\par
     */\par
    onDocKeyDown_: function(e) \{\par
      if (!e.ctrlKey || e.altKey || e.metaKey || e.shiftKey)\par
        return;\par
\par
      var direction = 0;\par
      if (e.keyIdentifier == 'Left')\par
        direction = -1;\par
      else if (e.keyIdentifier == 'Right')\par
        direction = 1;\par
      else\par
        return;\par
\par
      var cardIndex =\par
          (this.cardSlider.currentCard + direction +\par
           this.cardSlider.cardCount) % this.cardSlider.cardCount;\par
      this.cardSlider.selectCard(cardIndex, true);\par
\par
      e.stopPropagation();\par
    \},\par
\par
    /**\par
     * Returns the index of a given tile page.\par
     * @param \{TilePage\} page The TilePage we wish to find.\par
     * @return \{number\} The index of |page| or -1 if it is not in the\par
     *    collection.\par
     */\par
    getTilePageIndex: function(page) \{\par
      return Array.prototype.indexOf.call(this.tilePages, page);\par
    \},\par
\par
    /**\par
     * Removes a page and navigation dot (if the navdot exists).\par
     * @param \{TilePage\} page The page to be removed.\par
     * @param \{boolean=\} opt_animate If the removal should be animated.\par
     */\par
    removeTilePageAndDot_: function(page, opt_animate) \{\par
      if (page.navigationDot)\par
        page.navigationDot.remove(opt_animate);\par
      this.cardSlider.removeCard(page);\par
    \},\par
  \};\par
\par
  return \{\par
    PageListView: PageListView\par
  \};\par
\});\par
</script>\par
<script>// Copyright (c) 2012 The Chromium Authors. All rights reserved.\par
// Use of this source code is governed by a BSD-style license that can be\par
// found in the LICENSE file.\par
\par
/**\par
 * @fileoverview Page switcher\par
 * This is the class for the left and right navigation arrows that switch\par
 * between pages.\par
 */\par
cr.define('ntp4', function() \{\par
\par
  function PageSwitcher() \{\par
  \}\par
\par
  PageSwitcher.template = \{\par
    __proto__: HTMLButtonElement.prototype,\par
\par
    decorate: function(el) \{\par
      el.__proto__ = PageSwitcher.template;\par
\par
      el.addEventListener('click', el.activate_);\par
      el.addEventListener('mousewheel', el.onMouseWheel_);\par
\par
      el.direction_ = el.id == 'page-switcher-start' ? -1 : 1;\par
\par
      el.dragWrapper_ = new cr.ui.DragWrapper(el, el);\par
    \},\par
\par
    /**\par
     * Activate the switcher (go to the next card).\par
     * @private\par
     */\par
    activate_: function() \{\par
      var cardSlider = ntp4.getCardSlider();\par
      var index = cardSlider.currentCard + this.direction_;\par
      var numCards = cardSlider.cardCount - 1;\par
      cardSlider.selectCard(Math.max(0, Math.min(index, numCards)), true);\par
    \},\par
\par
    /**\par
     * Handler for the mousewheel event on a pager. We pass through the scroll\par
     * to the page. This is necssary because the page is our sibling in the DOM\par
     * hierarchy, so the event won't naturally pass through to it.\par
     * @param \{Event\} e The mousewheel event.\par
     * @private\par
     */\par
    onMouseWheel_: function(e) \{\par
      var page = ntp4.getCardSlider().currentCardValue;\par
      page.handleMouseWheel(e);\par
    \},\par
\par
    shouldAcceptDrag: function(e) \{\par
      // We allow all drags to trigger the page switching effect.\par
      return true;\par
    \},\par
\par
    doDragEnter: function(e) \{\par
      this.scheduleDelayedSwitch_();\par
      this.doDragOver(e);\par
    \},\par
\par
    doDragLeave: function(e) \{\par
      this.cancelDelayedSwitch_();\par
    \},\par
\par
    doDragOver: function(e) \{\par
      e.preventDefault();\par
      var targetPage = ntp4.getCardSlider().currentCardValue;\par
      if (targetPage.shouldAcceptDrag(e))\par
        targetPage.setDropEffect(e.dataTransfer);\par
    \},\par
\par
    doDrop: function(e) \{\par
      e.stopPropagation();\par
      this.cancelDelayedSwitch_();\par
\par
      var tile = ntp4.getCurrentlyDraggingTile();\par
      if (!tile)\par
        return;\par
\par
      var sourcePage = tile.tilePage;\par
      var targetPage = ntp4.getCardSlider().currentCardValue;\par
      if (targetPage == sourcePage || !targetPage.shouldAcceptDrag(e))\par
        return;\par
\par
      targetPage.appendDraggingTile();\par
    \},\par
\par
    /**\par
     * Starts a timer to activate the switcher. The timer repeats until\par
     * cancelled by cancelDelayedSwitch_.\par
     * @private\par
     */\par
    scheduleDelayedSwitch_: function() \{\par
      var self = this;\par
      function navPageClearTimeout() \{\par
        self.activate_();\par
        self.dragNavTimeout_ = null;\par
        self.scheduleDelayedSwitch_();\par
      \}\par
      this.dragNavTimeout_ = window.setTimeout(navPageClearTimeout, 500);\par
    \},\par
\par
    /**\par
     * Cancels the timer that activates the switcher while dragging.\par
     * @private\par
     */\par
    cancelDelayedSwitch_: function() \{\par
      if (this.dragNavTimeout_) \{\par
        window.clearTimeout(this.dragNavTimeout_);\par
        this.dragNavTimeout_ = null;\par
      \}\par
    \},\par
\par
  \};\par
\par
  return \{\par
    initializePageSwitcher: PageSwitcher.template.decorate\par
  \}\par
\});\par
</script>\par
\par
<script>// Copyright (c) 2012 The Chromium Authors. All rights reserved.\par
// Use of this source code is governed by a BSD-style license that can be\par
// found in the LICENSE file.\par
\par
/**\par
 * @fileoverview Nav dot\par
 * This is the class for the navigation controls that appear along the bottom\par
 * of the NTP.\par
 */\par
\par
cr.define('ntp4', function() \{\par
  'use strict';\par
\par
  /**\par
   * Creates a new navigation dot.\par
   * @param \{TilePage\} page The associated TilePage.\par
   * @param \{string\} title The title of the navigation dot.\par
   * @param \{bool\} titleIsEditable If true, the title can be changed.\par
   * @param \{bool\} animate If true, animates into existence.\par
   * @constructor\par
   * @extends \{HTMLLIElement\}\par
   */\par
  function NavDot(page, title, titleIsEditable, animate) \{\par
    var dot = cr.doc.createElement('li');\par
    dot.__proto__ = NavDot.prototype;\par
    dot.initialize(page, title, titleIsEditable, animate);\par
\par
    return dot;\par
  \}\par
\par
  NavDot.prototype = \{\par
    __proto__: HTMLLIElement.prototype,\par
\par
    initialize: function(page, title, titleIsEditable, animate) \{\par
      this.className = 'dot';\par
      this.setAttribute('role', 'button');\par
\par
      this.page_ = page;\par
\par
      var selectionBar = this.ownerDocument.createElement('div');\par
      selectionBar.className = 'selection-bar';\par
      this.appendChild(selectionBar);\par
\par
      // TODO(estade): should there be some limit to the number of characters?\par
      this.input_ = this.ownerDocument.createElement('input');\par
      this.input_.setAttribute('spellcheck', false);\par
      this.input_.value = title;\par
      // Take the input out of the tab-traversal focus order.\par
      this.input_.disabled = true;\par
      this.appendChild(this.input_);\par
\par
      this.displayTitle = title;\par
      this.titleIsEditable_ = titleIsEditable;\par
\par
      this.addEventListener('keydown', this.onKeyDown_);\par
      this.addEventListener('click', this.onClick_);\par
      this.addEventListener('dblclick', this.onDoubleClick_);\par
      this.dragWrapper_ = new cr.ui.DragWrapper(this, this);\par
      this.addEventListener('webkitTransitionEnd', this.onTransitionEnd_);\par
\par
      this.input_.addEventListener('blur', this.onInputBlur_.bind(this));\par
      this.input_.addEventListener('mousedown',\par
                                   this.onInputMouseDown_.bind(this));\par
      this.input_.addEventListener('keydown', this.onInputKeyDown_.bind(this));\par
\par
      if (animate) \{\par
        this.classList.add('small');\par
        var self = this;\par
        window.setTimeout(function() \{\par
          self.classList.remove('small');\par
        \}, 0);\par
      \}\par
    \},\par
\par
    /**\par
     * Gets the associated TilePage.\par
     * @return \{TilePage\}\par
     */\par
    get page() \{\par
      return this.page_;\par
    \},\par
\par
    /**\par
     * Sets/gets the display title.\par
     * @type \{String\} title The display name for this nav dot.\par
     */\par
    get displayTitle() \{\par
      return this.title;\par
    \},\par
    set displayTitle(title) \{\par
      this.title = this.input_.value = title;\par
    \},\par
\par
    /**\par
     * Removes the dot from the page. If |opt_animate| is truthy, we first\par
     * transition the element to 0 width.\par
     * @param \{boolean=\} opt_animate Whether to animate the removal or not.\par
     */\par
    remove: function(opt_animate) \{\par
      if (opt_animate)\par
        this.classList.add('small');\par
      else\par
        this.parentNode.removeChild(this);\par
    \},\par
\par
    /**\par
     * Navigates the card slider to the page for this dot.\par
     */\par
    switchToPage: function() \{\par
      ntp4.getCardSlider().selectCardByValue(this.page_, true);\par
    \},\par
\par
    /**\par
     * Handler for keydown event on the dot.\par
     * @param \{Event\} e The KeyboardEvent.\par
     */\par
    onKeyDown_: function(e) \{\par
      if (e.keyIdentifier == 'Enter') \{\par
        this.onClick_(e);\par
        e.stopPropagation();\par
      \}\par
    \},\par
\par
    /**\par
     * Clicking causes the associated page to show.\par
     * @param \{Event\} e The click event.\par
     * @private\par
     */\par
    onClick_: function(e) \{\par
      this.switchToPage();\par
      // The explicit focus call is necessary because of overriding the default\par
      // handling in onInputMouseDown_.\par
      if (this.ownerDocument.activeElement != this.input_)\par
        this.focus();\par
\par
      chrome.send('introMessageDismissed');\par
      e.stopPropagation();\par
    \},\par
\par
    /**\par
     * Double clicks allow the user to edit the page title.\par
     * @param \{Event\} e The click event.\par
     * @private\par
     */\par
    onDoubleClick_: function(e) \{\par
      if (this.titleIsEditable_) \{\par
        this.input_.disabled = false;\par
        this.input_.focus();\par
        this.input_.select();\par
      \}\par
    \},\par
\par
    /**\par
     * Prevent mouse down on the input from selecting it.\par
     * @param \{Event\} e The click event.\par
     * @private\par
     */\par
    onInputMouseDown_: function(e) \{\par
      if (this.ownerDocument.activeElement != this.input_)\par
        e.preventDefault();\par
    \},\par
\par
    /**\par
     * Handle keypresses on the input.\par
     * @param \{Event\} e The click event.\par
     * @private\par
     */\par
    onInputKeyDown_: function(e) \{\par
      switch (e.keyIdentifier) \{\par
        case 'U+001B':  // Escape cancels edits.\par
          this.input_.value = this.displayTitle;\par
        case 'Enter':  // Fall through.\par
          this.input_.blur();\par
          break;\par
      \}\par
    \},\par
\par
    /**\par
     * When the input blurs, commit the edited changes.\par
     * @param \{Event\} e The blur event.\par
     * @private\par
     */\par
    onInputBlur_: function(e) \{\par
      window.getSelection().removeAllRanges();\par
      this.displayTitle = this.input_.value;\par
      ntp4.saveAppPageName(this.page_, this.displayTitle);\par
      this.input_.disabled = true;\par
    \},\par
\par
    shouldAcceptDrag: function(e) \{\par
      return this.page_.shouldAcceptDrag(e);\par
    \},\par
\par
    /**\par
     * A drag has entered the navigation dot. If the user hovers long enough,\par
     * we will navigate to the relevant page.\par
     * @param \{Event\} e The MouseOver event for the drag.\par
     * @private\par
     */\par
    doDragEnter: function(e) \{\par
      var self = this;\par
      function navPageClearTimeout() \{\par
        self.switchToPage();\par
        self.dragNavTimeout = null;\par
      \}\par
      this.dragNavTimeout = window.setTimeout(navPageClearTimeout, 500);\par
\par
      this.doDragOver(e);\par
    \},\par
\par
    /**\par
     * A dragged element has moved over the navigation dot. Show the correct\par
     * indicator and prevent default handling so the <input> won't act as a drag\par
     * target.\par
     * @param \{Event\} e The MouseOver event for the drag.\par
     * @private\par
     */\par
    doDragOver: function(e) \{\par
      e.preventDefault();\par
\par
      if (!this.dragWrapper_.isCurrentDragTarget)\par
        ntp4.setCurrentDropEffect(e.dataTransfer, 'none');\par
      else\par
        this.page_.setDropEffect(e.dataTransfer);\par
    \},\par
\par
    /**\par
     * A dragged element has been dropped on the navigation dot. Tell the page\par
     * to append it.\par
     * @param \{Event\} e The MouseOver event for the drag.\par
     * @private\par
     */\par
    doDrop: function(e) \{\par
      e.stopPropagation();\par
      var tile = ntp4.getCurrentlyDraggingTile();\par
      if (tile && tile.tilePage != this.page_)\par
        this.page_.appendDraggingTile();\par
      // TODO(estade): handle non-tile drags.\par
\par
      this.cancelDelayedSwitch_();\par
    \},\par
\par
    /**\par
     * The drag has left the navigation dot.\par
     * @param \{Event\} e The MouseOver event for the drag.\par
     * @private\par
     */\par
    doDragLeave: function(e) \{\par
      this.cancelDelayedSwitch_();\par
    \},\par
\par
    /**\par
     * Cancels the timer for page switching.\par
     * @private\par
     */\par
    cancelDelayedSwitch_: function() \{\par
      if (this.dragNavTimeout) \{\par
        window.clearTimeout(this.dragNavTimeout);\par
        this.dragNavTimeout = null;\par
      \}\par
    \},\par
\par
    /**\par
     * A transition has ended.\par
     * @param \{Event\} e The transition end event.\par
     * @private\par
     */\par
    onTransitionEnd_: function(e) \{\par
      if (e.propertyName === 'max-width' && this.classList.contains('small'))\par
        this.parentNode.removeChild(this);\par
    \},\par
  \};\par
\par
  return \{\par
    NavDot: NavDot,\par
  \};\par
\});\par
</script>\par
<script>// Copyright (c) 2012 The Chromium Authors. All rights reserved.\par
// Use of this source code is governed by a BSD-style license that can be\par
// found in the LICENSE file.\par
\par
/**\par
 * @fileoverview New tab page\par
 * This is the main code for the new tab page used by touch-enabled Chrome\par
 * browsers.  For now this is still a prototype.\par
 */\par
\par
// Use an anonymous function to enable strict mode just for this file (which\par
// will be concatenated with other files when embedded in Chrome\par
cr.define('ntp4', function() \{\par
  'use strict';\par
\par
  /**\par
   * NewTabView instance.\par
   * @type \{!Object|undefined\}\par
   */\par
  var newTabView;\par
\par
  /**\par
   * The 'notification-container' element.\par
   * @type \{!Element|undefined\}\par
   */\par
  var notificationContainer;\par
\par
  /**\par
   * Object for accessing localized strings.\par
   * @type \{!LocalStrings\}\par
   */\par
  var localStrings = new LocalStrings;\par
\par
  /**\par
   * If non-null, an info bubble for showing messages to the user. It points at\par
   * the Most Visited label, and is used to draw more attention to the\par
   * navigation dot UI.\par
   * @type \{!Element|undefined\}\par
   */\par
  var infoBubble;\par
\par
  /**\par
   * If non-null, an bubble confirming that the user has signed into sync. It\par
   * points at the login status at the top of the page.\par
   * @type \{!Element|undefined\}\par
   */\par
  var loginBubble;\par
\par
  /**\par
   * true if |loginBubble| should be shown.\par
   * @type \{Boolean\}\par
   */\par
  var shouldShowLoginBubble = false;\par
\par
  /**\par
   * The time in milliseconds for most transitions.  This should match what's\par
   * in new_tab.css.  Unfortunately there's no better way to try to time\par
   * something to occur until after a transition has completed.\par
   * @type \{number\}\par
   * @const\par
   */\par
  var DEFAULT_TRANSITION_TIME = 500;\par
\par
  /**\par
   * Creates a NewTabView object. NewTabView extends PageListView with\par
   * new tab UI specific logics.\par
   * @constructor\par
   * @extends \{PageListView\}\par
   */\par
  function NewTabView() \{\par
    this.initialize(getRequiredElement('page-list'),\par
                    getRequiredElement('dot-list'),\par
                    getRequiredElement('card-slider-frame'),\par
                    getRequiredElement('trash'),\par
                    getRequiredElement('page-switcher-start'),\par
                    getRequiredElement('page-switcher-end'));\par
  \}\par
\par
  NewTabView.prototype = \{\par
    __proto__: ntp4.PageListView.prototype,\par
\par
    /** @inheritDoc */\par
    appendTilePage: function(page, title, titleIsEditable, opt_refNode) \{\par
      ntp4.PageListView.prototype.appendTilePage.apply(this, arguments);\par
\par
      if (infoBubble)\par
        window.setTimeout(infoBubble.reposition.bind(infoBubble), 0);\par
    \}\par
  \};\par
\par
  /**\par
   * Invoked at startup once the DOM is available to initialize the app.\par
   */\par
  function onLoad() \{\par
    cr.enablePlatformSpecificCSSRules();\par
\par
    measureNavDots();\par
\par
    // Load the current theme colors.\par
    themeChanged();\par
\par
    newTabView = new NewTabView();\par
\par
    notificationContainer = getRequiredElement('notification-container');\par
    notificationContainer.addEventListener(\par
        'webkitTransitionEnd', onNotificationTransitionEnd);\par
\par
    cr.ui.decorate($('recently-closed-menu-button'), ntp4.RecentMenuButton);\par
    chrome.send('getRecentlyClosedTabs');\par
\par
    newTabView.appendTilePage(new ntp4.MostVisitedPage(),\par
                              localStrings.getString('mostvisited'),\par
                              false);\par
    chrome.send('getMostVisited');\par
\par
    if (templateData.isWebStoreExperimentEnabled) \{\par
      var webstoreLink = localStrings.getString('webStoreLink');\par
      var url = appendParam(webstoreLink, 'utm_source', 'chrome-ntp-launcher');\par
      $('chrome-web-store-href').href = url;\par
\par
      $('chrome-web-store-href').addEventListener('click',\par
          onChromeWebStoreButtonClick);\par
\par
      $('footer-content').classList.add('enable-cws-experiment');\par
    \}\par
\par
    if (localStrings.getString('login_status_message')) \{\par
      loginBubble = new cr.ui.Bubble;\par
      loginBubble.anchorNode = $('login-container');\par
      loginBubble.setArrowLocation(cr.ui.ArrowLocation.TOP_END);\par
      loginBubble.bubbleAlignment =\par
          cr.ui.BubbleAlignment.BUBBLE_EDGE_TO_ANCHOR_EDGE;\par
      loginBubble.deactivateToDismissDelay = 2000;\par
      loginBubble.setCloseButtonVisible(false);\par
\par
      $('login-status-learn-more').href =\par
          localStrings.getString('login_status_url');\par
      $('login-status-advanced').onclick = function() \{\par
        chrome.send('showAdvancedLoginUI');\par
      \}\par
      $('login-status-dismiss').onclick = loginBubble.hide.bind(loginBubble);\par
\par
      var bubbleContent = $('login-status-bubble-contents');\par
      loginBubble.content = bubbleContent;\par
\par
      // The anchor node won't be updated until updateLogin is called so don't\par
      // show the bubble yet.\par
      shouldShowLoginBubble = true;\par
    \} else if (localStrings.getString('ntp4_intro_message')) \{\par
      infoBubble = new cr.ui.Bubble;\par
      infoBubble.anchorNode = newTabView.mostVisitedPage.navigationDot;\par
      infoBubble.setArrowLocation(cr.ui.ArrowLocation.BOTTOM_START);\par
      infoBubble.handleCloseEvent = function() \{\par
        this.hide();\par
        chrome.send('introMessageDismissed');\par
      \}\par
\par
      var bubbleContent = $('ntp4-intro-bubble-contents');\par
      infoBubble.content = bubbleContent;\par
\par
      var learnMoreLink = infoBubble.querySelector('a');\par
      learnMoreLink.href = localStrings.getString('ntp4_intro_url');\par
      learnMoreLink.onclick = infoBubble.hide.bind(infoBubble);\par
\par
      infoBubble.show();\par
      chrome.send('introMessageSeen');\par
    \}\par
\par
    var serverpromo = localStrings.getString('serverpromo');\par
    if (serverpromo) \{\par
      showNotification(parseHtmlSubset(serverpromo), [], function() \{\par
        chrome.send('closeNotificationPromo');\par
      \}, 60000);\par
      chrome.send('notificationPromoViewed');\par
    \}\par
\par
    var loginContainer = getRequiredElement('login-container');\par
    loginContainer.addEventListener('click', function() \{\par
      var rect = loginContainer.getBoundingClientRect();\par
      chrome.send('showSyncLoginUI',\par
                  [rect.left, rect.top, rect.width, rect.height]);\par
    \});\par
    chrome.send('initializeSyncLogin');\par
  \}\par
\par
  /**\par
   * Launches the chrome web store app with the chrome-ntp-launcher\par
   * source.\par
   * @param \{Event\} e The click event.\par
   */\par
  function onChromeWebStoreButtonClick(e) \{\par
    chrome.send('recordAppLaunchByURL',\par
                [encodeURIComponent(this.href),\par
                 ntp4.APP_LAUNCH.NTP_WEBSTORE_FOOTER]);\par
  \}\par
\par
  /**\par
   * Fills in an invisible div with the 'Most Visited' string so that\par
   * its length may be measured and the nav dots sized accordingly.\par
   */\par
  function measureNavDots() \{\par
    var measuringDiv = $('fontMeasuringDiv');\par
    measuringDiv.textContent = localStrings.getString('mostvisited');\par
    var pxWidth = Math.max(measuringDiv.clientWidth * 1.15, 80);\par
\par
    var styleElement = document.createElement('style');\par
    styleElement.type = 'text/css';\par
    // max-width is used because if we run out of space, the nav dots will be\par
    // shrunk.\par
    styleElement.textContent = '.dot \{ max-width: ' + pxWidth + 'px; \}';\par
    document.querySelector('head').appendChild(styleElement);\par
  \}\par
\par
  // TODO(estade): rename newtab.css to new_tab_theme.css\par
  function themeChanged(hasAttribution) \{\par
    $('themecss').href = 'chrome://theme/css/newtab.css?' + Date.now();\par
    if (typeof hasAttribution != 'undefined')\par
      document.documentElement.setAttribute('hasattribution', hasAttribution);\par
    updateLogo();\par
    updateAttribution();\par
  \}\par
\par
  /**\par
   * Sets the proper image for the logo at the bottom left.\par
   */\par
  function updateLogo() \{\par
    var imageId = 'IDR_PRODUCT_LOGO';\par
    if (document.documentElement.getAttribute('customlogo') == 'true')\par
      imageId = 'IDR_CUSTOM_PRODUCT_LOGO';\par
\par
    $('logo-img').src = 'chrome://theme/' + imageId + '?' + Date.now();\par
  \}\par
\par
  /**\par
   * Attributes the attribution image at the bottom left.\par
   */\par
  function updateAttribution() \{\par
    var attribution = $('attribution');\par
    if (document.documentElement.getAttribute('hasattribution') == 'true') \{\par
      $('attribution-img').src =\par
          'chrome://theme/IDR_THEME_NTP_ATTRIBUTION?' + Date.now();\par
      attribution.hidden = false;\par
    \} else \{\par
      attribution.hidden = true;\par
    \}\par
  \}\par
\par
  /**\par
   * Timeout ID.\par
   * @type \{number\}\par
   */\par
  var notificationTimeout_ = 0;\par
\par
  /**\par
   * Shows the notification bubble.\par
   * @param \{string|Node\} message The notification message or node to use as\par
   *     message.\par
   * @param \{Array.<\{text: string, action: function()\}>\} links An array of\par
   *     records describing the links in the notification. Each record should\par
   *     have a 'text' attribute (the display string) and an 'action' attribute\par
   *     (a function to run when the link is activated).\par
   * @param \{Function\} opt_closeHandler The callback invoked if the user\par
   *     manually dismisses the notification.\par
   */\par
  function showNotification(message, links, opt_closeHandler, opt_timeout) \{\par
    window.clearTimeout(notificationTimeout_);\par
\par
    var span = document.querySelector('#notification > span');\par
    if (typeof message == 'string') \{\par
      span.textContent = message;\par
    \} else \{\par
      span.textContent = '';  // Remove all children.\par
      span.appendChild(message);\par
    \}\par
\par
    var linksBin = $('notificationLinks');\par
    linksBin.textContent = '';\par
    for (var i = 0; i < links.length; i++) \{\par
      var link = linksBin.ownerDocument.createElement('div');\par
      link.textContent = links[i].text;\par
      link.action = links[i].action;\par
      link.onclick = function() \{\par
        this.action();\par
        hideNotification();\par
      \}\par
      link.setAttribute('role', 'button');\par
      link.setAttribute('tabindex', 0);\par
      link.className = 'linkButton';\par
      linksBin.appendChild(link);\par
    \}\par
\par
    document.querySelector('#notification button').onclick = function(e) \{\par
      if (opt_closeHandler)\par
        opt_closeHandler();\par
      hideNotification();\par
    \};\par
\par
    var timeout = opt_timeout || 10000;\par
    notificationContainer.hidden = false;\par
    notificationContainer.classList.remove('inactive');\par
    notificationTimeout_ = window.setTimeout(hideNotification, timeout);\par
  \}\par
\par
  /**\par
   * Hide the notification bubble.\par
   */\par
  function hideNotification() \{\par
    notificationContainer.classList.add('inactive');\par
  \}\par
\par
  /**\par
   * When done fading out, set hidden to true so the notification can't be\par
   * tabbed to or clicked.\par
   */\par
  function onNotificationTransitionEnd(e) \{\par
    if (notificationContainer.classList.contains('inactive'));\par
      notificationContainer.hidden = true;\par
  \}\par
\par
  function setRecentlyClosedTabs(dataItems) \{\par
    $('recently-closed-menu-button').dataItems = dataItems;\par
  \}\par
\par
  function setMostVisitedPages(data, hasBlacklistedUrls) \{\par
    newTabView.mostVisitedPage.data = data;\par
  \}\par
\par
  /**\par
   * Set the dominant color for a node. This will be called in response to\par
   * getFaviconDominantColor. The node represented by |id| better have a setter\par
   * for stripeColor.\par
   * @param \{string\} id The ID of a node.\par
   * @param \{string\} color The color represented as a CSS string.\par
   */\par
  function setStripeColor(id, color) \{\par
    var node = $(id);\par
    if (node)\par
      node.stripeColor = color;\par
  \}\par
\par
  /**\par
   * Updates the text displayed in the login container. If there is no text then\par
   * the login container is hidden.\par
   * @param \{string\} loginHeader The first line of text.\par
   * @param \{string\} loginSubHeader The second line of text.\par
   * @param \{string\} iconURL The url for the login status icon. If this is null\par
        then the login status icon is hidden.\par
   */\par
  function updateLogin(loginHeader, loginSubHeader, iconURL) \{\par
    if (loginHeader || loginSubHeader) \{\par
      $('login-container').hidden = false;\par
      $('login-status-header').innerHTML = loginHeader;\par
      $('login-status-sub-header').innerHTML = loginSubHeader;\par
      $('card-slider-frame').classList.add('showing-login-area');\par
\par
      if (iconURL) \{\par
        $('login-status-header-container').style.backgroundImage = url(iconURL);\par
        $('login-status-header-container').classList.add('login-status-icon');\par
      \} else \{\par
        $('login-status-header-container').style.backgroundImage = 'none';\par
        $('login-status-header-container').classList.remove(\par
            'login-status-icon');\par
      \}\par
    \} else \{\par
      $('login-container').hidden = true;\par
      $('card-slider-frame').classList.remove('showing-login-area');\par
    \}\par
    if (shouldShowLoginBubble) \{\par
      window.setTimeout(loginBubble.show.bind(loginBubble), 0);\par
      chrome.send('loginMessageSeen');\par
      shouldShowLoginBubble = false;\par
    \} else if (loginBubble) \{\par
      loginBubble.reposition();\par
    \}\par
  \}\par
\par
  /**\par
   * Wrappers to forward the callback to corresponding PageListView member.\par
   */\par
  function appAdded() \{\par
    return newTabView.appAdded.apply(newTabView, arguments);\par
  \}\par
\par
  function appRemoved() \{\par
    return newTabView.appRemoved.apply(newTabView, arguments);\par
  \}\par
\par
  function appsPrefChangeCallback() \{\par
    return newTabView.appsPrefChangedCallback.apply(newTabView, arguments);\par
  \}\par
\par
  function appsReordered() \{\par
    return newTabView.appsReordered.apply(newTabView, arguments);\par
  \}\par
\par
  function enterRearrangeMode() \{\par
    return newTabView.enterRearrangeMode.apply(newTabView, arguments);\par
  \}\par
\par
  function getAppsCallback() \{\par
    return newTabView.getAppsCallback.apply(newTabView, arguments);\par
  \}\par
\par
  function getAppsPageIndex() \{\par
    return newTabView.getAppsPageIndex.apply(newTabView, arguments);\par
  \}\par
\par
  function getCardSlider() \{\par
    return newTabView.cardSlider;\par
  \}\par
\par
  function leaveRearrangeMode() \{\par
    return newTabView.leaveRearrangeMode.apply(newTabView, arguments);\par
  \}\par
\par
  function saveAppPageName() \{\par
    return newTabView.saveAppPageName.apply(newTabView, arguments);\par
  \}\par
\par
  function setAppToBeHighlighted(appId) \{\par
    newTabView.highlightAppId = appId;\par
  \}\par
\par
  // Return an object with all the exports\par
  return \{\par
    appAdded: appAdded,\par
    appRemoved: appRemoved,\par
    appsPrefChangeCallback: appsPrefChangeCallback,\par
    enterRearrangeMode: enterRearrangeMode,\par
    getAppsCallback: getAppsCallback,\par
    getAppsPageIndex: getAppsPageIndex,\par
    getCardSlider: getCardSlider,\par
    onLoad: onLoad,\par
    leaveRearrangeMode: leaveRearrangeMode,\par
    saveAppPageName: saveAppPageName,\par
    setAppToBeHighlighted: setAppToBeHighlighted,\par
    setMostVisitedPages: setMostVisitedPages,\par
    setRecentlyClosedTabs: setRecentlyClosedTabs,\par
    setStripeColor: setStripeColor,\par
    showNotification: showNotification,\par
    themeChanged: themeChanged,\par
    updateLogin: updateLogin\par
  \};\par
\});\par
\par
// publish ntp globals\par
// TODO(estade): update the content handlers to use ntp namespace instead of\par
// making these global.\par
var getAppsCallback = ntp4.getAppsCallback;\par
var appsPrefChangeCallback = ntp4.appsPrefChangeCallback;\par
var themeChanged = ntp4.themeChanged;\par
var recentlyClosedTabs = ntp4.setRecentlyClosedTabs;\par
var setMostVisitedPages = ntp4.setMostVisitedPages;\par
var updateLogin = ntp4.updateLogin;\par
\par
document.addEventListener('DOMContentLoaded', ntp4.onLoad);\par
</script>\par
<script>// Copyright (c) 2011 The Chromium Authors. All rights reserved.\par
// Use of this source code is governed by a BSD-style license that can be\par
// found in the LICENSE file.\par
\par
/**\par
 * @fileoverview The recently closed menu: button, model data, and menu.\par
 */\par
\par
cr.define('ntp4', function() \{\par
  'use strict';\par
\par
  var localStrings = new LocalStrings();\par
\par
  /**\par
   * Returns the text used for a recently closed window.\par
   * @param \{number\} numTabs Number of tabs in the window.\par
   * @return \{string\} The text to use.\par
   */\par
  function formatTabsText(numTabs) \{\par
    if (numTabs == 1)\par
      return localStrings.getString('closedwindowsingle');\par
    return localStrings.getStringF('closedwindowmultiple', numTabs);\par
  \}\par
\par
  var Menu = cr.ui.Menu;\par
  var MenuItem = cr.ui.MenuItem;\par
  var MenuButton = cr.ui.MenuButton;\par
  var RecentMenuButton = cr.ui.define('button');\par
\par
  RecentMenuButton.prototype = \{\par
    __proto__: MenuButton.prototype,\par
\par
    decorate: function() \{\par
      MenuButton.prototype.decorate.call(this);\par
      this.menu = new Menu;\par
      cr.ui.decorate(this.menu, Menu);\par
      this.menu.classList.add('recent-menu');\par
      document.body.appendChild(this.menu);\par
\par
      this.needsRebuild_ = true;\par
      this.classList.add('invisible');\par
      this.anchorType = cr.ui.AnchorType.ABOVE;\par
      this.invertLeftRight = true;\par
    \},\par
\par
    /**\par
     * Shows the menu, first rebuilding it if necessary.\par
     * TODO(estade): the right of the menu should align with the right of the\par
     * button.\par
     * @override\par
     */\par
    showMenu: function() \{\par
      if (this.needsRebuild_) \{\par
        this.menu.textContent = '';\par
        this.dataItems_.forEach(this.addItem_, this);\par
        this.needsRebuild_ = false;\par
      \}\par
\par
      MenuButton.prototype.showMenu.call(this);\par
    \},\par
\par
    /**\par
     * Sets the menu model data.\par
     * @param \{Array\} dataItems Array of objects that describe the apps.\par
     */\par
    set dataItems(dataItems) \{\par
      this.dataItems_ = dataItems;\par
      this.needsRebuild_ = true;\par
      if (dataItems.length)\par
        this.classList.remove('invisible');\par
      else\par
        this.classList.add('invisible');\par
    \},\par
\par
    /**\par
     * Adds an app to the menu.\par
     * @param \{Object\} data An object encapsulating all data about the app.\par
     * @private\par
     */\par
    addItem_: function(data) \{\par
      var isWindow = data.type == 'window';\par
      var a = this.ownerDocument.createElement('a');\par
      a.className = 'recent-menu-item';\par
      if (isWindow) \{\par
        a.href = '';\par
        a.classList.add('recent-window');\par
        a.textContent = formatTabsText(data.tabs.length);\par
      \} else \{\par
        a.href = data.url;\par
        a.style.backgroundImage = 'url(chrome://favicon/' + data.url + ')';\par
        a.textContent = data.title;\par
      \}\par
\par
      function onClick(e) \{\par
        chrome.send('recordAppLaunchByURL',\par
                    [encodeURIComponent(data.url),\par
                     ntp4.APP_LAUNCH.NTP_RECENTLY_CLOSED]);\par
        var index = Array.prototype.indexOf.call(a.parentNode.children, a);\par
        chrome.send('reopenTab', [data.sessionId, index,\par
            e.button, e.altKey, e.ctrlKey, e.metaKey, e.shiftKey]);\par
        // We are likely deleted by this point!\par
\par
        e.preventDefault();\par
      \}\par
      a.addEventListener('click', onClick);\par
\par
      this.menu.appendChild(a);\par
      cr.ui.decorate(a, MenuItem);\par
    \},\par
  \};\par
\par
  return \{\par
    RecentMenuButton: RecentMenuButton,\par
  \};\par
\});\par
</script>\par
<style type="text/css">.dot \{ max-width: 80px; \}</style><style type="text/css"></style></head>\par
<body>\par
  <button id="login-container" class="custom-appearance" hidden="">\par
    <div id="login-status-header-container" class="login-status-row">\par
      <div id="login-status-header"></div>\par
    </div>\par
    <div id="login-status-sub-header"></div>\par
  </button>\par
\par
  <div id="notification-container" class="inactive" hidden="">\par
    <div id="notification">\par
      <span></span>\par
      <div id="notificationLinks"></div>\par
      <button class="close-button custom-appearance">\par
      </button>\par
    </div>\par
  </div>\par
\par
  <div id="card-slider-frame">\par
    <button id="page-switcher-start" class="page-switcher custom-appearance" tabindex="2" style="width: 32.5px; left: 0px; top: 0px; padding-bottom: 0px; ">\'8b\f1\par
    </button>\par
    <div id="page-list" style="-webkit-transform: translate3d(-485px, 0px, 0px); "><div class="tile-page most-visited-page animating-tile-page" style="width: 485px; " tabindex="-1"><div class="tile-page-scrollbar" style="top: 0px; height: 0px; "></div><div class="tile-page-content"><div class="top-margin" style="margin-bottom: 0px; margin-top: 0px; "></div><div class="tile-grid" style="min-width: 259.25px; min-height: 3px; height: 491.8679245283019px; "><div class="tile real" style="left: 128.25px; right: 128.25px; top: 0px; "><a class="most-visited real focusable" tabindex="-1" title="Welcome to Google Chrome" style="width: 122px; height: 107.71698113207547px; left: -108.375px; right: -108.375px; top: 0px; " id="most-visited-tile-108" href="{{\field{\*\fldinst{HYPERLINK http://www.google.com/chrome/intl/en/welcome.html }}{\fldrslt{http://www.google.com/chrome/intl/en/welcome.html\ul0\cf0}}}}\f1\fs22 "><span class="thumbnail-wrapper fills-parent"><div class="close-button" title="Don't show on this page"></div><span class="thumbnail fills-parent" style="background-image: url(chrome://thumb/http://www.google.com/chrome/intl/en/welcome.html); "><div class="thumbnail-shield fills-parent"></div></span><span class="favicon" style="background-image: url(chrome://favicon/size/16/http://www.google.com/chrome/intl/en/welcome.html); "></span></span><div class="color-stripe" style="background-color: rgb(0, 147, 60); "></div><span class="title" dir="ltr">Welcome to Google Chrome</span></a></div><div class="tile real" style="left: 265.5px; right: 265.5px; top: 0px; "><a class="most-visited real focusable" tabindex="-1" title="Chrome Web Store" style="width: 122px; height: 107.71698113207547px; left: -108.375px; right: -108.375px; top: 0px; " id="most-visited-tile-109" href="{{\field{\*\fldinst{HYPERLINK https://chrome.google.com/webstore?hl=en }}{\fldrslt{https://chrome.google.com/webstore?hl=en\ul0\cf0}}}}\f1\fs22 "><span class="thumbnail-wrapper fills-parent"><div class="close-button" title="Don't show on this page"></div><span class="thumbnail fills-parent" style="background-image: url(chrome://thumb/https://chrome.google.com/webstore?hl=en); "><div class="thumbnail-shield fills-parent"></div></span><span class="favicon" style="background-image: url(chrome://favicon/size/16/https://chrome.google.com/webstore?hl=en); "></span></span><div class="color-stripe" style="background-color: rgb(63, 132, 197); "></div><span class="title" dir="ltr">Chrome Web Store</span></a></div><div class="tile real" style="left: 128.25px; right: 128.25px; top: 122.96698113207547px; "><a class="most-visited filler real" tabindex="-1" title="" style="width: 122px; height: 107.71698113207547px; left: -108.375px; right: -108.375px; top: 0px; "><span class="thumbnail-wrapper fills-parent"><div class="close-button" title="Don't show on this page"></div><span class="thumbnail fills-parent"><div class="thumbnail-shield fills-parent"></div></span><span class="favicon"></span></span><div class="color-stripe"></div><span class="title"></span></a></div><div class="tile real" style="left: 265.5px; right: 265.5px; top: 122.96698113207547px; "><a class="most-visited filler real" tabindex="-1" title="" style="width: 122px; height: 107.71698113207547px; left: -108.375px; right: -108.375px; top: 0px; "><span class="thumbnail-wrapper fills-parent"><div class="close-button" title="Don't show on this page"></div><span class="thumbnail fills-parent"><div class="thumbnail-shield fills-parent"></div></span><span class="favicon"></span></span><div class="color-stripe"></div><span class="title"></span></a></div><div class="tile real" style="left: 128.25px; right: 128.25px; top: 245.93396226415095px; "><a class="most-visited filler real" tabindex="-1" title="" style="width: 122px; height: 107.71698113207547px; left: -108.375px; right: -108.375px; top: 0px; "><span class="thumbnail-wrapper fills-parent"><div class="close-button" title="Don't show on this page"></div><span class="thumbnail fills-parent"><div class="thumbnail-shield fills-parent"></div></span><span class="favicon"></span></span><div class="color-stripe"></div><span class="title"></span></a></div><div class="tile real" style="left: 265.5px; right: 265.5px; top: 245.93396226415095px; "><a class="most-visited filler real" tabindex="-1" title="" style="width: 122px; height: 107.71698113207547px; left: -108.375px; right: -108.375px; top: 0px; "><span class="thumbnail-wrapper fills-parent"><div class="close-button" title="Don't show on this page"></div><span class="thumbnail fills-parent"><div class="thumbnail-shield fills-parent"></div></span><span class="favicon"></span></span><div class="color-stripe"></div><span class="title"></span></a></div><div class="tile real" style="left: 128.25px; right: 128.25px; top: 368.9009433962264px; "><a class="most-visited filler real" tabindex="-1" title="" style="width: 122px; height: 107.71698113207547px; left: -108.375px; right: -108.375px; top: 0px; "><span class="thumbnail-wrapper fills-parent"><div class="close-button" title="Don't show on this page"></div><span class="thumbnail fills-parent"><div class="thumbnail-shield fills-parent"></div></span><span class="favicon"></span></span><div class="color-stripe"></div><span class="title"></span></a></div><div class="tile real" style="left: 265.5px; right: 265.5px; top: 368.9009433962264px; "><a class="most-visited filler real" tabindex="-1" title="" style="width: 122px; height: 107.71698113207547px; left: -108.375px; right: -108.375px; top: 0px; "><span class="thumbnail-wrapper fills-parent"><div class="close-button" title="Don't show on this page"></div><span class="thumbnail fills-parent"><div class="thumbnail-shield fills-parent"></div></span><span class="favicon"></span></span><div class="color-stripe"></div><span class="title"></span></a></div></div></div></div><div class="tile-page apps-page selected-card animating-tile-page" style="width: 485px; " tabindex="1"><div class="tile-page-scrollbar" style="top: 0px; height: 0px; "></div><div class="tile-page-content"><div class="top-margin" style="margin-bottom: 4.603773584905667px; margin-top: -4.603773584905667px; "></div><div class="tile-grid" style="min-width: 260px; min-height: 3px; height: 180px; "><div class="tile real" style="left: 126px; right: 126px; top: 0px; "><div id="ahfgeienlihckogmohjhadlkjgocpleb" class="app focusable webstore" style="height: 80px; width: 80px; left: -106.5px; right: -106.5px; top: 0px; "><div id="" class="app-contents">\par
  <div class="app-img-container launch-click-target" title="Chrome Web Store" style="height: 64px; width: 64px; ">\par
    <img class="" src="chrome://extension-icon/ahfgeienlihckogmohjhadlkjgocpleb/128/0">\par
  <img class="apps-promo-logo"></div>\par
  <span class="title launch-click-target" title="Chrome Web Store">Chrome Web Store</span>\par
</div><div id="" class="apps-promo-extras">\par
  <h3 class="apps-promo-heading"></h3>\par
  <a class="apps-promo-link g-button-basic"></a>\par
</div></div></div><div class="tile real" style="left: 216px; right: 216px; top: 0px; "><div id="blpcfgokakmgnkcojhhkbfbldkacnbeo" class="app focusable" style="height: 80px; width: 80px; left: -106.5px; right: -106.5px; top: 0px; "><div id="" class="app-contents">\par
  <div class="app-img-container launch-click-target" title="YouTube" style="height: 64px; width: 64px; ">\par
    <img class="" src="chrome://extension-icon/blpcfgokakmgnkcojhhkbfbldkacnbeo/128/0">\par
  </div>\par
  <span class="title launch-click-target" title="YouTube">YouTube</span>\par
</div></div></div><div class="tile real" style="left: 306px; right: 306px; top: 0px; "><div id="coobgpohoikkiipiblmjeljniedjpjpf" class="app focusable" style="height: 80px; width: 80px; left: -106.5px; right: -106.5px; top: 0px; "><div id="" class="app-contents">\par
  <div class="app-img-container launch-click-target" title="Google Search" style="height: 64px; width: 64px; ">\par
    <img class="" src="chrome://extension-icon/coobgpohoikkiipiblmjeljniedjpjpf/128/0">\par
  </div>\par
  <span class="title launch-click-target" title="Google Search">Google Search</span>\par
</div></div></div><div class="tile real" style="left: 126px; right: 126px; top: 90px; "><div id="pjkljhegncpnkpknbcohdijeoejaedia" class="app focusable" style="height: 80px; width: 80px; left: -106.5px; right: -106.5px; top: 0px; "><div id="" class="app-contents">\par
  <div class="app-img-container launch-click-target" title="Gmail" style="height: 64px; width: 64px; ">\par
    <img class="" src="chrome://extension-icon/pjkljhegncpnkpknbcohdijeoejaedia/128/0">\par
  </div>\par
  <span class="title launch-click-target" title="Gmail">Gmail</span>\par
</div></div></div></div></div></div></div>\par
\f0     <button id="page-switcher-end" class="page-switcher custom-appearance" tabindex="2" style="width: 19.5px; right: 13px; top: 0px; padding-bottom: 0px; " hidden="">\'9b\f1\par
    </button>\par
    <div id="attribution" hidden="">\par
      <span i18n-content="attributionintro">Theme created by</span>\par
      <img id="attribution-img">\par
    </div>\par
  </div>\par
\par
  <div id="footer">\par
    <div id="footer-border"></div>\par
    <div id="footer-content">\par
      <img id="logo-img" src="chrome://theme/IDR_PRODUCT_LOGO?1455578975328">\par
\par
      <ul id="dot-list">\par
      <li class="dot" role="button" title="Most visited" tabindex="3"><div class="selection-bar"></div><input spellcheck="false" disabled=""></li><li class="dot selected" role="button" title="Apps"><div class="selection-bar"></div><input spellcheck="false" disabled=""></li></ul>\par
\par
      <button id="recently-closed-menu-button" class="custom-appearance" menu-shown="">\par
        <span i18n-content="recentlyclosed">Recently closed</span>\par
        <div class="disclosure-triangle"></div>\par
        <div id="vertical-separator"></div>\par
      </button>\par
\par
      <a id="chrome-web-store-href">\par
        <span id="chrome-web-store-title" i18n-content="webStoreTitle">Chrome Web Store</span>\par
      </a>\par
\par
      <div id="trash" class="trash">\par
        <span class="lid"></span>\par
        <span class="can"></span>\par
        <span class="trash-text" i18n-content="appuninstall">Remove from Chrome</span>\par
      </div>\par
    </div>\par
  </div>\par
\par
\par
<!-- A div to hold all the templates, and in the darkness bind them. -->\par
<div hidden="">\par
\par
<!-- NTP4 intro bubble -->\par
<div id="ntp4-intro-bubble-contents">\par
  <div i18n-content="ntp4_intro_message">undefined</div>\par
  <a i18n-content="learn_more" target="_blank">undefined</a>\par
</div>\par
\par
<!-- Login status bubble -->\par
<div id="login-status-bubble-contents">\par
  <div id="login-status-message-container">\par
    <span i18n-content="login_status_message">undefined</span>\par
    <a id="login-status-learn-more" i18n-content="login_status_learn_more" target="_blank">undefined</a>\par
  </div>\par
  <div class="login-status-row">\par
    <div id="login-status-advanced-container">\par
      <a id="login-status-advanced" i18n-content="login_status_advanced" href="#">undefined</a>\par
    </div>\par
    <button id="login-status-dismiss" i18n-content="login_status_dismiss">undefined</button>\par
  </div>\par
</div>\par
\par
<!-- Apps promo. -->\par
<div id="apps-promo-extras-template" class="apps-promo-extras">\par
  <h3 class="apps-promo-heading"></h3>\par
  <a class="apps-promo-link g-button-basic"></a>\par
</div>\par
\par
<!-- App Contents w/ Large Icon -->\par
<div id="app-large-icon-template" class="app-contents">\par
  <div class="app-img-container">\par
    <img class="invisible">\par
  </div>\par
  <span class="title"></span>\par
</div>\par
\par
<!-- App Contents w/ Small Icon -->\par
<div id="app-small-icon-template" class="app-contents">\par
  <div class="app-icon-div">\par
    <div class="app-img-container">\par
      <img class="invisible">\par
    </div>\par
    <div class="color-stripe"></div>\par
  </div>\par
  <span class="title"></span>\par
</div>\par
\par
</div>\par
\par
<!-- This is used to measure text in the current locale. It is not visible. -->\par
<div id="fontMeasuringDiv">Most visited</div>\par
\par
\par
<script>var templateData = \{"anim":"true","appDefaultPageName":"Apps","appcreateshortcut":"Create shortcut","appdisablenotifications":"Disable notifications","applaunchtypefullscreen":"Open full screen","applaunchtypepinned":"Open as pinned tab","applaunchtyperegular":"Open as regular tab","applaunchtypewindow":"Open as window","appoptions":"Options","apps_page_id":2048,"appuninstall":"Remove from Chrome","attributionintro":"Theme created by","bookmarkbarattached":"false","closedwindowmultiple":"$1 Tabs","closedwindowsingle":"1 Tab","customlogo":"false","fontfamily":"Arial, sans-serif","fontsize":"84%","hasattribution":"false","isWebStoreExperimentEnabled":false,"most_visited_page_id":1024,"mostvisited":"Most visited","recentlyclosed":"Recently closed","removethumbnailtooltip":"Don't show on this page","restoreThumbnailsShort":"Restore all","shown_page_index":0,"shown_page_type":2048,"syncLinkText":"Advanced settings","syncispresent":"true","syncpromotext":"Sign in to $1","textdirection":"ltr","themegravity":"","thumbnailremovednotification":"Thumbnail removed.","title":"New Tab","undothumbnailremove":"Undo","webStoreLink":"{{\field{\*\fldinst{HYPERLINK https://chrome.google.com/webstore?hl=en-US }}{\fldrslt{https://chrome.google.com/webstore?hl=en-US\ul0\cf0}}}}\f1\fs22 ","webStoreTitle":"Chrome Web Store"\};</script><script>// Copyright (c) 2010 The Chromium Authors. All rights reserved.\par
// Use of this source code is governed by a BSD-style license that can be\par
// found in the LICENSE file.\par
\par
/**\par
 * @fileoverview This is a simple template engine inspired by JsTemplates\par
 * optimized for i18n.\par
 *\par
 * It currently supports two handlers:\par
 *\par
 *   * i18n-content which sets the textContent of the element\par
 *\par
 *     <span i18n-content="myContent"></span>\par
 *     i18nTemplate.process(element, \{'myContent': 'Content'\});\par
 *\par
 *   * i18n-values is a list of attribute-value or property-value pairs.\par
 *     Properties are prefixed with a '.' and can contain nested properties.\par
 *\par
 *     <span i18n-values="title:myTitle;.style.fontSize:fontSize"></span>\par
 *     i18nTemplate.process(element, \{\par
 *       'myTitle': 'Title',\par
 *       'fontSize': '13px'\par
 *     \});\par
 */\par
\par
var i18nTemplate = (function() \{\par
  /**\par
   * This provides the handlers for the templating engine. The key is used as\par
   * the attribute name and the value is the function that gets called for every\par
   * single node that has this attribute.\par
   * @type \{Object\}\par
   */\par
  var handlers = \{\par
    /**\par
     * This handler sets the textContent of the element.\par
     */\par
    'i18n-content': function(element, attributeValue, obj) \{\par
      element.textContent = obj[attributeValue];\par
    \},\par
\par
    /**\par
     * This handler adds options to a select element.\par
     */\par
    'i18n-options': function(element, attributeValue, obj) \{\par
      var options = obj[attributeValue];\par
      options.forEach(function(values) \{\par
        var option = typeof values == 'string' ? new Option(values) :\par
            new Option(values[1], values[0]);\par
        element.appendChild(option);\par
      \});\par
    \},\par
\par
    /**\par
     * This is used to set HTML attributes and DOM properties,. The syntax is:\par
     *   attributename:key;\par
     *   .domProperty:key;\par
     *   .nested.dom.property:key\par
     */\par
    'i18n-values': function(element, attributeValue, obj) \{\par
      var parts = attributeValue.replace(/\\s/g, '').split(/;/);\par
      for (var j = 0; j < parts.length; j++) \{\par
        var a = parts[j].match(/^([^:]+):(.+)$/);\par
        if (a) \{\par
          var propName = a[1];\par
          var propExpr = a[2];\par
\par
          // Ignore missing properties\par
          if (propExpr in obj) \{\par
            var value = obj[propExpr];\par
            if (propName.charAt(0) == '.') \{\par
              var path = propName.slice(1).split('.');\par
              var object = element;\par
              while (object && path.length > 1) \{\par
                object = object[path.shift()];\par
              \}\par
              if (object) \{\par
                object[path] = value;\par
                // In case we set innerHTML (ignoring others) we need to\par
                // recursively check the content\par
                if (path == 'innerHTML') \{\par
                  process(element, obj);\par
                \}\par
              \}\par
            \} else \{\par
              element.setAttribute(propName, value);\par
            \}\par
          \} else \{\par
            console.warn('i18n-values: Missing value for "' + propExpr + '"');\par
          \}\par
        \}\par
      \}\par
    \}\par
  \};\par
\par
  var attributeNames = [];\par
  for (var key in handlers) \{\par
    attributeNames.push(key);\par
  \}\par
  var selector = '[' + attributeNames.join('],[') + ']';\par
\par
  /**\par
   * Processes a DOM tree with the \{@code obj\} map.\par
   */\par
  function process(node, obj) \{\par
    var elements = node.querySelectorAll(selector);\par
    for (var element, i = 0; element = elements[i]; i++) \{\par
      for (var j = 0; j < attributeNames.length; j++) \{\par
        var name = attributeNames[j];\par
        var att = element.getAttribute(name);\par
        if (att != null) \{\par
          handlers[name](element, att, obj);\par
        \}\par
      \}\par
    \}\par
  \}\par
\par
  return \{\par
    process: process\par
  \};\par
\})();\par
</script><script>// Copyright (c) 2010 The Chromium Authors. All rights reserved.\par
// Use of this source code is governed by a BSD-style license that can be\par
// found in the LICENSE file.\par
\par
// Invoke the template engine previously loaded from i18n_template.js\par
i18nTemplate.process(document, templateData);\par
</script><menu class="recent-menu" style="display: block; top: auto; left: auto; bottom: 49px; right: 0px; "><a class="recent-menu-item custom-appearance" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAkAAAAJCAYAAADgkQYQAAAAJUlEQVQYV2NgoDuYSQSGK/RB0+yDrACbQqwKkBUW41OArJB0AAACXws0ERupuAAAAABJRU5ErkJggg==" style="background-image: url(chrome://favicon/data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAkAAAAJCAYAAADgkQYQAAAAJUlEQVQYV2NgoDuYSQSGK/RB0+yDrACbQqwKkBUW41OArJB0AAACXws0ERupuAAAAABJRU5ErkJggg==); ">png (9\f0\'d79)</a><a class="recent-menu-item custom-appearance" href="chrome://theme/IDR_THEME_NTP_BACKGROUND?" style="background-image: url(chrome://favicon/chrome://theme/IDR_THEME_NTP_BACKGROUND?); ">IDR_THEME_NTP_BACKGROUND (42\'d742)</a><a class="recent-menu-item custom-appearance" href="chrome://theme/IDR_PRODUCT_LOGO?1455578975328" style="background-image: url(chrome://favicon/chrome://theme/IDR_PRODUCT_LOGO?1455578975328); ">IDR_PRODUCT_LOGO (171\'d732)</a><a class="recent-menu-item custom-appearance" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAQAAAC1+jfqAAAAiElEQVR42r2RsQrDMAxEBRdl8SDcX8lQPGg1GBI6lvz/h7QyRRXV0qUULwfvwZ1tenw5PxToRPWMC52eA9+WDnlh3HFQ/xBQl86NFYJqeGflkiogrOvVlIFhqURFVho3x1moGAa3deMs+LS30CAhBN5nNxeT5hbJ1zwmji2k+aF6NENIPf/hs54f0sZFUVAMigAAAABJRU5ErkJggg==" style="background-image: url(chrome://favicon/data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAQAAAC1+jfqAAAAiElEQVR42r2RsQrDMAxEBRdl8SDcX8lQPGg1GBI6lvz/h7QyRRXV0qUULwfvwZ1tenw5PxToRPWMC52eA9+WDnlh3HFQ/xBQl86NFYJqeGflkiogrOvVlIFhqURFVho3x1moGAa3deMs+LS30CAhBN5nNxeT5hbJ1zwmji2k+aF6NENIPf/hs54f0sZFUVAMigAAAABJRU5ErkJggg==); ">png (16\'d716)</a><a class="recent-menu-item custom-appearance" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAkAAAAJCAYAAADgkQYQAAAAJUlEQVQYV2NgoDuYSQSGK/RB0+yDrACbQqwKkBUW41OArJB0AAACXws0ERupuAAAAABJRU5ErkJggg==" style="background-image: url(chrome://favicon/data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAkAAAAJCAYAAADgkQYQAAAAJUlEQVQYV2NgoDuYSQSGK/RB0+yDrACbQqwKkBUW41OArJB0AAACXws0ERupuAAAAABJRU5ErkJggg==); ">png (9\'d79)</a><a class="recent-menu-item custom-appearance" href="chrome://theme/IDR_PRODUCT_LOGO?1455578975328" style="background-image: url(chrome://favicon/chrome://theme/IDR_PRODUCT_LOGO?1455578975328); ">IDR_PRODUCT_LOGO (171\'d732)</a><a class="recent-menu-item custom-appearance" href="chrome://extension-icon/blpcfgokakmgnkcojhhkbfbldkacnbeo/128/0" style="background-image: url(chrome://favicon/chrome://extension-icon/blpcfgokakmgnkcojhhkbfbldkacnbeo/128/0); ">0 (128\'d7128)</a><a class="recent-menu-item custom-appearance" href="chrome://theme/IDR_PRODUCT_LOGO?1455578975328" style="background-image: url(chrome://favicon/chrome://theme/IDR_PRODUCT_LOGO?1455578975328); ">IDR_PRODUCT_LOGO (171\'d732)</a><a class="recent-menu-item custom-appearance" href="{{\field{\*\fldinst{HYPERLINK https://www.google.co.th/?source=search_app&amp;gws_rd=cr,ssl&amp;ei=PV_CVr6ECtKUuATeqJngCA }}{\fldrslt{https://www.google.co.th/?source=search_app&amp;gws_rd=cr,ssl&amp;ei=PV_CVr6ECtKUuATeqJngCA\ul0\cf0}}}}\f0\fs22 " style="background-image: url(chrome://favicon/https://www.google.co.th/?source=search_app&amp;gws_rd=cr,ssl&amp;ei=PV_CVr6ECtKUuATeqJngCA); ">Google</a></menu></body>\par
<button id="login-container" class="custom-appearance" hidden="">\par
    <div id="login-status-header-container" class="login-status-row">\par
      <div id="login-status-header"></div>\par
    </div>\par
    <div id="login-status-sub-header"></div>\par
  </button>\par
<div id="notification-container" class="inactive" hidden="">\par
    <div id="notification">\par
      <span></span>\par
      <div id="notificationLinks"></div>\par
      <button class="close-button custom-appearance">\par
      </button>\par
    </div>\par
  </div>\par
<div id="card-slider-frame">\par
    <button id="page-switcher-start" class="page-switcher custom-appearance" tabindex="2" style="width: 32.5px; left: 0px; top: 0px; padding-bottom: 0px; ">\'8b\f1\par
    </button>\par
    <div id="page-list" style="-webkit-transform: translate3d(-485px, 0px, 0px); "><div class="tile-page most-visited-page animating-tile-page" style="width: 485px; " tabindex="-1"><div class="tile-page-scrollbar" style="top: 0px; height: 0px; "></div><div class="tile-page-content"><div class="top-margin" style="margin-bottom: 0px; margin-top: 0px; "></div><div class="tile-grid" style="min-width: 259.25px; min-height: 3px; height: 491.8679245283019px; "><div class="tile real" style="left: 128.25px; right: 128.25px; top: 0px; "><a class="most-visited real focusable" tabindex="-1" title="Welcome to Google Chrome" style="width: 122px; height: 107.71698113207547px; left: -108.375px; right: -108.375px; top: 0px; " id="most-visited-tile-110" href="{{\field{\*\fldinst{HYPERLINK http://www.google.com/chrome/intl/en/welcome.html }}{\fldrslt{http://www.google.com/chrome/intl/en/welcome.html\ul0\cf0}}}}\f1\fs22 "><span class="thumbnail-wrapper fills-parent"><div class="close-button" title="Don't show on this page"></div><span class="thumbnail fills-parent" style="background-image: url(chrome://thumb/http://www.google.com/chrome/intl/en/welcome.html); "><div class="thumbnail-shield fills-parent"></div></span><span class="favicon" style="background-image: url(chrome://favicon/size/16/http://www.google.com/chrome/intl/en/welcome.html); "></span></span><div class="color-stripe" style="background-color: rgb(0, 147, 60); "></div><span class="title" dir="ltr">Welcome to Google Chrome</span></a></div><div class="tile real" style="left: 265.5px; right: 265.5px; top: 0px; "><a class="most-visited real focusable" tabindex="-1" title="Chrome Web Store" style="width: 122px; height: 107.71698113207547px; left: -108.375px; right: -108.375px; top: 0px; " id="most-visited-tile-111" href="{{\field{\*\fldinst{HYPERLINK https://chrome.google.com/webstore?hl=en }}{\fldrslt{https://chrome.google.com/webstore?hl=en\ul0\cf0}}}}\f1\fs22 "><span class="thumbnail-wrapper fills-parent"><div class="close-button" title="Don't show on this page"></div><span class="thumbnail fills-parent" style="background-image: url(chrome://thumb/https://chrome.google.com/webstore?hl=en); "><div class="thumbnail-shield fills-parent"></div></span><span class="favicon" style="background-image: url(chrome://favicon/size/16/https://chrome.google.com/webstore?hl=en); "></span></span><div class="color-stripe" style="background-color: rgb(63, 132, 197); "></div><span class="title" dir="ltr">Chrome Web Store</span></a></div><div class="tile real" style="left: 128.25px; right: 128.25px; top: 122.96698113207547px; "><a class="most-visited filler real" tabindex="-1" title="" style="width: 122px; height: 107.71698113207547px; left: -108.375px; right: -108.375px; top: 0px; "><span class="thumbnail-wrapper fills-parent"><div class="close-button" title="Don't show on this page"></div><span class="thumbnail fills-parent"><div class="thumbnail-shield fills-parent"></div></span><span class="favicon"></span></span><div class="color-stripe"></div><span class="title"></span></a></div><div class="tile real" style="left: 265.5px; right: 265.5px; top: 122.96698113207547px; "><a class="most-visited filler real" tabindex="-1" title="" style="width: 122px; height: 107.71698113207547px; left: -108.375px; right: -108.375px; top: 0px; "><span class="thumbnail-wrapper fills-parent"><div class="close-button" title="Don't show on this page"></div><span class="thumbnail fills-parent"><div class="thumbnail-shield fills-parent"></div></span><span class="favicon"></span></span><div class="color-stripe"></div><span class="title"></span></a></div><div class="tile real" style="left: 128.25px; right: 128.25px; top: 245.93396226415095px; "><a class="most-visited filler real" tabindex="-1" title="" style="width: 122px; height: 107.71698113207547px; left: -108.375px; right: -108.375px; top: 0px; "><span class="thumbnail-wrapper fills-parent"><div class="close-button" title="Don't show on this page"></div><span class="thumbnail fills-parent"><div class="thumbnail-shield fills-parent"></div></span><span class="favicon"></span></span><div class="color-stripe"></div><span class="title"></span></a></div><div class="tile real" style="left: 265.5px; right: 265.5px; top: 245.93396226415095px; "><a class="most-visited filler real" tabindex="-1" title="" style="width: 122px; height: 107.71698113207547px; left: -108.375px; right: -108.375px; top: 0px; "><span class="thumbnail-wrapper fills-parent"><div class="close-button" title="Don't show on this page"></div><span class="thumbnail fills-parent"><div class="thumbnail-shield fills-parent"></div></span><span class="favicon"></span></span><div class="color-stripe"></div><span class="title"></span></a></div><div class="tile real" style="left: 128.25px; right: 128.25px; top: 368.9009433962264px; "><a class="most-visited filler real" tabindex="-1" title="" style="width: 122px; height: 107.71698113207547px; left: -108.375px; right: -108.375px; top: 0px; "><span class="thumbnail-wrapper fills-parent"><div class="close-button" title="Don't show on this page"></div><span class="thumbnail fills-parent"><div class="thumbnail-shield fills-parent"></div></span><span class="favicon"></span></span><div class="color-stripe"></div><span class="title"></span></a></div><div class="tile real" style="left: 265.5px; right: 265.5px; top: 368.9009433962264px; "><a class="most-visited filler real" tabindex="-1" title="" style="width: 122px; height: 107.71698113207547px; left: -108.375px; right: -108.375px; top: 0px; "><span class="thumbnail-wrapper fills-parent"><div class="close-button" title="Don't show on this page"></div><span class="thumbnail fills-parent"><div class="thumbnail-shield fills-parent"></div></span><span class="favicon"></span></span><div class="color-stripe"></div><span class="title"></span></a></div></div></div></div><div class="tile-page apps-page selected-card animating-tile-page" style="width: 485px; " tabindex="1"><div class="tile-page-scrollbar" style="top: 0px; height: 0px; "></div><div class="tile-page-content"><div class="top-margin" style="margin-bottom: 4.603773584905667px; margin-top: -4.603773584905667px; "></div><div class="tile-grid" style="min-width: 260px; min-height: 3px; height: 180px; "><div class="tile real" style="left: 126px; right: 126px; top: 0px; "><div id="ahfgeienlihckogmohjhadlkjgocpleb" class="app focusable webstore" style="height: 80px; width: 80px; left: -106.5px; right: -106.5px; top: 0px; "><div id="" class="app-contents">\par
  <div class="app-img-container launch-click-target" title="Chrome Web Store" style="height: 64px; width: 64px; ">\par
    <img class="" src="chrome://extension-icon/ahfgeienlihckogmohjhadlkjgocpleb/128/0">\par
  <img class="apps-promo-logo"></div>\par
  <span class="title launch-click-target" title="Chrome Web Store">Chrome Web Store</span>\par
</div><div id="" class="apps-promo-extras">\par
  <h3 class="apps-promo-heading"></h3>\par
  <a class="apps-promo-link g-button-basic"></a>\par
</div></div></div><div class="tile real" style="left: 216px; right: 216px; top: 0px; "><div id="blpcfgokakmgnkcojhhkbfbldkacnbeo" class="app focusable" style="height: 80px; width: 80px; left: -106.5px; right: -106.5px; top: 0px; "><div id="" class="app-contents">\par
  <div class="app-img-container launch-click-target" title="YouTube" style="height: 64px; width: 64px; ">\par
    <img class="" src="chrome://extension-icon/blpcfgokakmgnkcojhhkbfbldkacnbeo/128/0">\par
  </div>\par
  <span class="title launch-click-target" title="YouTube">YouTube</span>\par
</div></div></div><div class="tile real" style="left: 306px; right: 306px; top: 0px; "><div id="coobgpohoikkiipiblmjeljniedjpjpf" class="app focusable" style="height: 80px; width: 80px; left: -106.5px; right: -106.5px; top: 0px; "><div id="" class="app-contents">\par
  <div class="app-img-container launch-click-target" title="Google Search" style="height: 64px; width: 64px; ">\par
    <img class="" src="chrome://extension-icon/coobgpohoikkiipiblmjeljniedjpjpf/128/0">\par
  </div>\par
  <span class="title launch-click-target" title="Google Search">Google Search</span>\par
</div></div></div><div class="tile real" style="left: 126px; right: 126px; top: 90px; "><div id="pjkljhegncpnkpknbcohdijeoejaedia" class="app focusable" style="height: 80px; width: 80px; left: -106.5px; right: -106.5px; top: 0px; "><div id="" class="app-contents">\par
  <div class="app-img-container launch-click-target" title="Gmail" style="height: 64px; width: 64px; ">\par
    <img class="" src="chrome://extension-icon/pjkljhegncpnkpknbcohdijeoejaedia/128/0">\par
  </div>\par
  <span class="title launch-click-target" title="Gmail">Gmail</span>\par
</div></div></div></div></div></div></div>\par
\f0     <button id="page-switcher-end" class="page-switcher custom-appearance" tabindex="2" style="width: 19.5px; right: 13px; top: 0px; padding-bottom: 0px; " hidden="">\'9b\f1\par
    </button>\par
    <div id="attribution" hidden="">\par
      <span i18n-content="attributionintro">Theme created by</span>\par
      <img id="attribution-img">\par
    </div>\par
  </div>\par
<div id="footer">\par
    <div id="footer-border"></div>\par
    <div id="footer-content">\par
      <img id="logo-img" src="chrome://theme/IDR_PRODUCT_LOGO?1455578975328">\par
\par
      <ul id="dot-list">\par
      <li class="dot" role="button" title="Most visited" tabindex="3"><div class="selection-bar"></div><input spellcheck="false" disabled=""></li><li class="dot selected" role="button" title="Apps"><div class="selection-bar"></div><input spellcheck="false" disabled=""></li></ul>\par
\par
      <button id="recently-closed-menu-button" class="custom-appearance" menu-shown="">\par
        <span i18n-content="recentlyclosed">Recently closed</span>\par
        <div class="disclosure-triangle"></div>\par
        <div id="vertical-separator"></div>\par
      </button>\par
\par
      <a id="chrome-web-store-href">\par
        <span id="chrome-web-store-title" i18n-content="webStoreTitle">Chrome Web Store</span>\par
      </a>\par
\par
      <div id="trash" class="trash">\par
        <span class="lid"></span>\par
        <span class="can"></span>\par
        <span class="trash-text" i18n-content="appuninstall">Remove from Chrome</span>\par
      </div>\par
    </div>\par
  </div>\par
<!-- A div to hold all the templates, and in the darkness bind them. -->\par
<div hidden="">\par
\par
<!-- NTP4 intro bubble -->\par
<div id="ntp4-intro-bubble-contents">\par
  <div i18n-content="ntp4_intro_message">undefined</div>\par
  <a i18n-content="learn_more" target="_blank">undefined</a>\par
</div>\par
\par
<!-- Login status bubble -->\par
<div id="login-status-bubble-contents">\par
  <div id="login-status-message-container">\par
    <span i18n-content="login_status_message">undefined</span>\par
    <a id="login-status-learn-more" i18n-content="login_status_learn_more" target="_blank">undefined</a>\par
  </div>\par
  <div class="login-status-row">\par
    <div id="login-status-advanced-container">\par
      <a id="login-status-advanced" i18n-content="login_status_advanced" href="#">undefined</a>\par
    </div>\par
    <button id="login-status-dismiss" i18n-content="login_status_dismiss">undefined</button>\par
  </div>\par
</div>\par
\par
<!-- Apps promo. -->\par
<div id="apps-promo-extras-template" class="apps-promo-extras">\par
  <h3 class="apps-promo-heading"></h3>\par
  <a class="apps-promo-link g-button-basic"></a>\par
</div>\par
\par
<!-- App Contents w/ Large Icon -->\par
<div id="app-large-icon-template" class="app-contents">\par
  <div class="app-img-container">\par
    <img class="invisible">\par
  </div>\par
  <span class="title"></span>\par
</div>\par
\par
<!-- App Contents w/ Small Icon -->\par
<div id="app-small-icon-template" class="app-contents">\par
  <div class="app-icon-div">\par
    <div class="app-img-container">\par
      <img class="invisible">\par
    </div>\par
    <div class="color-stripe"></div>\par
  </div>\par
  <span class="title"></span>\par
</div>\par
\par
</div>\par
<!-- This is used to measure text in the current locale. It is not visible. -->\par
<div id="fontMeasuringDiv">Most visited</div>\par
<script>var templateData = \{"anim":"true","appDefaultPageName":"Apps","appcreateshortcut":"Create shortcut","appdisablenotifications":"Disable notifications","applaunchtypefullscreen":"Open full screen","applaunchtypepinned":"Open as pinned tab","applaunchtyperegular":"Open as regular tab","applaunchtypewindow":"Open as window","appoptions":"Options","apps_page_id":2048,"appuninstall":"Remove from Chrome","attributionintro":"Theme created by","bookmarkbarattached":"false","closedwindowmultiple":"$1 Tabs","closedwindowsingle":"1 Tab","customlogo":"false","fontfamily":"Arial, sans-serif","fontsize":"84%","hasattribution":"false","isWebStoreExperimentEnabled":false,"most_visited_page_id":1024,"mostvisited":"Most visited","recentlyclosed":"Recently closed","removethumbnailtooltip":"Don't show on this page","restoreThumbnailsShort":"Restore all","shown_page_index":0,"shown_page_type":2048,"syncLinkText":"Advanced settings","syncispresent":"true","syncpromotext":"Sign in to $1","textdirection":"ltr","themegravity":"","thumbnailremovednotification":"Thumbnail removed.","title":"New Tab","undothumbnailremove":"Undo","webStoreLink":"{{\field{\*\fldinst{HYPERLINK https://chrome.google.com/webstore?hl=en-US }}{\fldrslt{https://chrome.google.com/webstore?hl=en-US\ul0\cf0}}}}\f1\fs22 ","webStoreTitle":"Chrome Web Store"\};</script>\par
<script>// Copyright (c) 2010 The Chromium Authors. All rights reserved.\par
// Use of this source code is governed by a BSD-style license that can be\par
// found in the LICENSE file.\par
\par
/**\par
 * @fileoverview This is a simple template engine inspired by JsTemplates\par
 * optimized for i18n.\par
 *\par
 * It currently supports two handlers:\par
 *\par
 *   * i18n-content which sets the textContent of the element\par
 *\par
 *     <span i18n-content="myContent"></span>\par
 *     i18nTemplate.process(element, \{'myContent': 'Content'\});\par
 *\par
 *   * i18n-values is a list of attribute-value or property-value pairs.\par
 *     Properties are prefixed with a '.' and can contain nested properties.\par
 *\par
 *     <span i18n-values="title:myTitle;.style.fontSize:fontSize"></span>\par
 *     i18nTemplate.process(element, \{\par
 *       'myTitle': 'Title',\par
 *       'fontSize': '13px'\par
 *     \});\par
 */\par
\par
var i18nTemplate = (function() \{\par
  /**\par
   * This provides the handlers for the templating engine. The key is used as\par
   * the attribute name and the value is the function that gets called for every\par
   * single node that has this attribute.\par
   * @type \{Object\}\par
   */\par
  var handlers = \{\par
    /**\par
     * This handler sets the textContent of the element.\par
     */\par
    'i18n-content': function(element, attributeValue, obj) \{\par
      element.textContent = obj[attributeValue];\par
    \},\par
\par
    /**\par
     * This handler adds options to a select element.\par
     */\par
    'i18n-options': function(element, attributeValue, obj) \{\par
      var options = obj[attributeValue];\par
      options.forEach(function(values) \{\par
        var option = typeof values == 'string' ? new Option(values) :\par
            new Option(values[1], values[0]);\par
        element.appendChild(option);\par
      \});\par
    \},\par
\par
    /**\par
     * This is used to set HTML attributes and DOM properties,. The syntax is:\par
     *   attributename:key;\par
     *   .domProperty:key;\par
     *   .nested.dom.property:key\par
     */\par
    'i18n-values': function(element, attributeValue, obj) \{\par
      var parts = attributeValue.replace(/\\s/g, '').split(/;/);\par
      for (var j = 0; j < parts.length; j++) \{\par
        var a = parts[j].match(/^([^:]+):(.+)$/);\par
        if (a) \{\par
          var propName = a[1];\par
          var propExpr = a[2];\par
\par
          // Ignore missing properties\par
          if (propExpr in obj) \{\par
            var value = obj[propExpr];\par
            if (propName.charAt(0) == '.') \{\par
              var path = propName.slice(1).split('.');\par
              var object = element;\par
              while (object && path.length > 1) \{\par
                object = object[path.shift()];\par
              \}\par
              if (object) \{\par
                object[path] = value;\par
                // In case we set innerHTML (ignoring others) we need to\par
                // recursively check the content\par
                if (path == 'innerHTML') \{\par
                  process(element, obj);\par
                \}\par
              \}\par
            \} else \{\par
              element.setAttribute(propName, value);\par
            \}\par
          \} else \{\par
            console.warn('i18n-values: Missing value for "' + propExpr + '"');\par
          \}\par
        \}\par
      \}\par
    \}\par
  \};\par
\par
  var attributeNames = [];\par
  for (var key in handlers) \{\par
    attributeNames.push(key);\par
  \}\par
  var selector = '[' + attributeNames.join('],[') + ']';\par
\par
  /**\par
   * Processes a DOM tree with the \{@code obj\} map.\par
   */\par
  function process(node, obj) \{\par
    var elements = node.querySelectorAll(selector);\par
    for (var element, i = 0; element = elements[i]; i++) \{\par
      for (var j = 0; j < attributeNames.length; j++) \{\par
        var name = attributeNames[j];\par
        var att = element.getAttribute(name);\par
        if (att != null) \{\par
          handlers[name](element, att, obj);\par
        \}\par
      \}\par
    \}\par
  \}\par
\par
  return \{\par
    process: process\par
  \};\par
\})();\par
</script>\par
<script>// Copyright (c) 2010 The Chromium Authors. All rights reserved.\par
// Use of this source code is governed by a BSD-style license that can be\par
// found in the LICENSE file.\par
\par
// Invoke the template engine previously loaded from i18n_template.js\par
i18nTemplate.process(document, templateData);\par
</script>\par
<menu class="recent-menu" style="display: block; top: auto; left: auto; bottom: 49px; right: 0px; "><a class="recent-menu-item custom-appearance" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAkAAAAJCAYAAADgkQYQAAAAJUlEQVQYV2NgoDuYSQSGK/RB0+yDrACbQqwKkBUW41OArJB0AAACXws0ERupuAAAAABJRU5ErkJggg==" style="background-image: url(chrome://favicon/data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAkAAAAJCAYAAADgkQYQAAAAJUlEQVQYV2NgoDuYSQSGK/RB0+yDrACbQqwKkBUW41OArJB0AAACXws0ERupuAAAAABJRU5ErkJggg==); ">png (9\f0\'d79)</a><a class="recent-menu-item custom-appearance" href="chrome://theme/IDR_THEME_NTP_BACKGROUND?" style="background-image: url(chrome://favicon/chrome://theme/IDR_THEME_NTP_BACKGROUND?); ">IDR_THEME_NTP_BACKGROUND (42\'d742)</a><a class="recent-menu-item custom-appearance" href="chrome://theme/IDR_PRODUCT_LOGO?1455578975328" style="background-image: url(chrome://favicon/chrome://theme/IDR_PRODUCT_LOGO?1455578975328); ">IDR_PRODUCT_LOGO (171\'d732)</a><a class="recent-menu-item custom-appearance" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAQAAAC1+jfqAAAAiElEQVR42r2RsQrDMAxEBRdl8SDcX8lQPGg1GBI6lvz/h7QyRRXV0qUULwfvwZ1tenw5PxToRPWMC52eA9+WDnlh3HFQ/xBQl86NFYJqeGflkiogrOvVlIFhqURFVho3x1moGAa3deMs+LS30CAhBN5nNxeT5hbJ1zwmji2k+aF6NENIPf/hs54f0sZFUVAMigAAAABJRU5ErkJggg==" style="background-image: url(chrome://favicon/data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAQAAAC1+jfqAAAAiElEQVR42r2RsQrDMAxEBRdl8SDcX8lQPGg1GBI6lvz/h7QyRRXV0qUULwfvwZ1tenw5PxToRPWMC52eA9+WDnlh3HFQ/xBQl86NFYJqeGflkiogrOvVlIFhqURFVho3x1moGAa3deMs+LS30CAhBN5nNxeT5hbJ1zwmji2k+aF6NENIPf/hs54f0sZFUVAMigAAAABJRU5ErkJggg==); ">png (16\'d716)</a><a class="recent-menu-item custom-appearance" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAkAAAAJCAYAAADgkQYQAAAAJUlEQVQYV2NgoDuYSQSGK/RB0+yDrACbQqwKkBUW41OArJB0AAACXws0ERupuAAAAABJRU5ErkJggg==" style="background-image: url(chrome://favicon/data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAkAAAAJCAYAAADgkQYQAAAAJUlEQVQYV2NgoDuYSQSGK/RB0+yDrACbQqwKkBUW41OArJB0AAACXws0ERupuAAAAABJRU5ErkJggg==); ">png (9\'d79)</a><a class="recent-menu-item custom-appearance" href="chrome://theme/IDR_PRODUCT_LOGO?1455578975328" style="background-image: url(chrome://favicon/chrome://theme/IDR_PRODUCT_LOGO?1455578975328); ">IDR_PRODUCT_LOGO (171\'d732)</a><a class="recent-menu-item custom-appearance" href="chrome://extension-icon/blpcfgokakmgnkcojhhkbfbldkacnbeo/128/0" style="background-image: url(chrome://favicon/chrome://extension-icon/blpcfgokakmgnkcojhhkbfbldkacnbeo/128/0); ">0 (128\'d7128)</a><a class="recent-menu-item custom-appearance" href="chrome://theme/IDR_PRODUCT_LOGO?1455578975328" style="background-image: url(chrome://favicon/chrome://theme/IDR_PRODUCT_LOGO?1455578975328); ">IDR_PRODUCT_LOGO (171\'d732)</a><a class="recent-menu-item custom-appearance" href="{{\field{\*\fldinst{HYPERLINK https://www.google.co.th/?source=search_app&amp;gws_rd=cr,ssl&amp;ei=PV_CVr6ECtKUuATeqJngCA }}{\fldrslt{https://www.google.co.th/?source=search_app&amp;gws_rd=cr,ssl&amp;ei=PV_CVr6ECtKUuATeqJngCA\ul0\cf0}}}}\f0\fs22 " style="background-image: url(chrome://favicon/https://www.google.co.th/?source=search_app&amp;gws_rd=cr,ssl&amp;ei=PV_CVr6ECtKUuATeqJngCA); ">Google</a></menu>\par
<body>\par
  <button id="login-container" class="custom-appearance" hidden="">\par
    <div id="login-status-header-container" class="login-status-row">\par
      <div id="login-status-header"></div>\par
    </div>\par
    <div id="login-status-sub-header"></div>\par
  </button>\par
\par
  <div id="notification-container" class="inactive" hidden="">\par
    <div id="notification">\par
      <span></span>\par
      <div id="notificationLinks"></div>\par
      <button class="close-button custom-appearance">\par
      </button>\par
    </div>\par
  </div>\par
\par
  <div id="card-slider-frame">\par
    <button id="page-switcher-start" class="page-switcher custom-appearance" tabindex="2" style="width: 32.5px; left: 0px; top: 0px; padding-bottom: 0px; ">\f1\'8b\par
    </button>\par
    <div id="page-list" style="-webkit-transform: translate3d(-485px, 0px, 0px); "><div class="tile-page most-visited-page animating-tile-page" style="width: 485px; " tabindex="-1"><div class="tile-page-scrollbar" style="top: 0px; height: 0px; "></div><div class="tile-page-content"><div class="top-margin" style="margin-bottom: 0px; margin-top: 0px; "></div><div class="tile-grid" style="min-width: 259.25px; min-height: 3px; height: 491.8679245283019px; "><div class="tile real" style="left: 128.25px; right: 128.25px; top: 0px; "><a class="most-visited real focusable" tabindex="-1" title="Welcome to Google Chrome" style="width: 122px; height: 107.71698113207547px; left: -108.375px; right: -108.375px; top: 0px; " id="most-visited-tile-120" href="http://www.google.com/chrome/intl/en/welcome.html"><span class="thumbnail-wrapper fills-parent"><div class="close-button" title="Don't show on this page"></div><span class="thumbnail fills-parent" style="background-image: url(chrome://thumb/http://www.google.com/chrome/intl/en/welcome.html); "><div class="thumbnail-shield fills-parent"></div></span><span class="favicon" style="background-image: url(chrome://favicon/size/16/http://www.google.com/chrome/intl/en/welcome.html); "></span></span><div class="color-stripe" style="background-color: rgb(0, 147, 60); "></div><span class="title" dir="ltr">Welcome to Google Chrome</span></a></div><div class="tile real" style="left: 265.5px; right: 265.5px; top: 0px; "><a class="most-visited real focusable" tabindex="-1" title="Chrome Web Store" style="width: 122px; height: 107.71698113207547px; left: -108.375px; right: -108.375px; top: 0px; " id="most-visited-tile-121" href="https://chrome.google.com/webstore?hl=en"><span class="thumbnail-wrapper fills-parent"><div class="close-button" title="Don't show on this page"></div><span class="thumbnail fills-parent" style="background-image: url(chrome://thumb/https://chrome.google.com/webstore?hl=en); "><div class="thumbnail-shield fills-parent"></div></span><span class="favicon" style="background-image: url(chrome://favicon/size/16/https://chrome.google.com/webstore?hl=en); "></span></span><div class="color-stripe" style="background-color: rgb(63, 132, 197); "></div><span class="title" dir="ltr">Chrome Web Store</span></a></div><div class="tile real" style="left: 128.25px; right: 128.25px; top: 122.96698113207547px; "><a class="most-visited filler real" tabindex="-1" title="" style="width: 122px; height: 107.71698113207547px; left: -108.375px; right: -108.375px; top: 0px; "><span class="thumbnail-wrapper fills-parent"><div class="close-button" title="Don't show on this page"></div><span class="thumbnail fills-parent"><div class="thumbnail-shield fills-parent"></div></span><span class="favicon"></span></span><div class="color-stripe"></div><span class="title"></span></a></div><div class="tile real" style="left: 265.5px; right: 265.5px; top: 122.96698113207547px; "><a class="most-visited filler real" tabindex="-1" title="" style="width: 122px; height: 107.71698113207547px; left: -108.375px; right: -108.375px; top: 0px; "><span class="thumbnail-wrapper fills-parent"><div class="close-button" title="Don't show on this page"></div><span class="thumbnail fills-parent"><div class="thumbnail-shield fills-parent"></div></span><span class="favicon"></span></span><div class="color-stripe"></div><span class="title"></span></a></div><div class="tile real" style="left: 128.25px; right: 128.25px; top: 245.93396226415095px; "><a class="most-visited filler real" tabindex="-1" title="" style="width: 122px; height: 107.71698113207547px; left: -108.375px; right: -108.375px; top: 0px; "><span class="thumbnail-wrapper fills-parent"><div class="close-button" title="Don't show on this page"></div><span class="thumbnail fills-parent"><div class="thumbnail-shield fills-parent"></div></span><span class="favicon"></span></span><div class="color-stripe"></div><span class="title"></span></a></div><div class="tile real" style="left: 265.5px; right: 265.5px; top: 245.93396226415095px; "><a class="most-visited filler real" tabindex="-1" title="" style="width: 122px; height: 107.71698113207547px; left: -108.375px; right: -108.375px; top: 0px; "><span class="thumbnail-wrapper fills-parent"><div class="close-button" title="Don't show on this page"></div><span class="thumbnail fills-parent"><div class="thumbnail-shield fills-parent"></div></span><span class="favicon"></span></span><div class="color-stripe"></div><span class="title"></span></a></div><div class="tile real" style="left: 128.25px; right: 128.25px; top: 368.9009433962264px; "><a class="most-visited filler real" tabindex="-1" title="" style="width: 122px; height: 107.71698113207547px; left: -108.375px; right: -108.375px; top: 0px; "><span class="thumbnail-wrapper fills-parent"><div class="close-button" title="Don't show on this page"></div><span class="thumbnail fills-parent"><div class="thumbnail-shield fills-parent"></div></span><span class="favicon"></span></span><div class="color-stripe"></div><span class="title"></span></a></div><div class="tile real" style="left: 265.5px; right: 265.5px; top: 368.9009433962264px; "><a class="most-visited filler real" tabindex="-1" title="" style="width: 122px; height: 107.71698113207547px; left: -108.375px; right: -108.375px; top: 0px; "><span class="thumbnail-wrapper fills-parent"><div class="close-button" title="Don't show on this page"></div><span class="thumbnail fills-parent"><div class="thumbnail-shield fills-parent"></div></span><span class="favicon"></span></span><div class="color-stripe"></div><span class="title"></span></a></div></div></div></div><div class="tile-page apps-page selected-card animating-tile-page" style="width: 485px; " tabindex="1"><div class="tile-page-scrollbar" style="top: 0px; height: 0px; "></div><div class="tile-page-content"><div class="top-margin" style="margin-bottom: 4.603773584905667px; margin-top: -4.603773584905667px; "></div><div class="tile-grid" style="min-width: 260px; min-height: 3px; height: 180px; "><div class="tile real" style="left: 126px; right: 126px; top: 0px; "><div id="ahfgeienlihckogmohjhadlkjgocpleb" class="app focusable webstore" style="height: 80px; width: 80px; left: -106.5px; right: -106.5px; top: 0px; "><div id="" class="app-contents">\par
  <div class="app-img-container launch-click-target" title="Chrome Web Store" style="height: 64px; width: 64px; ">\par
    <img class="" src="chrome://extension-icon/ahfgeienlihckogmohjhadlkjgocpleb/128/0">\par
  <img class="apps-promo-logo"></div>\par
  <span class="title launch-click-target" title="Chrome Web Store">Chrome Web Store</span>\par
</div><div id="" class="apps-promo-extras">\par
  <h3 class="apps-promo-heading"></h3>\par
  <a class="apps-promo-link g-button-basic"></a>\par
</div></div></div><div class="tile real" style="left: 216px; right: 216px; top: 0px; "><div id="blpcfgokakmgnkcojhhkbfbldkacnbeo" class="app focusable" style="height: 80px; width: 80px; left: -106.5px; right: -106.5px; top: 0px; "><div id="" class="app-contents">\par
  <div class="app-img-container launch-click-target" title="YouTube" style="height: 64px; width: 64px; ">\par
    <img class="" src="chrome://extension-icon/blpcfgokakmgnkcojhhkbfbldkacnbeo/128/0">\par
  </div>\par
  <span class="title launch-click-target" title="YouTube">YouTube</span>\par
</div></div></div><div class="tile real" style="left: 306px; right: 306px; top: 0px; "><div id="coobgpohoikkiipiblmjeljniedjpjpf" class="app focusable" style="height: 80px; width: 80px; left: -106.5px; right: -106.5px; top: 0px; "><div id="" class="app-contents">\par
  <div class="app-img-container launch-click-target" title="Google Search" style="height: 64px; width: 64px; ">\par
    <img class="" src="chrome://extension-icon/coobgpohoikkiipiblmjeljniedjpjpf/128/0">\par
  </div>\par
  <span class="title launch-click-target" title="Google Search">Google Search</span>\par
</div></div></div><div class="tile real" style="left: 126px; right: 126px; top: 90px; "><div id="pjkljhegncpnkpknbcohdijeoejaedia" class="app focusable" style="height: 80px; width: 80px; left: -106.5px; right: -106.5px; top: 0px; "><div id="" class="app-contents">\par
  <div class="app-img-container launch-click-target" title="Gmail" style="height: 64px; width: 64px; ">\par
    <img class="" src="chrome://extension-icon/pjkljhegncpnkpknbcohdijeoejaedia/128/0">\par
  </div>\par
  <span class="title launch-click-target" title="Gmail">Gmail</span>\par
</div></div></div></div></div></div></div>\par
    <button id="page-switcher-end" class="page-switcher custom-appearance" tabindex="2" style="width: 19.5px; right: 13px; top: 0px; padding-bottom: 0px; " hidden="">\'9b\par
    </button>\par
    <div id="attribution" hidden="">\par
      <span i18n-content="attributionintro">Theme created by</span>\par
      <img id="attribution-img">\par
    </div>\par
  </div>\par
\par
  <div id="footer">\par
    <div id="footer-border"></div>\par
    <div id="footer-content">\par
      <img id="logo-img" src="chrome://theme/IDR_PRODUCT_LOGO?1455578975328">\par
\par
      <ul id="dot-list">\par
      <li class="dot" role="button" title="Most visited" tabindex="3"><div class="selection-bar"></div><input spellcheck="false" disabled=""></li><li class="dot selected" role="button" title="Apps"><div class="selection-bar"></div><input spellcheck="false" disabled=""></li></ul>\par
\par
      <button id="recently-closed-menu-button" class="custom-appearance">\par
        <span i18n-content="recentlyclosed">Recently closed</span>\par
        <div class="disclosure-triangle"></div>\par
        <div id="vertical-separator"></div>\par
      </button>\par
\par
      <a id="chrome-web-store-href">\par
        <span id="chrome-web-store-title" i18n-content="webStoreTitle">Chrome Web Store</span>\par
      </a>\par
\par
      <div id="trash" class="trash">\par
        <span class="lid"></span>\par
        <span class="can"></span>\par
        <span class="trash-text" i18n-content="appuninstall">Remove from Chrome</span>\par
      </div>\par
    </div>\par
  </div>\par
\par
\par
<!-- A div to hold all the templates, and in the darkness bind them. -->\par
<div hidden="">\par
\par
<!-- NTP4 intro bubble -->\par
<div id="ntp4-intro-bubble-contents">\par
  <div i18n-content="ntp4_intro_message">undefined</div>\par
  <a i18n-content="learn_more" target="_blank">undefined</a>\par
</div>\par
\par
<!-- Login status bubble -->\par
<div id="login-status-bubble-contents">\par
  <div id="login-status-message-container">\par
    <span i18n-content="login_status_message">undefined</span>\par
    <a id="login-status-learn-more" i18n-content="login_status_learn_more" target="_blank">undefined</a>\par
  </div>\par
  <div class="login-status-row">\par
    <div id="login-status-advanced-container">\par
      <a id="login-status-advanced" i18n-content="login_status_advanced" href="#">undefined</a>\par
    </div>\par
    <button id="login-status-dismiss" i18n-content="login_status_dismiss">undefined</button>\par
  </div>\par
</div>\par
\par
<!-- Apps promo. -->\par
<div id="apps-promo-extras-template" class="apps-promo-extras">\par
  <h3 class="apps-promo-heading"></h3>\par
  <a class="apps-promo-link g-button-basic"></a>\par
</div>\par
\par
<!-- App Contents w/ Large Icon -->\par
<div id="app-large-icon-template" class="app-contents">\par
  <div class="app-img-container">\par
    <img class="invisible">\par
  </div>\par
  <span class="title"></span>\par
</div>\par
\par
<!-- App Contents w/ Small Icon -->\par
<div id="app-small-icon-template" class="app-contents">\par
  <div class="app-icon-div">\par
    <div class="app-img-container">\par
      <img class="invisible">\par
    </div>\par
    <div class="color-stripe"></div>\par
  </div>\par
  <span class="title"></span>\par
</div>\par
\par
</div>\par
\par
<!-- This is used to measure text in the current locale. It is not visible. -->\par
<div id="fontMeasuringDiv">Most visited</div>\par
\par
\par
<script>var templateData = \{"anim":"true","appDefaultPageName":"Apps","appcreateshortcut":"Create shortcut","appdisablenotifications":"Disable notifications","applaunchtypefullscreen":"Open full screen","applaunchtypepinned":"Open as pinned tab","applaunchtyperegular":"Open as regular tab","applaunchtypewindow":"Open as window","appoptions":"Options","apps_page_id":2048,"appuninstall":"Remove from Chrome","attributionintro":"Theme created by","bookmarkbarattached":"false","closedwindowmultiple":"$1 Tabs","closedwindowsingle":"1 Tab","customlogo":"false","fontfamily":"Arial, sans-serif","fontsize":"84%","hasattribution":"false","isWebStoreExperimentEnabled":false,"most_visited_page_id":1024,"mostvisited":"Most visited","recentlyclosed":"Recently closed","removethumbnailtooltip":"Don't show on this page","restoreThumbnailsShort":"Restore all","shown_page_index":0,"shown_page_type":2048,"syncLinkText":"Advanced settings","syncispresent":"true","syncpromotext":"Sign in to $1","textdirection":"ltr","themegravity":"","thumbnailremovednotification":"Thumbnail removed.","title":"New Tab","undothumbnailremove":"Undo","webStoreLink":"https://chrome.google.com/webstore?hl=en-US","webStoreTitle":"Chrome Web Store"\};</script><script>// Copyright (c) 2010 The Chromium Authors. All rights reserved.\par
// Use of this source code is governed by a BSD-style license that can be\par
// found in the LICENSE file.\par
\par
/**\par
 * @fileoverview This is a simple template engine inspired by JsTemplates\par
 * optimized for i18n.\par
 *\par
 * It currently supports two handlers:\par
 *\par
 *   * i18n-content which sets the textContent of the element\par
 *\par
 *     <span i18n-content="myContent"></span>\par
 *     i18nTemplate.process(element, \{'myContent': 'Content'\});\par
 *\par
 *   * i18n-values is a list of attribute-value or property-value pairs.\par
 *     Properties are prefixed with a '.' and can contain nested properties.\par
 *\par
 *     <span i18n-values="title:myTitle;.style.fontSize:fontSize"></span>\par
 *     i18nTemplate.process(element, \{\par
 *       'myTitle': 'Title',\par
 *       'fontSize': '13px'\par
 *     \});\par
 */\par
\par
var i18nTemplate = (function() \{\par
  /**\par
   * This provides the handlers for the templating engine. The key is used as\par
   * the attribute name and the value is the function that gets called for every\par
   * single node that has this attribute.\par
   * @type \{Object\}\par
   */\par
  var handlers = \{\par
    /**\par
     * This handler sets the textContent of the element.\par
     */\par
    'i18n-content': function(element, attributeValue, obj) \{\par
      element.textContent = obj[attributeValue];\par
    \},\par
\par
    /**\par
     * This handler adds options to a select element.\par
     */\par
    'i18n-options': function(element, attributeValue, obj) \{\par
      var options = obj[attributeValue];\par
      options.forEach(function(values) \{\par
        var option = typeof values == 'string' ? new Option(values) :\par
            new Option(values[1], values[0]);\par
        element.appendChild(option);\par
      \});\par
    \},\par
\par
    /**\par
     * This is used to set HTML attributes and DOM properties,. The syntax is:\par
     *   attributename:key;\par
     *   .domProperty:key;\par
     *   .nested.dom.property:key\par
     */\par
    'i18n-values': function(element, attributeValue, obj) \{\par
      var parts = attributeValue.replace(/\\s/g, '').split(/;/);\par
      for (var j = 0; j < parts.length; j++) \{\par
        var a = parts[j].match(/^([^:]+):(.+)$/);\par
        if (a) \{\par
          var propName = a[1];\par
          var propExpr = a[2];\par
\par
          // Ignore missing properties\par
          if (propExpr in obj) \{\par
            var value = obj[propExpr];\par
            if (propName.charAt(0) == '.') \{\par
              var path = propName.slice(1).split('.');\par
              var object = element;\par
              while (object && path.length > 1) \{\par
                object = object[path.shift()];\par
              \}\par
              if (object) \{\par
                object[path] = value;\par
                // In case we set innerHTML (ignoring others) we need to\par
                // recursively check the content\par
                if (path == 'innerHTML') \{\par
                  process(element, obj);\par
                \}\par
              \}\par
            \} else \{\par
              element.setAttribute(propName, value);\par
            \}\par
          \} else \{\par
            console.warn('i18n-values: Missing value for "' + propExpr + '"');\par
          \}\par
        \}\par
      \}\par
    \}\par
  \};\par
\par
  var attributeNames = [];\par
  for (var key in handlers) \{\par
    attributeNames.push(key);\par
  \}\par
  var selector = '[' + attributeNames.join('],[') + ']';\par
\par
  /**\par
   * Processes a DOM tree with the \{@code obj\} map.\par
   */\par
  function process(node, obj) \{\par
    var elements = node.querySelectorAll(selector);\par
    for (var element, i = 0; element = elements[i]; i++) \{\par
      for (var j = 0; j < attributeNames.length; j++) \{\par
        var name = attributeNames[j];\par
        var att = element.getAttribute(name);\par
        if (att != null) \{\par
          handlers[name](element, att, obj);\par
        \}\par
      \}\par
    \}\par
  \}\par
\par
  return \{\par
    process: process\par
  \};\par
\})();\par
</script><script>// Copyright (c) 2010 The Chromium Authors. All rights reserved.\par
// Use of this source code is governed by a BSD-style license that can be\par
// found in the LICENSE file.\par
\par
// Invoke the template engine previously loaded from i18n_template.js\par
i18nTemplate.process(document, templateData);\par
</script><menu class="recent-menu" style="top: auto; left: auto; bottom: 49px; right: 0px; display: none; "><a class="recent-menu-item custom-appearance" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAkAAAAJCAYAAADgkQYQAAAAJUlEQVQYV2NgoDuYSQSGK/RB0+yDrACbQqwKkBUW41OArJB0AAACXws0ERupuAAAAABJRU5ErkJggg==" style="background-image: url(chrome://favicon/data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAkAAAAJCAYAAADgkQYQAAAAJUlEQVQYV2NgoDuYSQSGK/RB0+yDrACbQqwKkBUW41OArJB0AAACXws0ERupuAAAAABJRU5ErkJggg==); ">png (9\f0\'d79)</a><a class="recent-menu-item custom-appearance" href="chrome://theme/IDR_THEME_NTP_BACKGROUND?" style="background-image: url(chrome://favicon/chrome://theme/IDR_THEME_NTP_BACKGROUND?); ">IDR_THEME_NTP_BACKGROUND (42\'d742)</a><a class="recent-menu-item custom-appearance" href="chrome://theme/IDR_PRODUCT_LOGO?1455578975328" style="background-image: url(chrome://favicon/chrome://theme/IDR_PRODUCT_LOGO?1455578975328); ">IDR_PRODUCT_LOGO (171\'d732)</a><a class="recent-menu-item custom-appearance" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAQAAAC1+jfqAAAAiElEQVR42r2RsQrDMAxEBRdl8SDcX8lQPGg1GBI6lvz/h7QyRRXV0qUULwfvwZ1tenw5PxToRPWMC52eA9+WDnlh3HFQ/xBQl86NFYJqeGflkiogrOvVlIFhqURFVho3x1moGAa3deMs+LS30CAhBN5nNxeT5hbJ1zwmji2k+aF6NENIPf/hs54f0sZFUVAMigAAAABJRU5ErkJggg==" style="background-image: url(chrome://favicon/data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAQAAAC1+jfqAAAAiElEQVR42r2RsQrDMAxEBRdl8SDcX8lQPGg1GBI6lvz/h7QyRRXV0qUULwfvwZ1tenw5PxToRPWMC52eA9+WDnlh3HFQ/xBQl86NFYJqeGflkiogrOvVlIFhqURFVho3x1moGAa3deMs+LS30CAhBN5nNxeT5hbJ1zwmji2k+aF6NENIPf/hs54f0sZFUVAMigAAAABJRU5ErkJggg==); ">png (16\'d716)</a><a class="recent-menu-item custom-appearance" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAkAAAAJCAYAAADgkQYQAAAAJUlEQVQYV2NgoDuYSQSGK/RB0+yDrACbQqwKkBUW41OArJB0AAACXws0ERupuAAAAABJRU5ErkJggg==" style="background-image: url(chrome://favicon/data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAkAAAAJCAYAAADgkQYQAAAAJUlEQVQYV2NgoDuYSQSGK/RB0+yDrACbQqwKkBUW41OArJB0AAACXws0ERupuAAAAABJRU5ErkJggg==); ">png (9\'d79)</a><a class="recent-menu-item custom-appearance" href="chrome://theme/IDR_PRODUCT_LOGO?1455578975328" style="background-image: url(chrome://favicon/chrome://theme/IDR_PRODUCT_LOGO?1455578975328); ">IDR_PRODUCT_LOGO (171\'d732)</a><a class="recent-menu-item custom-appearance" href="chrome://extension-icon/blpcfgokakmgnkcojhhkbfbldkacnbeo/128/0" style="background-image: url(chrome://favicon/chrome://extension-icon/blpcfgokakmgnkcojhhkbfbldkacnbeo/128/0); ">0 (128\'d7128)</a><a class="recent-menu-item custom-appearance" href="chrome://theme/IDR_PRODUCT_LOGO?1455578975328" style="background-image: url(chrome://favicon/chrome://theme/IDR_PRODUCT_LOGO?1455578975328); ">IDR_PRODUCT_LOGO (171\'d732)</a><a class="recent-menu-item custom-appearance" href="https://www.google.co.th/?source=search_app&amp;gws_rd=cr,ssl&amp;ei=PV_CVr6ECtKUuATeqJngCA" style="background-image: url(chrome://favicon/https://www.google.co.th/?source=search_app&amp;gws_rd=cr,ssl&amp;ei=PV_CVr6ECtKUuATeqJngCA); ">Google</a></menu></body>\par
<html i18n-values="\par
    dir:textdirection;\par
    hasattribution:hasattribution;\par
    customlogo:customlogo;\par
    themegravity:themegravity;" class="" dir="ltr" hasattribution="false" customlogo="false" themegravity="" os="windows" toolkit="views"><head>\par
<meta charset="utf-8">\par
<title i18n-content="title">New Tab</title>\par
<!-- Don't scale the viewport in either portrait or landscape mode.\par
     Note that this means apps will be reflowed when rotated (like iPad).\par
     If we wanted to maintain position we could remove 'maximum-scale' so\par
     that we'd zoom out in portrait mode, but then there would be a bunch\par
     of unusable space at the bottom.\par
-->\par
<meta name="viewport" content="user-scalable=no, width=device-width, maximum-scale=1.0">\par
\par
<!-- It's important that this be the first script loaded. -->\par
<script>// Copyright (c) 2011 The Chromium Authors. All rights reserved.\par
// Use of this source code is governed by a BSD-style license that can be\par
// found in the LICENSE file.\par
\par
/**\par
 * @fileOverview\par
 * Logging info for benchmarking purposes. Should be the first js file included.\par
 */\par
\par
/* Stack of events that has been logged. */\par
var eventLog = [];\par
\par
/**\par
 * Logs an event.\par
 * @param \{String\} name The name of the event (can be any string).\par
 * @param \{boolean\} shouldLogTime If true, the event is used for benchmarking\par
 *     and the time is logged. Otherwise, just push the event on the event\par
 *     stack.\par
 */\par
function logEvent(name, shouldLogTime) \{\par
  if (shouldLogTime)\par
    chrome.send('metricsHandler:logEventTime', [name]);\par
  eventLog.push([name, Date.now()]);\par
\}\par
\par
logEvent('Tab.NewTabScriptStart', true);\par
window.addEventListener('load', function(e) \{\par
  logEvent('Tab.NewTabOnload', true);\par
\});\par
document.addEventListener('DOMContentLoaded', function(e) \{\par
  logEvent('Tab.NewTabDOMContentLoaded', true);\par
\});\par
</script>\par
\par
<style>/* Copyright (c) 2012 The Chromium Authors. All rights reserved.\par
 * Use of this source code is governed by a BSD-style license that can be\par
 * found in the LICENSE file.\par
 */\par
\par
button:not(.custom-appearance),\par
input[type='button']:not(.custom-appearance),\par
input[type='submit']:not(.custom-appearance) \{\par
  -webkit-border-radius: 3px;\par
  -webkit-box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);\par
  -webkit-user-select: none;\par
  background: -webkit-linear-gradient(#fafafa, #f4f4f4 40%, #e5e5e5);\par
  border: 1px solid #aaa;\par
  color: #444;\par
  font-size: inherit;\par
  margin-bottom: 0;\par
  min-width: 4em;\par
  padding: 3px 12px;\par
\}\par
\par
button:not(.custom-appearance):hover,\par
input[type='button']:not(.custom-appearance):hover,\par
input[type='submit']:not(.custom-appearance):hover \{\par
  -webkit-box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2);\par
  background: #ebebeb -webkit-linear-gradient(#fefefe, #f8f8f8 40%, #e9e9e9);\par
  border-color: #999;\par
  color: #222;\par
\}\par
\par
button:not(.custom-appearance):active,\par
input[type='button']:not(.custom-appearance):active,\par
input[type='submit']:not(.custom-appearance):active \{\par
  -webkit-box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.2);\par
  background: #ebebeb -webkit-linear-gradient(#f4f4f4, #efefef 40%, #dcdcdc);\par
  color: #333;\par
\}\par
\par
button[disabled]:not(.custom-appearance),\par
input[type='button'][disabled]:not(.custom-appearance),\par
input[type='submit'][disabled]:not(.custom-appearance),\par
button[disabled]:not(.custom-appearance):hover,\par
input[type='button'][disabled]:not(.custom-appearance):hover,\par
input[type='submit'][disabled]:not(.custom-appearance):hover \{\par
  -webkit-box-shadow: none;\par
  background: -webkit-linear-gradient(#fafafa, #f4f4f4 40%, #e5e5e5);\par
  border-color: #aaa;\par
  color: #888;\par
\}\par
\par
button:not(.custom-appearance):focus,\par
input[type='submit']:not(.custom-appearance):focus,\par
input[type='text']:not(.custom-appearance):focus,\par
select:not(.custom-appearance):focus \{\par
  -webkit-box-shadow: inset 0 1px 2px white,\par
      0 1px 2px rgba(0, 0, 0, .2),\par
      0 0 1px #c0c0c0,\par
      0 0 1px #c0c0c0,\par
      0 0 1px #c0c0c0;\par
  -webkit-transition: border-color 200ms;\par
  /* We use border color because it follows the border radius (unlike outline).\par
   * This is particularly noticeable on mac. */\par
  border-color: rgb(64, 128, 250);\par
  outline: none;\par
\}\par
\par
/* Search boxes use an outline because it follows the contours of the box. */\par
input[type='search']:not(.custom-appearance):focus \{\par
  outline-color: rgb(64, 128, 250);\par
\}\par
\par
/* TODO(jhawkins): Refactor button styling and remove !important here. This is\par
 * currently necessary because individual page button element selectors have\par
 * higher specificity.\par
 */\par
.link-button,\par
.link-button:focus \{\par
  -webkit-box-shadow: none !important;\par
  background: transparent none !important;\par
  border: none !important;\par
  color: rgb(17, 85, 204) !important;\par
  cursor: pointer;\par
  /* Input elements have -webkit-small-control which overrides the body font.\par
   * Resolve this by using 'inherit'. */\par
  font-family: inherit;\par
  margin: 0;\par
  padding: 0 4px !important;\par
\}\par
\par
.link-button:hover \{\par
  text-decoration: underline;\par
\}\par
\par
.link-button:active \{\par
  color: rgb(5, 37, 119) !important;\par
  text-decoration: underline;\par
\}\par
</style>\par
<style>/* Copyright (c) 2012 The Chromium Authors. All rights reserved.\par
 * Use of this source code is governed by a BSD-style license that can be\par
 * found in the LICENSE file.\par
 */\par
\par
.bubble \{\par
  position: absolute;\par
  /* Height is dynamic, width fixed. */\par
  width: 300px;\par
  z-index: 9999;\par
\}\par
\par
.bubble-contents \{\par
  color: black;\par
  left: 1px;\par
  line-height: 150%;\par
  padding: 8px 11px 12px;\par
  position: relative;\par
  right: 1px;\par
  top: 1px;\par
  width: 298px;\par
  z-index: 3;\par
\}\par
\par
.bubble-close \{\par
  background-image: no-repeat 50% 50%;  \par
  height: 16px;\par
  position: absolute;\par
  right: 6px;\par
  top: 6px;\par
  width: 16px;\par
  z-index: 4;\par
\}\par
\par
html[dir='rtl'] .bubble-close \{\par
  left: 6px;\par
  right: auto;\par
\}\par
\par
.bubble-close \{\par
  background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAQAAAC1+jfqAAAAiElEQVR42r2RsQrDMAxEBRdl8SDcX8lQPGg1GBI6lvz/h7QyRRXV0qUULwfvwZ1tenw5PxToRPWMC52eA9+WDnlh3HFQ/xBQl86NFYJqeGflkiogrOvVlIFhqURFVho3x1moGAa3deMs+LS30CAhBN5nNxeT5hbJ1zwmji2k+aF6NENIPf/hs54f0sZFUVAMigAAAABJRU5ErkJggg==");\par
\}\par
\par
.bubble-close:hover \{\par
  background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAQAAAC1+jfqAAAAqklEQVR4XqWRMQ6DMAxF/1Fyilyj2SmIBUG5QcTCyJA5Z8jGhlBPgRi4TmoDraVmKFJlWYrlp/g5QfwRlwEVNWVa4WzfH9jK6kCkEkBjwxOhLghheMWMELUAqqwQ4OCbnE4LJnhr5IYdqQt4DJQjhe9u4vBBmnxHHNzRFkDGjHDo0VuTAqy2vAG4NkvXXDHxbGsIGlj3e835VFNtdugma/Jk0eXq0lP//5svi4PtO01oFfYAAAAASUVORK5CYII=");\par
\}\par
\par
.bubble-close:active \{\par
  background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAQAAAC1+jfqAAAARElEQVQoz2P4z4AfMlBLAYMdwxkghgEwD1XBGTC0g0sDIaYJECVwFqoChBK4WegKkJWArSJZAQErCDqSKG/iCyhaRhYA9LDIbULDzlIAAAAASUVORK5CYII=");\par
\}\par
\par
.bubble-shadow \{\par
  bottom: -2px;\par
  left: 0;\par
  position: absolute;\par
  right: 0;\par
  top: 0;\par
  z-index: 1;\par
\}\par
\par
.bubble-arrow \{\par
  /* The tip of the arrow.  */\par
  border-bottom-right-radius: 1px;\par
  /* No border on the right or top (inner sides of the rotated square) because\par
   * it would overlap/darken the content shadow. */\par
  border-right: none;\par
  border-top: none;\par
  bottom: -9px;\par
  height: 15px;\par
  left: 22px;\par
  position: absolute;\par
  right: 22px;\par
  width: 15px;\par
  z-index: 2;\par
  -webkit-transform: rotate(45deg);\par
\}\par
\par
.bubble-contents,\par
.bubble-arrow \{\par
  background: white;\par
\}\par
\par
.bubble-arrow[is-right='true'] \{\par
  left: auto;\par
\}\par
\par
.bubble-arrow[is-right='false'] \{\par
  right: auto;\par
\}\par
\par
.bubble-arrow[is-top='true'] \{\par
  bottom: auto;\par
  top: -8px;\par
\}\par
\par
.bubble-shadow,\par
.bubble-arrow \{\par
  border: 1px solid rgba(0, 0, 0, 0.3);\par
  -webkit-box-shadow: 0 2px 6px rgba(0, 0, 0, 0.15);\par
\}\par
\par
.bubble-shadow,\par
.bubble-contents \{\par
  border-radius: 6px;\par
  box-sizing: border-box;\par
\}\par
</style>\par
<style>/* Copyright (c) 2012 The Chromium Authors. All rights reserved.\par
 * Use of this source code is governed by a BSD-style license that can be\par
 * found in the LICENSE file.\par
 */\par
\par
.expandable-bubble \{\par
  -webkit-border-image: url('chrome://theme/IDR_APP_NOTIFICATION_SMALL_BUBBLE')\par
                        5 5 7 6 stretch;\par
  -webkit-box-sizing: border-box;\par
  -webkit-user-select: none;\par
  border-width: 5px 5px 7px 6px;\par
  color: #444;\par
  cursor: pointer;\par
  display: inline-block;\par
  font-size: 12px;\par
  position: absolute;\par
  z-index: 1;\par
\}\par
\par
.expandable-bubble::after \{\par
  bottom: -1px;\par
  content: url('chrome://theme/IDR_APP_NOTIFICATION_NUB');\par
  display: block;\par
  height: 7px;\par
  position: absolute;\par
  right: 5px;  /* TODO(finnur): Need to handle RTL properly. */\par
  width: 9px;\par
\}\par
\par
.expandable-bubble > .expandable-bubble-contents > .expandable-bubble-title \{\par
  display: inline-block;\par
  margin-left: 1px;\par
  margin-top : -3px;\par
  overflow: hidden;\par
  white-space: nowrap;\par
\}\par
\par
.expandable-bubble[masked] > .expandable-bubble-contents >\par
    .expandable-bubble-title::after \{\par
  content: url('chrome://theme/IDR_APP_NOTIFICATION_NUB_MASK');\par
  display: block;\par
  height: 15px;\par
  overflow: hidden;\par
  position: absolute;\par
  right: 0;\par
  top: 0;\par
  width: 12px;\par
\}\par
\par
.expandable-bubble[expanded] > .expandable-bubble-contents >\par
    .expandable-bubble-title \{\par
  font-size: 13px;\par
  margin-left: 0;\par
  margin-bottom: 3px;\par
\}\par
\par
.expandable-bubble-close \{\par
  background-image: no-repeat 50% 50%;\par
  height: 16px;\par
  position: absolute;\par
  right: 0;\par
  top: 0;\par
  width: 16px;\par
  z-index: 2;\par
\}\par
\par
.expandable-bubble[expanded] \{\par
  padding: 3px;\par
  z-index: 3;  /* One higher then the close button on an unexpanded bubble. */\par
\}\par
\par
.expandable-bubble[expanded] > .expandable-bubble-close \{\par
  z-index: 4;\par
\}\par
\par
.expandable-bubble-close \{\par
  background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAQAAAC1+jfqAAAAiElEQVR42r2RsQrDMAxEBRdl8SDcX8lQPGg1GBI6lvz/h7QyRRXV0qUULwfvwZ1tenw5PxToRPWMC52eA9+WDnlh3HFQ/xBQl86NFYJqeGflkiogrOvVlIFhqURFVho3x1moGAa3deMs+LS30CAhBN5nNxeT5hbJ1zwmji2k+aF6NENIPf/hs54f0sZFUVAMigAAAABJRU5ErkJggg==");\par
\}\par
\par
.expandable-bubble-close:hover \{\par
  background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAQAAAC1+jfqAAAAqklEQVR4XqWRMQ6DMAxF/1Fyilyj2SmIBUG5QcTCyJA5Z8jGhlBPgRi4TmoDraVmKFJlWYrlp/g5QfwRlwEVNWVa4WzfH9jK6kCkEkBjwxOhLghheMWMELUAqqwQ4OCbnE4LJnhr5IYdqQt4DJQjhe9u4vBBmnxHHNzRFkDGjHDo0VuTAqy2vAG4NkvXXDHxbGsIGlj3e835VFNtdugma/Jk0eXq0lP//5svi4PtO01oFfYAAAAASUVORK5CYII=");\par
\}\par
\par
.expandable-bubble-close:active \{\par
  background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAQAAAC1+jfqAAAARElEQVQoz2P4z4AfMlBLAYMdwxkghgEwD1XBGTC0g0sDIaYJECVwFqoChBK4WegKkJWArSJZAQErCDqSKG/iCyhaRhYA9LDIbULDzlIAAAAASUVORK5CYII=");\par
\}\par
</style>\par
<style>/* Copyright (c) 2012 The Chromium Authors. All rights reserved.\par
 * Use of this source code is governed by a BSD-style license that can be\par
 * found in the LICENSE file.\par
 */\par
\par
menu \{\par
  -webkit-box-shadow: 0 2px 4px rgba(0, 0, 0, .50);\par
  background: white;\par
  color: black;\par
  cursor: default;\par
  display: none;\par
  left: 0;\par
  margin: 0;\par
  outline: 1px solid rgba(0, 0, 0, 0.2);\par
  padding: 8px 0;\par
  position: fixed;\par
  white-space: nowrap;\par
  z-index: 3;\par
\}\par
\par
menu > * \{\par
  box-sizing: border-box;\par
  display: block;\par
  margin: 0;\par
  width: 100%;\par
  text-align: start;\par
\}\par
\par
menu > :not(hr) \{\par
  -webkit-appearance: none;\par
  background: transparent;\par
  border: 0;\par
  font: inherit;\par
  line-height: 18px;\par
  overflow: hidden;\par
  padding: 0 19px;\par
  text-overflow: ellipsis;\par
\}\par
\par
menu > hr \{\par
  background: -webkit-linear-gradient(left,\par
                                      rgba(0, 0, 0, .10),\par
                                      rgba(0, 0, 0, .02) 96%);\par
  border: 0;\par
  height: 1px;\par
  margin: 8px 0;\par
\}\par
\par
menu > [disabled] \{\par
  color: rgba(0, 0, 0, .3);\par
\}\par
\par
/* Text alpha doesn't work on Linux/GTK and ChromeOs/views.\par
 * TODO(estade): {{\field{\*\fldinst{HYPERLINK http://crbug.com/88688 }}{\fldrslt{http://crbug.com/88688\ul0\cf0}}}}\f0\fs22 . */\par
html[toolkit=gtk] menu > [disabled],\par
html[os=chromeos] menu > [disabled] \{\par
  color: #969696;\par
\}\par
\par
menu > [hidden] \{\par
  display: none;\par
\}\par
\par
menu > :not(hr)[selected] \{\par
  background-color: #dce5fa;\par
\}\par
\par
menu > :not(hr)[selected]:active \{\par
  background-color: #426dc9;\par
  color: #fff;\par
\}\par
\par
menu > [checked]:before \{\par
  content: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAkAAAAJCAYAAADgkQYQAAAARklEQVQYlWNgwA+MgViQkIJ3QKzEAFVpjEPBf5giJaiAMRYF72DWKSEJlKMpgNsgiCTxH5sCbG7AqgBZ4V2sCv7//08QAwAUfjKKBs+BFgAAAABJRU5ErkJggg==");\par
  display: inline-block;\par
  height: 9px;\par
  margin: 0 5px;\par
  vertical-align: 50%;\par
  width: 9px;\par
\}\par
\par
menu > [checked] \{\par
  -webkit-padding-start: 0;\par
\}\par
\par
menu > [selected][checked]:active:before \{\par
  content: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAkAAAAJCAYAAADgkQYQAAAATElEQVR42oXNyw0AIAgDUFdwBVZgOKd1BVeokNhgiJ9DL+WRFgCvqKX+wLBIcenFBYBIVqEHMDgnW9ECxCPneEAGRDGRQEaEnSCjbyYFHgnBSWvSHgAAAABJRU5ErkJggg==");\par
\}\par
</style>\par
<style>/* Copyright (c) 2012 The Chromium Authors. All rights reserved.\par
 * Use of this source code is governed by a BSD-style license that can be\par
 * found in the LICENSE file.\par
 */\par
\par
.trash \{\par
  cursor: pointer;\par
  display: inline-block;\par
  outline: none;\par
  position: relative;\par
  width: 30px;\par
\}\par
\par
.trash > span \{\par
  display: inline-block;\par
\}\par
\par
.trash > .can,\par
.trash > .lid \{\par
  background: url('chrome://resources/images/trash.png') 0 0 no-repeat;\par
  left: 8px;\par
  position: absolute;\par
  right: 8px;\par
  top: 2px;\par
\}\par
\par
.trash > .lid \{\par
  -webkit-transition: -webkit-transform 150ms;\par
  -webkit-transform-origin: -7% 100%;\par
  height: 6px;\par
  width: 14px;\par
\}\par
\par
html[dir='rtl'] .trash > .lid \{\par
  -webkit-transform-origin: 107% 100%;\par
\}\par
\par
.trash:focus > .lid,\par
.trash:hover > .lid \{\par
  -webkit-transition: -webkit-transform 250ms;\par
  -webkit-transform: rotate(-45deg);\par
\}\par
\par
html[dir='rtl'] .trash:focus > .lid,\par
html[dir='rtl'] .trash:hover > .lid \{\par
  -webkit-transform: rotate(45deg);\par
\}\par
\par
.trash > .can \{\par
  background-position: -1px -4px;\par
  height: 12px;\par
  /* The margins match the background position offsets. */\par
  margin-left: 1px;\par
  /* The right margin is one greater due to a shadow on the trash image. */\par
  margin-right: 2px;\par
  margin-top: 4px;\par
  width: 11px;\par
\}\par
</style>\par
<style>/* Copyright (c) 2012 The Chromium Authors. All rights reserved.\par
 * Use of this source code is governed by a BSD-style license that can be\par
 * found in the LICENSE file. */\par
\par
.app \{\par
  outline: none;\par
  position: absolute;\par
  text-align: center;\par
\}\par
\par
.app-contents \{\par
  -webkit-transition: -webkit-transform 100ms;\par
\}\par
\par
.app-contents:active:not(.suppress-active),\par
.app:not(.click-focus):focus .app-contents:not(.suppress-active),\par
.drag-representation:not(.placing) .app-contents \{\par
  -webkit-transform: scale(1.1);\par
\}\par
\par
/* Don't animate the initial scaling.  */\par
.app-contents:active:not(.suppress-active),\par
/* Active gets applied right before .suppress-active, so to avoid flicker\par
 * we need to make the scale go back to normal without an animation. */\par
.app-contents.suppress-active \{\par
  -webkit-transition-duration: 0;\par
\}\par
\par
.app-contents > span \{\par
  display: block;\par
  overflow: hidden;\par
  text-decoration: none;\par
  text-overflow: ellipsis;\par
  white-space: nowrap;\par
\}\par
\par
.app-img-container \{\par
  margin-left: auto;\par
  margin-right: auto;\par
  /* -webkit-mask-image set by JavaScript to the image source */\par
  -webkit-mask-size: 100% 100%;\par
\}\par
\par
.app-img-container > * \{\par
  height: 100%;\par
  width: 100%;\par
\}\par
\par
.app-icon-div \{\par
  background-color: white;\par
  border: 1px solid #d5d5d5;\par
  border-radius: 5px;\par
  display: -webkit-box;\par
  margin-left: auto;\par
  margin-right: auto;\par
  position: relative;\par
  vertical-align: middle;\par
  z-index: 0;\par
  -webkit-box-align: center;\par
  -webkit-box-pack: center;\par
\}\par
\par
.app-icon-div .app-img-container \{\par
  bottom: 10px;\par
  left: 10px;\par
  position: absolute;\par
\}\par
\par
.app-icon-div .color-stripe \{\par
  border-bottom-left-radius: 5px 5px;\par
  border-bottom-right-radius: 5px 5px;\par
  bottom: 0;\par
  height: 3px;\par
  opacity: 1.0;\par
  position: absolute;\par
  width: 100%;\par
  z-index: 100;\par
\}\par
\par
.app-context-menu > button:first-child \{\par
  font-weight: bold;\par
\}\par
\par
.app-context-menu \{\par
  z-index: 1000;\par
\}\par
\par
.launch-click-target \{\par
  cursor: pointer;\par
\}\par
\par
/* Notifications */\par
\par
.app-notification \{\par
  color: #999999;  \par
  display: block;\par
  font-size: 11px;\par
  white-space: nowrap;\par
  -webkit-transition: color 150ms linear;\par
\}\par
\par
.app-notification:hover \{\par
  text-decoration: underline;\par
\}\par
\par
/* Promo */\par
/* Show the promo if the webstore has a promo and is the only app on the page.\par
 */\par
.tile:only-of-type > .has-promo > .app-contents > span \{\par
  display: none;\par
\}\par
\par
.tile:only-of-type > .has-promo .app-img-container > .apps-promo-logo \{\par
  display: block;\par
\}\par
\par
.apps-promo-logo \{\par
  display: none;\par
  height: 128px;\par
  width: 128px;\par
\}\par
\par
.tile:only-of-type > .has-promo .app-img-container > img:first-child \{\par
  display: none;\par
\}\par
\par
.app-img-container > img:first-child \{\par
  display: block;\par
\}\par
\par
/* TODO(estade): animation? */\par
.tile:only-of-type > .has-promo > .apps-promo-extras \{\par
  display: block;\par
\}\par
\par
.apps-promo-extras \{\par
  display: none;\par
  /* 128 * 5/4 */\par
  left: 160px;\par
  position: absolute;\par
  text-align: left;\par
  top: 0;\par
\}\par
\par
html[dir="rtl"] .apps-promo-extras \{\par
  left: auto;\par
  right: 160px;\par
\}\par
\par
.apps-promo-heading \{\par
  font-weight: bold;\par
  margin-bottom: 5px;\par
  -webkit-margin-start: 3px;\par
\}\par
\par
.g-button-basic \{\par
  border-width: 6px 10px 12px 6px;\par
  color: #fff !important;\par
  display: inline-block;\par
  font-size: 1.3em;\par
  font-weight: bold;\par
  padding: 2px 10px;\par
  text-align: center;\par
  text-decoration: none;\par
  white-space: nowrap;\par
  -webkit-border-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAD4AAABHCAYAAABf7PRNAAAEzUlEQVR4Xu2YP4gkRRTGf9Xdszu79088BMVEAw+8UBMREzURQ3MDMRQEQ8FE0Fi4TDQ4wcRAMLtLTA4EUzVYFUUP1vPk7tyb3fnX3VXf0x0ezcDC9qQ1Ox981LzhVfDr1/2oesHMALj2zc/2+Y09/r4/IcnIX/yF2ReqR5+Obr67DxiAryzAr779tT1/5SovPPcE54ZD2hSIMixD/nkLR3Nj/96En379g99+/4X2cP+Zw2/fvw3IwVV9+OWPC+hXX3yaqggOYEiGhUBuMhl1I+q0zZOXH6E+epQ/2+k7wAdABBJAdf3mHm+98TqTuTg3LDr4oiiQRG5KEoczMT28x2x0l0uDSCiHbwIfAzXQAFaNJg3TxuAo0STYGQRmrTGrRY4aTcX9gynTgzvMxw8g1hDCZeCcpwhQBTCepf/N4gHsboXjdfFfm8hOR3MxHd2lnvxLamYYhus8kIAIxApgOo8MBpU/gEXMtCFLxWZKnI9JscEssaQdYAZUQFEBC8hdIlDhMZLIUUoJSZgSkrGkITAAyg68shrYBqBt4yKuVZKjTGJhMzAHJwBUOPSxC8/3RAHGmqpwd08BmZFixIIoTABgIk8JMMwM6xhKltWBm9F9F4HQvQEZyoEN3Es6CQ54IhAMWcge3N0PTggQus25g/f2qsqzceo1AHceoxf8JKR/H9mSr/qqd0ldYxMY+YLj7gPHhFQQQuGh5cvN6s0NKUEoSGlpu/JEXz610Q9uhEKkZLjIuORgvtgqzc0MJYFvMCnvikuATgd3EXzUJBOG5f2N91f8pEwp+67u6+ngwYQkCCUAIesDjNz9XR3MkARW4DGW+QEGVunqXnVTwmPIGtxXOB08GQwwLCU8PiO3MzMIYXn32biPB8nHb+Bxxic3W2pu6qm4EljArMDjjL9xrd7cTAkTmEq6mJDvqw6rTmAEhlfcYwXylEDC1Qce3C5C7ncUzOip+EllP2XtJjB9FZeEFJCJACj/ru7uv48j+QaP12quHvpfdZIAyBy8W1cHlzzI/pJC/8ktCQoZMlwh74qz4pE1CkoZ0np09e7IivrO6hEoSKoIAIpgyv/ISk/FSyKEEsl8b5v1XB1stQNMsAQGKAGgmDCFbKesyMAE0N/cQjSK0AIgy3uubu6eintSMkIV85+rm47tEPSA+wRmWcZZGD11WoJf+ylrj9Z3rr5+5O7TO3TBWdMGPFdtwDfgG/AN+AZ8A74BrwBSEkWAVAYAlIRJ6w9e1y11A/O6QIIYa0yJHJWaCbGdIyVMfVPW+ggpUi+SW5SabK+lqZ0tbClinA7e1NODLYs1SsduMUvgw4nspISZcGGhAEvzk+BK303a+ctVM8IUfdP6qB3soPloD7AlU6kdf3Y4uPjyhfohpRLrpFRuMd55nPb2rRtABBIOH4DdS69de6/cvvhRmWaUqVkb6FTu0Pzzw/Xx9598BRwAD4ARMAnAENipLl95bPupV14Kw0vPkpptUxxgKoGQJfjh/p3m9q09zQ9GwNiBHwJHwCwAW8A2sAtcAM777yEwAEKG8OZugTkwdeCx/64rQHiCAyag9gdSAkWm4HKWxtlmvrZAqpYTfEP0hAoo3GQEb77KHR22waEBqwDDg6XE0h0yf9WdbdkIsP8ABZhTTDj3evgAAAAASUVORK5CYII=") 6 10 12 6;\par
\}\par
\par
.app .invisible \{\par
  visibility: hidden;\par
\}\par
</style>\par
<style>/* Copyright (c) 2012 The Chromium Authors. All rights reserved.\par
 * Use of this source code is governed by a BSD-style license that can be\par
 * found in the LICENSE file.\par
 */\par
\par
.most-visited \{\par
  position: absolute;\par
  z-index: 0;\par
\}\par
\par
.most-visited \{\par
  display: -webkit-box;\par
  position: absolute;\par
  text-decoration: none;\par
  -webkit-box-orient: vertical;\par
\}\par
\par
.most-visited:focus \{\par
  outline: none;\par
\}\par
\par
.fills-parent \{\par
  bottom: 0;\par
  display: -webkit-box;\par
  left: 0;\par
  position: absolute;\par
  right: 0;\par
  top: 0;\par
\}\par
\par
/* filler mode: hide everything except the thumbnail --- leave a grey rectangle\par
 * in its place. */\par
.filler * \{\par
  visibility: hidden;\par
\}\par
\par
.filler \{\par
  pointer-events: none;\par
\}\par
\par
.most-visited .close-button \{\par
  opacity: 0;\par
  position: absolute;\par
  right: 0;\par
  top: 0;\par
  z-index: 5;\par
  -webkit-transition: opacity 150ms;\par
\}\par
\par
html[dir=rtl] .most-visited .close-button \{\par
  left: 0;\par
  right: auto;\par
\}\par
\par
.most-visited:hover .close-button \{\par
  opacity: 1;\par
  -webkit-transition-delay: 500ms;\par
\}\par
\par
.most-visited .close-button:hover \{\par
  -webkit-transition: none;\par
\}\par
\par
.most-visited .favicon \{\par
  -webkit-margin-start: 5px;\par
  background: no-repeat left 50%;\par
  bottom: 7px;\par
  box-sizing: border-box;\par
  display: block;\par
  height: 16px;\par
  position: absolute;\par
  width: 16px;\par
\}\par
\par
html[dir='rtl'] .most-visited .favicon \{\par
  background-position-x: right;\par
\}\par
\par
.most-visited .color-stripe \{\par
  border-bottom-left-radius: 3px 3px;\par
  border-bottom-right-radius: 3px 3px;\par
  /* Matches height of title.  */\par
  bottom: 23px;\par
  height: 3px;\par
  /* Matches padding-top of the title. */\par
  margin-bottom: 8px;\par
  position: absolute;\par
  width: 100%;\par
  z-index: 10;\par
\}\par
\par
.most-visited .title \{\par
  display: block;\par
  height: 23px;\par
  overflow: hidden;\par
  padding-top: 8px;\par
  text-align: center;\par
  text-overflow: ellipsis;\par
  white-space: nowrap;\par
\}\par
\par
.thumbnail \{\par
  background: no-repeat;\par
  /* This shows for missing thumbnails. */\par
  background-color: #eee;\par
  background-size: 100%;\par
  border-radius: 3px;\par
  /* These max dimensions are not necessary, as the sizing logic in the .js\par
   * should be sufficient, but they're here for extra insurance. We never want\par
   * to scale a thumbnail larger than this size. */\par
  max-height: 132px;\par
  max-width: 212px;\par
  -webkit-transition: opacity 150ms;\par
\}\par
\par
.filler .thumbnail \{\par
  /* TODO(estade): there seems to be a webkit bug where this border is not\par
   * always removed when it should be. Investigate. */\par
  border: 1px solid;\par
  visibility: visible;\par
\}\par
\par
.thumbnail-shield \{\par
  border-radius: 3px;\par
  background: -webkit-linear-gradient(rgba(255, 255, 255, 0),\par
                                      rgba(255, 255, 255, 0) 50%,\par
                                      rgba(255, 255, 255, 0.9));\par
\}\par
\par
/* TODO(dbeam): Remove this when printing of -webkit-linear-gradient() works. */\par
@media print \{\par
  .thumbnail-shield \{\par
    background: none;\par
  \}\par
\}\par
\par
.most-visited:focus .thumbnail,\par
.most-visited:hover .thumbnail \{\par
  opacity: 0.95;\par
\}\par
\par
.most-visited:focus .thumbnail-shield,\par
.most-visited:hover .thumbnail-shield,\par
.most-visited:active .thumbnail-shield \{\par
  background: -webkit-linear-gradient(rgba(255, 255, 255, 0),\par
                                      rgba(255, 255, 255, 0) 80%,\par
                                      rgba(255, 255, 255, 0.9));\par
\}\par
\par
/* The thumbnail gets lighter when clicked, but not when the click is on the\par
 * close button. */\par
.most-visited:active .close-button:not(:active) + .thumbnail \{\par
  opacity: 0.9;\par
\}\par
\par
/* The thumbnail gets a shadow when clicked, but not when the click is on the\par
 * close button. */\par
.most-visited:active .close-button:not(:active) + .thumbnail .thumbnail-shield \{\par
  -webkit-box-shadow: inset 0 1px 10px rgba(0, 0, 0, 0.2);\par
\}\par
\par
.thumbnail-wrapper \{\par
  border: 1px solid transparent;\par
  border-radius: 3px;\par
  display: block;\par
  position: relative;\par
  z-index: 5;\par
  -webkit-box-flex: 1;\par
  -webkit-transition: background-color 150ms;\par
\}\par
\par
.filler .thumbnail-wrapper \{\par
  visibility: visible;\par
\}\par
\par
/* 'finishing-drag' is the state we are in after dropping on the trash can.\par
 * Override opacity of the tile to 1, so that the new tile animation\par
 * occurs simultaneously with the trash animation. */\par
.tile.dragging.finishing-drag \{\par
  opacity: 1;\par
\}\par
\par
/* Don't display the new tile until there's something to show.  */\par
.blacklisted \{\par
  opacity: 0;\par
\}\par
</style>\par
<style>/* Copyright (c) 2012 The Chromium Authors. All rights reserved.\par
 * Use of this source code is governed by a BSD-style license that can be\par
 * found in the LICENSE file.\par
 */\par
\par
/* TODO(estade): handle overflow better? I tried overflow-x: hidden and\par
   overflow-y: visible (for the new dot animation), but this makes a scroll\par
   bar appear */\par
#dot-list \{\par
  display: -webkit-box;\par
  height: 100%;\par
  list-style-type: none;\par
  margin: 0;\par
  padding: 0;\par
  /* Expand to take up all available horizontal space.  */\par
  -webkit-box-flex: 1;\par
  /* Center child dots. */\par
  -webkit-box-pack: center;\par
\}\par
\par
html.starting-up #dot-list \{\par
  display: none;\par
\}\par
\par
.dot \{\par
  box-sizing: border-box;\par
  cursor: pointer;\par
  /* max-width: Set in new_tab.js. See measureNavDots() */\par
  outline: none;\par
  text-align: left;\par
  -webkit-box-flex: 1;\par
  -webkit-margin-end: 10px;\par
  -webkit-padding-start: 2px;\par
  -webkit-transition: max-width 250ms, -webkit-margin-end 250ms;\par
\}\par
\par
.dot:last-child \{\par
  -webkit-margin-end: 0;\par
\}\par
\par
.dot.small \{\par
  max-width: 0;\par
  -webkit-margin-end: 0;\par
\}\par
\par
.dot .selection-bar \{\par
  border-bottom: 5px solid;\par
  border-color: rgba(0, 0, 0, 0.1);\par
  height: 10px;\par
  -webkit-transition: border-color 200ms;\par
\}\par
\par
.dot input \{\par
  background-color: transparent;\par
  cursor: inherit;\par
  /* TODO(estade): the font needs tweaking. */\par
  font-size: 8pt;\par
  font-weight: bold;\par
  padding-top: 0;\par
  width: 90%;\par
  -webkit-appearance: caret;\par
  -webkit-transition: color 200ms;\par
\}\par
\par
.dot input:focus \{\par
  cursor: auto;\par
\}\par
\par
/* Everything below here should be themed but we don't have appropriate colors\par
 * yet.\par
 */\par
.dot input \{\par
  color: #b2b2b2;\par
\}\par
\par
.dot:focus input, .dot:hover input, .dot.selected input \{\par
  color: #7f7f7f;\par
\}\par
\par
.dot:focus .selection-bar,\par
.dot:hover .selection-bar,\par
.dot.drag-target .selection-bar \{\par
  border-color: #b2b2b2;\par
\}\par
\par
.dot.selected .selection-bar \{\par
  border-color: #7f7f7f;\par
\}\par
</style>\par
<style>/* Copyright (c) 2012 The Chromium Authors. All rights reserved.\par
 * Use of this source code is governed by a BSD-style license that can be\par
 * found in the LICENSE file.\par
 */\par
\par
html \{\par
  font-family: segoe ui, arial, helvetica, sans-serif;\par
  font-size: 14px;\par
  /* It's necessary to put this here instead of in body in order to get the\par
     background-size of 100% to work properly */\par
  height: 100%;\par
  overflow: hidden;\par
\}\par
\par
body \{\par
  /* Don't highlight links when they're tapped.  Safari has bugs here that\par
     show up as flicker when dragging in some situations */\par
  -webkit-tap-highlight-color: transparent;\par
  /* Don't allow selecting text - can occur when dragging */\par
  -webkit-user-select: none;\par
  background-size: auto 100%;\par
  margin: 0;\par
\}\par
\par
/* [hidden] does display:none, but its priority is too low in some cases. */\par
[hidden] \{\par
  display: none !important;\par
\}\par
\par
#notification-container \{\par
  -webkit-transition-duration: 100ms;\par
  -webkit-transition-property: opacity;\par
  display: block;\par
  margin-top: 2px;\par
  position: relative;\par
  text-align: center;\par
  z-index: 15;\par
\}\par
\par
#notification-container.inactive \{\par
  -webkit-transition-duration: 200ms;\par
  opacity: 0;\par
\}\par
\par
#notification \{\par
  background-color: #FFF199;\par
  border: 1px solid lightGrey;\par
  border-radius: 6px;\par
  color: black;\par
  display: inline-block;\par
  font-weight: bold;\par
  padding: 7px 15px;\par
\}\par
\par
#notification > div > div,\par
#notification > div \{\par
  display: inline-block;\par
\}\par
\par
#notification .close-button \{\par
  -webkit-margin-start: 0.5em;\par
  vertical-align: middle;\par
\}\par
\par
.close-button \{\par
  background: no-repeat;\par
  background-color: transparent;\par
  /* TODO(estade): this should animate between states. */\par
  background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAQAAAC1+jfqAAAAiElEQVR42r2RsQrDMAxEBRdl8SDcX8lQPGg1GBI6lvz/h7QyRRXV0qUULwfvwZ1tenw5PxToRPWMC52eA9+WDnlh3HFQ/xBQl86NFYJqeGflkiogrOvVlIFhqURFVho3x1moGAa3deMs+LS30CAhBN5nNxeT5hbJ1zwmji2k+aF6NENIPf/hs54f0sZFUVAMigAAAABJRU5ErkJggg==");\par
  border: 0;\par
  cursor: default;\par
  display: inline-block;\par
  height: 16px;\par
  padding: 0;\par
  width: 16px;\par
\}\par
\par
.close-button:hover,\par
.close-button:focus \{\par
  background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAQAAAC1+jfqAAAAqklEQVR4XqWRMQ6DMAxF/1Fyilyj2SmIBUG5QcTCyJA5Z8jGhlBPgRi4TmoDraVmKFJlWYrlp/g5QfwRlwEVNWVa4WzfH9jK6kCkEkBjwxOhLghheMWMELUAqqwQ4OCbnE4LJnhr5IYdqQt4DJQjhe9u4vBBmnxHHNzRFkDGjHDo0VuTAqy2vAG4NkvXXDHxbGsIGlj3e835VFNtdugma/Jk0eXq0lP//5svi4PtO01oFfYAAAAASUVORK5CYII=");\par
\}\par
\par
.close-button:active \{\par
  background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAQAAAC1+jfqAAAARElEQVQoz2P4z4AfMlBLAYMdwxkghgEwD1XBGTC0g0sDIaYJECVwFqoChBK4WegKkJWArSJZAQErCDqSKG/iCyhaRhYA9LDIbULDzlIAAAAASUVORK5CYII=");\par
\}\par
\par
.linkButton \{\par
  -webkit-margin-start: 0.5em;\par
  color: #06C;\par
  cursor: pointer;\par
  display: inline-block;\par
  text-decoration: underline;\par
\}\par
\par
#card-slider-frame \{\par
  /* Must match #footer height. */\par
  bottom: 50px;\par
  overflow: hidden;\par
  /* We want this to fill the window except for the region used\par
     by footer */\par
  position: fixed;\par
  top: 0;\par
  width: 100%;\par
\}\par
\par
#page-list \{\par
  /* fill the apps-frame */\par
  height: 100%;\par
  display: -webkit-box;\par
\}\par
\par
#attribution \{\par
  bottom: 0;\par
  left: auto;\par
  margin-left: 8px;\par
  /* Leave room for the scrollbar. */\par
  margin-right: 13px;\par
  position: absolute;\par
  right: 0;\par
  text-align: left;\par
  z-index: -5;\par
\}\par
\par
/* For themes that right-align their images, we flip the attribution to the\par
 * left to avoid conflicts.  */\par
html[themegravity='right'] #attribution,\par
html[dir='rtl'] #attribution \{\par
  left: 0;\par
  right: auto;\par
  text-align: right;\par
\}\par
\par
#attribution > span \{\par
  display: block;\par
  font-size: 84%;\par
\}\par
\par
#footer \{\par
  background-image: -webkit-linear-gradient(\par
      rgba(242, 242, 242, 0.9), rgba(222, 222, 222, 0.9));\par
  bottom: 0;\par
  position: fixed;\par
  width: 100%;\par
  z-index: 5;\par
\}\par
\par
/* TODO(estade): remove this border hack and replace with a webkit-gradient\par
 * border-image on #footer once WebKit supports border-image-slice.\par
 * See {{\field{\*\fldinst{HYPERLINK https://bugs.webkit.org/show_bug.cgi?id=20127 }}{\fldrslt{https://bugs.webkit.org/show_bug.cgi?id=20127\ul0\cf0}}}}\f0\fs22  */\par
#footer-border \{\par
  height: 1px;\par
\}\par
\par
#footer-content \{\par
  -webkit-box-align: center;\par
  display: -webkit-box;\par
  height: 49px;\par
\}\par
\par
#footer-content > * \{\par
  margin: 0 9px;\par
\}\par
\par
#logo-img \{\par
  margin-top: 4px;\par
\}\par
\par
.starting-up * \{\par
  -webkit-transition: none !important;\par
\}\par
\par
/* Login Status. **************************************************************/\par
\par
#login-container \{\par
  -webkit-box-shadow: none;\par
  background: transparent none;\par
  border: none;\par
  cursor: pointer;\par
  font-size: 13px;\par
  /* Leave room for the scrollbar. */\par
  margin-left: 13px;\par
  margin-right: 13px;\par
  margin-top: 5px;\par
  padding: 0;\par
  position: fixed;\par
  right: 0;\par
  text-align: right;\par
  top: 0;\par
  z-index: 10;\par
\}\par
\par
html[dir='rtl'] #login-container \{\par
  left: 0;\par
  right: auto;\par
\}\par
\par
.login-status-icon \{\par
  -webkit-padding-end: 37px;\par
  background-position: right center;\par
  background-repeat: no-repeat;\par
  min-height: 27px;\par
\}\par
\par
html[dir='rtl'] .login-status-icon \{\par
  background-position-x: left;\par
\}\par
\par
.profile-name:hover \{\par
  text-decoration: underline;\par
\}\par
\par
.link-span \{\par
  text-decoration: underline;\par
\}\par
\par
#login-status-bubble-contents \{\par
  font-size: 13px;\par
\}\par
\par
#login-status-message-container \{\par
  margin-bottom: 13px;\par
\}\par
\par
#login-status-learn-more \{\par
  display: inline-block;\par
\}\par
\par
.login-status-row \{\par
  -webkit-box-align: center;\par
  -webkit-box-orient: horizontal;\par
  -webkit-box-pack: end;\par
  display: -webkit-box;\par
\}\par
\par
#login-status-advanced-container \{\par
  -webkit-box-flex: 1;\par
\}\par
\par
#login-status-dismiss \{\par
  min-width: 6em;\par
\}\par
\par
/* Trash. *********************************************************************/\par
\par
#trash \{\par
  -webkit-transition: top 200ms, opacity 0;\par
  -webkit-transition-delay: 0, 200ms;\par
  color: #222;\par
  height: 100%;\par
  position: absolute;\par
  opacity: 0;\par
  right: 0;\par
  top: 50px;\par
  width: auto;\par
\}\par
\par
html[dir='rtl'] #trash \{\par
  left: 0;\par
  right: auto;\par
\}\par
\par
#footer.showing-trash-mode #trash \{\par
  -webkit-transition-delay: 0, 0;\par
  -webkit-transition-duration: 0, 200ms;\par
  opacity: 0.75;\par
  top: 0;\par
\}\par
\par
#footer.showing-trash-mode #trash.drag-target \{\par
  opacity: 1;\par
\}\par
\par
#trash > .trash-text \{\par
  -webkit-padding-end: 7px;\par
  -webkit-padding-start: 30px;\par
  border: 1px dashed #7f7f7f;\par
  border-radius: 4px;\par
  display: inline-block;\par
  font-size: 84%;\par
  padding-bottom: 9px;\par
  padding-top: 10px;\par
  position: relative;\par
  top: 7px;\par
\}\par
\par
#trash > .lid,\par
#trash > .can \{\par
  top: 18px;\par
\}\par
\par
#footer.showing-trash-mode #trash.drag-target .lid \{\par
  -webkit-transform: rotate(-45deg);\par
\}\par
\par
html[dir='rtl'] #footer.showing-trash-mode #trash.drag-target .lid \{\par
  -webkit-transform: rotate(45deg);\par
\}\par
\par
#fontMeasuringDiv \{\par
  /* The font attributes match the nav inputs. */\par
  font-size: 8pt;\par
  font-weight: bold;\par
  pointer-events: none;\par
  position: absolute;\par
  visibility: hidden;\par
\}\par
\par
/* Page switcher buttons. *****************************************************/\par
\par
.page-switcher \{\par
  -webkit-transition: width 150ms, right 150ms, background-color 150ms;\par
  background-color: transparent;\par
  border: none;\par
  bottom: 0;\par
  font-size: 40px;\par
  padding: 0;\par
  position: absolute;\par
  margin: 0;\par
  max-width: 150px;\par
  min-width: 90px;\par
  outline: none;\par
  top: 0;\par
  z-index: 5;\par
\}\par
\par
#chrome-web-store-href \{\par
  -webkit-padding-end: 12px;\par
  /* Match transition delay of recently closed button. */\par
  -webkit-transition-delay: 100ms;\par
  color: #7F7F7F;\par
  cursor: pointer;\par
  display: none;\par
  margin: 0;\par
  text-decoration: none;\par
\}\par
\par
#chrome-web-store-title \{\par
  -webkit-padding-end: 26px;\par
  -webkit-padding-start: 16px;\par
  background: url('chrome://theme/IDR_WEBSTORE_ICON_24') right 50% no-repeat;\par
  display: inline-block;\par
  font-weight: bold;\par
  font-size: 9pt;\par
  line-height: 49px;\par
\}\par
\par
#chrome-web-store-href:hover \{\par
  color: #666;\par
\}\par
\par
html[dir='rtl'] #chrome-web-store-title \{\par
  background-position-x: left;\par
\}\par
\par
/* Show the chrome-web-store button when the experiment is turned on. */\par
.enable-cws-experiment #chrome-web-store-href \{\par
  display: inline-block;\par
\}\par
\par
/* Reserve space for the menu button even when it's hidden. */\par
#footer.showing-trash-mode #chrome-web-store-href \{\par
  visibility: hidden;\par
\}\par
\par
#footer.showing-trash-mode #chrome-web-store-href \{\par
  -webkit-transition-delay: 0;\par
  opacity: 0;\par
\}\par
</style>\par
<style>/* Copyright (c) 2012 The Chromium Authors. All rights reserved.\par
 * Use of this source code is governed by a BSD-style license that can be\par
 * found in the LICENSE file. */\par
\par
#recently-closed-menu-button \{\par
  -webkit-appearance: none;\par
  -webkit-padding-end: 15px;\par
  -webkit-padding-start: 9px;\par
  -webkit-transition: opacity 200ms;\par
  -webkit-transition-delay: 100ms;\par
  background: none;\par
  border: 0;\par
  color: #7F7F7F;\par
  cursor: pointer;\par
  display: block;\par
  margin: 0;\par
  font-size: 9pt;\par
  font-weight: bold;\par
  height: 100%;\par
  /* The padding increases the clickable area. */\par
  padding-bottom: 0;\par
  padding-top: 0;\par
\}\par
\par
.enable-cws-experiment #recently-closed-menu-button \{\par
  position: relative;\par
  -webkit-margin-end: 0;\par
  -webkit-padding-end: 16px;\par
\}\par
\par
#recently-closed-menu-button:hover:not([menu-shown]) \{\par
  color: #666;\par
\}\par
\par
#recently-closed-menu-button:hover:not([menu-shown]) .disclosure-triangle \{\par
  background-color: #666;\par
\}\par
\par
#recently-closed-menu-button[menu-shown] \{\par
  color: #555;\par
\}\par
\par
#recently-closed-menu-button[menu-shown] .disclosure-triangle \{\par
  background-color: #555;\par
\}\par
\par
/* Reserve space for the menu button even when it's hidden. */\par
#recently-closed-menu-button.invisible,\par
#footer.showing-trash-mode #recently-closed-menu-button \{\par
  visibility: hidden;\par
\}\par
\par
#footer.showing-trash-mode #recently-closed-menu-button \{\par
  opacity: 0;\par
  -webkit-transition-delay: 0;\par
\}\par
\par
#recently-closed-menu-button > * \{\par
  vertical-align: middle;\par
\}\par
\par
.recent-menu \{\par
  padding: 6px 8px;\par
  /* Needs to be above #footer. */\par
  z-index: 10;\par
\}\par
\par
.recent-menu-item \{\par
  background: no-repeat 0 50%;\par
  background-color: transparent !important;\par
  background-size: 16px 16px;\par
  box-sizing: border-box;\par
  display: block;\par
  font-size: 100%;\par
  line-height: 20px;\par
  margin: 8px;\par
  max-width: 450px;\par
  overflow: hidden;\par
  text-overflow: ellipsis;\par
  white-space: nowrap;\par
  -webkit-margin-start: 0;\par
  -webkit-padding-end: 0;\par
  -webkit-padding-start: 22px;\par
\}\par
\par
.recent-menu-item:not(:hover) \{\par
  text-decoration: none;\par
\}\par
\par
.recent-menu-item:first-of-type \{\par
  margin-top: 4px;\par
\}\par
\par
.recent-menu-item:last-of-type \{\par
  margin-bottom: 4px;\par
\}\par
\par
html[dir='rtl'] .recent-menu-item \{\par
  background: no-repeat 100% 50%;\par
\}\par
\par
.recent-window \{\par
  background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAA0UlEQVR42s2OSwsBYRSGz1+Uv6CQyTUsLFzKlFtmMWUQvkSJxIgfYGVrZWFjr9jY2L3mzJSUoo6NxdPbWTxPhwCQWq+gNisMmDWv7a5yVvHtYrsoZuPBLvXsOfzWVURvOQdZ0wna2xt2++OT5uIAX+vyFWs2AZnjoSudzvdXOPL1A3M0BBn9jie9w+GPGP0uqNYyPUFA1XFJNxrigG7UQYWKLg4UK2VQrpQXB9j9g0A2lxUHMo5LqUxCHEilk6BYXBMHoo5LES0oDrBL4VAAv/AAQoVZHAc9DoAAAAAASUVORK5CYII=");\par
\}\par
\par
/* TODO(estade): find a better color for active. */\par
.recent-menu-item:active,\par
.recent-menu-item:visited,\par
.recent-menu-item:link \{\par
  color: hsl(213, 90%, 24%) !important;\par
\}\par
\par
.disclosure-triangle \{\par
  background-color: #7F7F7F;\par
  display: inline-block;\par
  height: 9px;\par
  width: 9px;\par
  -webkit-margin-start: 2px;\par
  -webkit-mask-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAkAAAAJCAYAAADgkQYQAAAAJUlEQVQYV2NgoDuYSQSGK/RB0+yDrACbQqwKkBUW41OArJB0AAACXws0ERupuAAAAABJRU5ErkJggg==");\par
\}\par
\par
#vertical-separator \{\par
  background-color: #B2B2B2;\par
  display: none;\par
  height: 20px;\par
  left: 15px;\par
  position: relative;\par
  right: 15px;\par
  width: 1px;\par
\}\par
\par
.enable-cws-experiment #vertical-separator \{\par
  display: inline-block;\par
\}\par
</style>\par
<style>/* Copyright (c) 2011 The Chromium Authors. All rights reserved.\par
 * Use of this source code is governed by a BSD-style license that can be\par
 * found in the LICENSE file.\par
 */\par
\par
.tile-page \{\par
  display: -webkit-box;\par
  height: 100%;\par
  position: relative;\par
  width: 100%;\par
  -webkit-box-orient: vertical;\par
\}\par
\par
.tile-page-scrollbar \{\par
  margin: 0 4px;\par
  pointer-events: none;\par
  position: absolute;\par
  right: 0;\par
  width: 5px;\par
  z-index: 5;\par
  -webkit-box-sizing: border-box;\par
\}\par
\par
.tile-page-content \{\par
  overflow-y: scroll;\par
  /* This value is mirrored in TilePage.updateTopMargin_ */\par
  padding-top: 60px;\par
  position: relative;\par
  text-align: center;\par
  width: 100%;\par
  /* TODO(estade): this mask is disabled for technical reasons. It negatively\par
   * impacts performance of page switching, also it causes problems with Mac\par
   * text: {{\field{\*\fldinst{HYPERLINK http://crbug.com/86955 }}{\fldrslt{http://crbug.com/86955\ul0\cf0}}}}\f0\fs22\par
  -webkit-mask-image: -webkit-linear-gradient(bottom, transparent, black 30px);\par
  */\par
  /* The following four properties are necessary so that the mask won't clip\par
   * the scrollbar. */\par
  box-sizing: border-box;\par
  /* Scrollbar width(13px) + balance right padding.  */\par
  padding-left: 93px;\par
  padding-right: 80px;\par
  -webkit-box-flex: 1;\par
  /* Don't apply clip mask to padding. */\par
  -webkit-mask-clip: content-box;\par
\}\par
\par
.tile-grid \{\par
  position: relative;\par
  width: 100%;\par
\}\par
\par
.tile \{\par
  display: inline-block;\par
  position: absolute;\par
  -webkit-print-color-adjust: exact;\par
  /* Don't offer the context menu on long-press. */\par
  -webkit-touch-callout: none;\par
  -webkit-user-drag: element;\par
\}\par
\par
/* I don't know why this is necessary. -webkit-user-drag: element on .tile\par
 * should be enough. If we don't do this, we get 2 drag representations for\par
 * the image. */\par
.tile img \{\par
  -webkit-user-drag: none;\par
\}\par
\par
.doppleganger \{\par
  left: 0 !important;\par
  right: 0 !important;\par
  top: 0 !important;\par
\}\par
\par
.tile.dragging \{\par
  opacity: 0;\par
\}\par
\par
.tile.drag-representation \{\par
  pointer-events: none;\par
  position: fixed;\par
  z-index: 3;\par
  -webkit-transition: opacity 200ms;\par
\}\par
\par
.tile.drag-representation.placing > * \{\par
  -webkit-transition: -webkit-transform 200ms;\par
\}\par
\par
/* When a drag finishes while we're not showing the page where the tile\par
 * belongs, the tile shrinks to a dot. */\par
.tile.drag-representation.dropped-on-other-page > * \{\par
   -webkit-transform: scale(0) rotate(0);\par
\}\par
\par
.tile.drag-representation.deleting > * \{\par
  -webkit-transform: scale(0) rotate(360deg);\par
  -webkit-transition: -webkit-transform 600ms;\par
\}\par
\par
.animating-tile-page .tile,\par
.tile.drag-representation.placing \{\par
  -webkit-transition: left 200ms, right 200ms, top 200ms;\par
\}\par
\par
.hovering-on-trash \{\par
  opacity: 0.6;\par
\}\par
\par
.animating-tile-page .top-margin \{\par
  -webkit-transition: margin-bottom 200ms;\par
\}\par
\par
@-webkit-keyframes bounce \{\par
  0% \{\par
    -webkit-transform: scale(0, 0);\par
  \}\par
\par
  60% \{\par
    -webkit-transform: scale(1.2, 1.2);\par
  \}\par
\par
  100% \{\par
    -webkit-transform: scale(1, 1);\par
  \}\par
\}\par
\par
.tile > .new-tile-contents \{\par
  -webkit-animation: bounce 500ms ease-in-out;\par
\}\par
\par
@-webkit-keyframes blipout \{\par
  0% \{\par
    -webkit-transform: scale(1, 1);\par
  \}\par
\par
  60% \{\par
    opacity: 1;\par
    -webkit-animation-timing-function: ease-in;\par
    -webkit-transform: scale(1.3, 0.02);\par
  \}\par
\par
  90% \{\par
    opacity: 0.7;\par
    -webkit-animation-timing-function: default;\par
    -webkit-transform: scale(0.3, 0.02);\par
  \}\par
\par
  100% \{\par
    opacity: 0;\par
    -webkit-animation-timing-function: linear;\par
    -webkit-transform: scale(0.3, 0.02);\par
  \}\par
\}\par
\par
.tile > .removing-tile-contents \{\par
  pointer-events: none;\par
  -webkit-animation: blipout 300ms;\par
\}\par
\par
.tile-page:not(.selected-card) * \{\par
  -webkit-transition: none !important;\par
\}\par
\par
/** Scrollbars ****************************************************************/\par
\par
.tile-page-content::-webkit-scrollbar \{\par
  width: 13px;\par
\}\par
\par
.tile-page-content::-webkit-scrollbar-button \{\par
  display: none;\par
\}\par
</style>\par
<link id="themecss" rel="stylesheet" href="chrome://theme/css/newtab.css?1455578975327">\par
\par
<script>// Copyright (c) 2011 The Chromium Authors. All rights reserved.\par
// Use of this source code is governed by a BSD-style license that can be\par
// found in the LICENSE file.\par
\par
/** @fileoverview EventTracker is a simple class that manages the addition and\par
 *  removal of DOM event listeners. In particular, it keeps track of all\par
 *  listeners that have been added and makes it easy to remove some or all of\par
 *  them without requiring all the information again. This is particularly\par
 *  handy when the listener is a generated function such as a lambda or the\par
 *  result of calling Function.bind.\par
 */\par
\par
// Use an anonymous function to enable strict mode just for this file (which\par
// will be concatenated with other files when embedded in Chrome)\par
var EventTracker = (function() \{\par
  'use strict';\par
\par
  /**\par
   *  Create an EventTracker to track a set of events.\par
   *  EventTracker instances are typically tied 1:1 with other objects or\par
   *  DOM elements whose listeners should be removed when the object is disposed\par
   *  or the corresponding elements are removed from the DOM.\par
   *  @constructor\par
   */\par
  function EventTracker() \{\par
    /**\par
     *  @type \{Array.<EventTracker.Entry>\}\par
     *  @private\par
     */\par
    this.listeners_ = [];\par
  \}\par
\par
  /**\par
   * The type of the internal tracking entry.\par
   *  @typedef \{\{node: !Node,\par
   *            eventType: string,\par
   *            listener: Function,\par
   *            capture: boolean\}\}\par
   */\par
  EventTracker.Entry;\par
\par
  EventTracker.prototype = \{\par
    /**\par
     * Add an event listener - replacement for Node.addEventListener.\par
     * @param \{!Node\} node The DOM node to add a listener to.\par
     * @param \{string\} eventType The type of event to subscribe to.\par
     * @param \{Function\} listener The listener to add.\par
     * @param \{boolean\} capture Whether to invoke during the capture phase.\par
     */\par
    add: function(node, eventType, listener, capture) \{\par
      var h = \{\par
        node: node,\par
        eventType: eventType,\par
        listener: listener,\par
        capture: capture\par
      \};\par
      this.listeners_.push(h);\par
      node.addEventListener(eventType, listener, capture);\par
    \},\par
\par
    /**\par
     * Remove any specified event listeners added with this EventTracker.\par
     * @param \{!Node\} node The DOM node to remove a listener from.\par
     * @param \{?string\} eventType The type of event to remove.\par
     */\par
    remove: function(node, eventType) \{\par
      this.listeners_ = this.listeners_.filter(function(h) \{\par
        if (h.node == node && (!eventType || (h.eventType == eventType))) \{\par
          EventTracker.removeEventListener_(h);\par
          return false;\par
        \}\par
        return true;\par
      \});\par
    \},\par
\par
    /**\par
     * Remove all event listeners added with this EventTracker.\par
     */\par
    removeAll: function() \{\par
      this.listeners_.forEach(EventTracker.removeEventListener_);\par
      this.listeners_ = [];\par
    \}\par
  \};\par
\par
  /**\par
   * Remove a single event listener given it's tracker entry.  It's up to the\par
   * caller to ensure the entry is removed from listeners_.\par
   * @param \{EventTracker.Entry\} h The entry describing the listener to remove.\par
   * @private\par
   */\par
  EventTracker.removeEventListener_ = function(h) \{\par
    h.node.removeEventListener(h.eventType, h.listener, h.capture);\par
  \};\par
\par
  return EventTracker;\par
\})();\par
\par
</script>\par
<script>// Copyright (c) 2011 The Chromium Authors. All rights reserved.\par
// Use of this source code is governed by a BSD-style license that can be\par
// found in the LICENSE file.\par
\par
// TODO(arv): Namespace\par
\par
/**\par
 * The local strings get injected into the page using a variable named\par
 * \{@code templateData\}. This class provides a simpler interface to access those\par
 * strings.\par
 *\par
 * @param \{Object\} opt_templateData Optional object containing translated\par
 *     strings.  If this is not supplied during construction, it can be\par
 *     assigned to the templateData property after construction.  If all else\par
 *     fails, the value of window.templateDate will be used.\par
 * @constructor\par
 */\par
function LocalStrings(opt_templateData) \{\par
  this.templateData = opt_templateData;\par
\}\par
\par
// Start of anonymous namespace.\par
(function() \{\par
\par
/**\par
 * Returns a formatted string where $1 to $9 are replaced by the second to the\par
 * tenth argument.\par
 * @param \{string\} s The format string.\par
 * @param \{...string\} The extra values to include in the formatted output.\par
 * @return \{string\} The string after format substitution.\par
 */\par
function replaceArgs(s, args) \{\par
  return s.replace(/\\$[$1-9]/g, function(m) \{\par
    return (m == '$$') ? '$' : args[m[1]];\par
  \});\par
\}\par
\par
/**\par
 * Returns a string after removing Windows-style accelerators.\par
 * @param \{string\} s The input string that may contain accelerators.\par
 * @return \{string\} The resulting string with accelerators removed.\par
 */\par
function trimAccelerators(s) \{\par
  return s.replace(/&\{1,2\}/g, function(m) \{\par
    return (m == '&&') ? '&' : '';\par
  \});\par
\}\par
\par
LocalStrings.prototype = \{\par
  /**\par
   * The template data object.\par
   * @type \{Object\}\par
   */\par
  templateData: null,\par
\par
  /**\par
   * Gets a localized string by its id.\par
   * @param \{string\} s The ID of the string we want.\par
   * @return \{string\} The localized string.\par
   */\par
  getString: function(id) \{\par
    // TODO(arv): We should not rely on a global variable here.\par
    return (this.templateData || window.templateData)[id] || '';\par
  \},\par
\par
  /**\par
   * Returns a formatted localized string where $1 to $9 are replaced by the\par
   * second to the tenth argument.\par
   * @param \{string\} id The ID of the string we want.\par
   * @param \{...string\} The extra values to include in the formatted output.\par
   * @return \{string\} The formatted string.\par
   */\par
  getStringF: function(id, var_args) \{\par
    return replaceArgs(this.getString(id), arguments);\par
  \},\par
\};\par
\par
// End of anonymous namespace.\par
\})();\par
</script>\par
<script>/**\par
 * Whitelist of tag names allowed in parseHtmlSubset.\par
 * @type \{[string]\}\par
 */\par
var allowedTags = ['A', 'B', 'STRONG'];\par
\par
/**\par
 * Parse a very small subset of HTML.\par
 * @param \{string\} s The string to parse.\par
 * @throws \{Error\} In case of non supported markup.\par
 * @return \{DocumentFragment\} A document fragment containing the DOM tree.\par
 */\par
var allowedAttributes = \{\par
  'href': function(node, value) \{\par
    // Only allow a[href] starting with {{\field{\*\fldinst{HYPERLINK http:// }}{\fldrslt{http://\ul0\cf0}}}}\f0\fs22  and {{\field{\*\fldinst{HYPERLINK https:// }}{\fldrslt{https://\ul0\cf0}}}}\f0\fs22\par
    return node.tagName == 'A' && (value.indexOf('http://') == 0 ||\par
        value.indexOf('https://') == 0);\par
  \},\par
  'target': function(node, value) \{\par
    // Allow a[target] but reset the value to "".\par
    if (node.tagName != 'A')\par
      return false;\par
    node.setAttribute('target', '');\par
    return true;\par
  \}\par
\}\par
\par
/**\par
 * Parse a very small subset of HTML.  This ensures that insecure HTML /\par
 * javascript cannot be injected into the new tab page.\par
 * @param \{string\} s The string to parse.\par
 * @throws \{Error\} In case of non supported markup.\par
 * @return \{DocumentFragment\} A document fragment containing the DOM tree.\par
 */\par
function parseHtmlSubset(s) \{\par
  function walk(n, f) \{\par
    f(n);\par
    for (var i = 0; i < n.childNodes.length; i++) \{\par
      walk(n.childNodes[i], f);\par
    \}\par
  \}\par
\par
  function assertElement(node) \{\par
    if (allowedTags.indexOf(node.tagName) == -1)\par
      throw Error(node.tagName + ' is not supported');\par
  \}\par
\par
  function assertAttribute(attrNode, node) \{\par
    var n = attrNode.nodeName;\par
    var v = attrNode.nodeValue;\par
    if (!allowedAttributes.hasOwnProperty(n) || !allowedAttributes[n](node, v))\par
      throw Error(node.tagName + '[' + n + '="' + v + '"] is not supported');\par
  \}\par
\par
  var r = document.createRange();\par
  r.selectNode(document.body);\par
  // This does not execute any scripts.\par
  var df = r.createContextualFragment(s);\par
  walk(df, function(node) \{\par
    switch (node.nodeType) \{\par
      case Node.ELEMENT_NODE:\par
        assertElement(node);\par
        var attrs = node.attributes;\par
        for (var i = 0; i < attrs.length; i++) \{\par
          assertAttribute(attrs[i], node);\par
        \}\par
        break;\par
\par
      case Node.COMMENT_NODE:\par
      case Node.DOCUMENT_FRAGMENT_NODE:\par
      case Node.TEXT_NODE:\par
        break;\par
\par
      default:\par
        throw Error('Node type ' + node.nodeType + ' is not supported');\par
    \}\par
  \});\par
  return df;\par
\}\par
</script>\par
<script>// Copyright (c) 2011 The Chromium Authors. All rights reserved.\par
// Use of this source code is governed by a BSD-style license that can be\par
// found in the LICENSE file.\par
\par
/**\par
 * The global object.\par
 * @type \{!Object\}\par
 */\par
const global = this;\par
\par
/**\par
 * Alias for document.getElementById.\par
 * @param \{string\} id The ID of the element to find.\par
 * @return \{HTMLElement\} The found element or null if not found.\par
 */\par
function $(id) \{\par
  return document.getElementById(id);\par
\}\par
\par
/**\par
 * Calls chrome.send with a callback and restores the original afterwards.\par
 * @param \{string\} name The name of the message to send.\par
 * @param \{!Array\} params The parameters to send.\par
 * @param \{string\} callbackName The name of the function that the backend calls.\par
 * @param \{!Function\} The function to call.\par
 */\par
function chromeSend(name, params, callbackName, callback) \{\par
  var old = global[callbackName];\par
  global[callbackName] = function() \{\par
    // restore\par
    global[callbackName] = old;\par
\par
    var args = Array.prototype.slice.call(arguments);\par
    return callback.apply(global, args);\par
  \};\par
  chrome.send(name, params);\par
\}\par
\par
/**\par
 * Generates a CSS url string.\par
 * @param \{string\} s The URL to generate the CSS url for.\par
 * @return \{string\} The CSS url string.\par
 */\par
function url(s) \{\par
  // {{\field{\*\fldinst{HYPERLINK http://www.w3.org/TR/css3-values/#uris }}{\fldrslt{http://www.w3.org/TR/css3-values/#uris\ul0\cf0}}}}\f0\fs22\par
  // Parentheses, commas, whitespace characters, single quotes (') and double\par
  // quotes (") appearing in a URI must be escaped with a backslash\par
  var s2 = s.replace(/(\\(|\\)|\\,|\\s|\\'|\\"|\\\\)/g, '{{\field{\*\fldinst{HYPERLINK "\\\\\\\\$1"}}{\fldrslt{\\\\$1\ul0\cf0}}}}\f0\fs22 ');\par
  // WebKit has a bug when it comes to URLs that end with \\\par
  // {{\field{\*\fldinst{HYPERLINK https://bugs.webkit.org/show_bug.cgi?id=28885 }}{\fldrslt{https://bugs.webkit.org/show_bug.cgi?id=28885\ul0\cf0}}}}\f0\fs22\par
  if (/\\\\\\\\$/.test(s2)) \{\par
    // Add a space to work around the WebKit bug.\par
    s2 += ' ';\par
  \}\par
  return 'url("' + s2 + '")';\par
\}\par
\par
/**\par
 * Parses query parameters from Location.\par
 * @param \{string\} s The URL to generate the CSS url for.\par
 * @return \{object\} Dictionary containing name value pairs for URL\par
 */\par
function parseQueryParams(location) \{\par
  var params = \{\};\par
  var query = unescape(location.search.substring(1));\par
  var vars = query.split("&");\par
  for (var i=0; i < vars.length; i++) \{\par
    var pair = vars[i].split("=");\par
    params[pair[0]] = pair[1];\par
  \}\par
  return params;\par
\}\par
\par
function findAncestorByClass(el, className) \{\par
  return findAncestor(el, function(el) \{\par
    if (el.classList)\par
      return el.classList.contains(className);\par
    return null;\par
  \});\par
\}\par
\par
/**\par
 * Return the first ancestor for which the \{@code predicate\} returns true.\par
 * @param \{Node\} node The node to check.\par
 * @param \{function(Node) : boolean\} predicate The function that tests the\par
 *     nodes.\par
 * @return \{Node\} The found ancestor or null if not found.\par
 */\par
function findAncestor(node, predicate) \{\par
  var last = false;\par
  while (node != null && !(last = predicate(node))) \{\par
    node = node.parentNode;\par
  \}\par
  return last ? node : null;\par
\}\par
\par
function swapDomNodes(a, b) \{\par
  var afterA = a.nextSibling;\par
  if (afterA == b) \{\par
    swapDomNodes(b, a);\par
    return;\par
  \}\par
  var aParent = a.parentNode;\par
  b.parentNode.replaceChild(a, b);\par
  aParent.insertBefore(b, afterA);\par
\}\par
\par
/**\par
 * Disables text selection and dragging.\par
 */\par
function disableTextSelectAndDrag() \{\par
  // Disable text selection.\par
  document.onselectstart = function(e) \{\par
    e.preventDefault();\par
  \}\par
\par
  // Disable dragging.\par
  document.ondragstart = function(e) \{\par
    e.preventDefault();\par
  \}\par
\}\par
\par
/**\par
 * Check the directionality of the page.\par
 * @return \{boolean\} True if Chrome is running an RTL UI.\par
 */\par
function isRTL() \{\par
  return document.documentElement.dir == 'rtl';\par
\}\par
\par
/**\par
 * Simple common assertion API\par
 * @param \{*\} condition The condition to test.  Note that this may be used to\par
 *     test whether a value is defined or not, and we don't want to force a\par
 *     cast to Boolean.\par
 * @param \{string=\} opt_message A message to use in any error.\par
 */\par
function assert(condition, opt_message) \{\par
  'use strict';\par
  if (!condition) \{\par
    var msg = 'Assertion failed';\par
    if (opt_message)\par
      msg = msg + ': ' + opt_message;\par
    throw new Error(msg);\par
  \}\par
\}\par
\par
/**\par
 * Get an element that's known to exist by its ID. We use this instead of just\par
 * calling getElementById and not checking the result because this lets us\par
 * satisfy the JSCompiler type system.\par
 * @param \{string\} id The identifier name.\par
 * @return \{!Element\} the Element.\par
 */\par
function getRequiredElement(id) \{\par
  var element = $(id);\par
  assert(element, 'Missing required element: ' + id);\par
  return element;\par
\}\par
\par
// Handle click on a link. If the link points to a chrome: or file: url, then\par
// call into the browser to do the navigation.\par
document.addEventListener('click', function(e) \{\par
  // Allow preventDefault to work.\par
  if (!e.returnValue)\par
    return;\par
\par
  var el = e.target;\par
  if (el.nodeType == Node.ELEMENT_NODE &&\par
      el.webkitMatchesSelector('A, A *')) \{\par
    while (el.tagName != 'A') \{\par
      el = el.parentElement;\par
    \}\par
\par
    if ((el.protocol == '{{\field{\*\fldinst{HYPERLINK file: }}{\fldrslt{file:\ul0\cf0}}}}\f0\fs22 ' || el.protocol == 'about:') &&\par
        (e.button == 0 || e.button == 1)) \{\par
      chrome.send('navigateToUrl', [\par
        el.href,\par
        el.target,\par
        e.button,\par
        e.altKey,\par
        e.ctrlKey,\par
        e.metaKey,\par
        e.shiftKey\par
      ]);\par
      e.preventDefault();\par
    \}\par
  \}\par
\});\par
\par
/**\par
 * Creates a new URL which is the old URL with a GET param of key=value.\par
 * @param \{string\} url The base URL. There is not sanity checking on the URL so\par
 *     it must be passed in a proper format.\par
 * @param \{string\} key The key of the param.\par
 * @param \{string\} value The value of the param.\par
 * @return \{string\}\par
 */\par
function appendParam(url, key, value) \{\par
  var param = encodeURIComponent(key) + '=' + encodeURIComponent(value);\par
\par
  if (url.indexOf('?') == -1)\par
    return url + '?' + param;\par
  return url + '&' + param;\par
\}\par
</script>\par
\par
<script>// Copyright (c) 2012 The Chromium Authors. All rights reserved.\par
// Use of this source code is governed by a BSD-style license that can be\par
// found in the LICENSE file.\par
\par
const cr = (function() \{\par
\par
  /**\par
   * Whether we are using a Mac or not.\par
   * @type \{boolean\}\par
   */\par
  const isMac = /Mac/.test(navigator.platform);\par
\par
  /**\par
   * Whether this is on the Windows platform or not.\par
   * @type \{boolean\}\par
   */\par
  const isWindows = /Win/.test(navigator.platform);\par
\par
  /**\par
   * Whether this is on chromeOS or not.\par
   * @type \{boolean\}\par
   */\par
  const isChromeOS = /CrOS/.test(navigator.userAgent);\par
\par
  /**\par
   * Whether this is on vanilla Linux (not chromeOS).\par
   * @type \{boolean\}\par
   */\par
  const isLinux = /Linux/.test(navigator.userAgent);\par
\par
  /**\par
   * Whether this uses GTK or not.\par
   * @type \{boolean\}\par
   */\par
  const isGTK = /GTK/.test(chrome.toolkit);\par
\par
  /**\par
   * Whether this uses the views toolkit or not.\par
   * @type \{boolean\}\par
   */\par
  const isViews = /views/.test(chrome.toolkit);\par
\par
  /**\par
   * Whether this window is optimized for touch-based input.\par
   * @type \{boolean\}\par
   */\par
  const isTouchOptimized = !!chrome.touchOptimized;\par
\par
  /**\par
   * Sets the os and toolkit attributes in the <html> element so that platform\par
   * specific css rules can be applied.\par
   */\par
  function enablePlatformSpecificCSSRules() \{\par
    if (isMac)\par
      doc.documentElement.setAttribute('os', 'mac');\par
    if (isWindows)\par
      doc.documentElement.setAttribute('os', 'windows');\par
    if (isChromeOS)\par
      doc.documentElement.setAttribute('os', 'chromeos');\par
    if (isLinux)\par
      doc.documentElement.setAttribute('os', 'linux');\par
    if (isGTK)\par
      doc.documentElement.setAttribute('toolkit', 'gtk');\par
    if (isViews)\par
      doc.documentElement.setAttribute('toolkit', 'views');\par
    if (isTouchOptimized)\par
      doc.documentElement.setAttribute('touch-optimized', '');\par
  \}\par
\par
  /**\par
   * Builds an object structure for the provided namespace path,\par
   * ensuring that names that already exist are not overwritten. For\par
   * example:\par
   * "a.b.c" -> a = \{\};a.b=\{\};a.b.c=\{\};\par
   * @param \{string\} name Name of the object that this file defines.\par
   * @param \{*=\} opt_object The object to expose at the end of the path.\par
   * @param \{Object=\} opt_objectToExportTo The object to add the path to;\par
   *     default is \{@code window\}.\par
   * @private\par
   */\par
  function exportPath(name, opt_object, opt_objectToExportTo) \{\par
    var parts = name.split('.');\par
    var cur = opt_objectToExportTo || window /* global */;\par
\par
    for (var part; parts.length && (part = parts.shift());) \{\par
      if (!parts.length && opt_object !== undefined) \{\par
        // last part and we have an object; use it\par
        cur[part] = opt_object;\par
      \} else if (part in cur) \{\par
        cur = cur[part];\par
      \} else \{\par
        cur = cur[part] = \{\};\par
      \}\par
    \}\par
    return cur;\par
  \};\par
\par
  // cr.Event is called CrEvent in here to prevent naming conflicts. We also\par
  // store the original Event in case someone does a global alias of cr.Event.\par
  const DomEvent = Event;\par
\par
  /**\par
   * Creates a new event to be used with cr.EventTarget or DOM EventTarget\par
   * objects.\par
   * @param \{string\} type The name of the event.\par
   * @param \{boolean=\} opt_bubbles Whether the event bubbles. Default is false.\par
   * @param \{boolean=\} opt_preventable Whether the default action of the event\par
   *     can be prevented.\par
   * @constructor\par
   * @extends \{DomEvent\}\par
   */\par
  function CrEvent(type, opt_bubbles, opt_preventable) \{\par
    var e = cr.doc.createEvent('Event');\par
    e.initEvent(type, !!opt_bubbles, !!opt_preventable);\par
    e.__proto__ = CrEvent.prototype;\par
    return e;\par
  \}\par
\par
  CrEvent.prototype = \{\par
    __proto__: DomEvent.prototype\par
  \};\par
\par
  /**\par
   * Fires a property change event on the target.\par
   * @param \{EventTarget\} target The target to dispatch the event on.\par
   * @param \{string\} propertyName The name of the property that changed.\par
   * @param \{*\} newValue The new value for the property.\par
   * @param \{*\} oldValue The old value for the property.\par
   */\par
  function dispatchPropertyChange(target, propertyName, newValue, oldValue) \{\par
    var e = new CrEvent(propertyName + 'Change');\par
    e.propertyName = propertyName;\par
    e.newValue = newValue;\par
    e.oldValue = oldValue;\par
    target.dispatchEvent(e);\par
  \}\par
\par
  /**\par
   * Converts a camelCase javascript property name to a hyphenated-lower-case\par
   * attribute name.\par
   * @param \{string\} jsName The javascript camelCase property name.\par
   * @return \{string\} The equivalent hyphenated-lower-case attribute name.\par
   */\par
  function getAttributeName(jsName) \{\par
    return jsName.replace(/([A-Z])/g, '-$1').toLowerCase();\par
  \}\par
\par
  /**\par
   * The kind of property to define in \{@code defineProperty\}.\par
   * @enum \{number\}\par
   */\par
  const PropertyKind = \{\par
    /**\par
     * Plain old JS property where the backing data is stored as a "private"\par
     * field on the object.\par
     */\par
    JS: 'js',\par
\par
    /**\par
     * The property backing data is stored as an attribute on an element.\par
     */\par
    ATTR: 'attr',\par
\par
    /**\par
     * The property backing data is stored as an attribute on an element. If the\par
     * element has the attribute then the value is true.\par
     */\par
    BOOL_ATTR: 'boolAttr'\par
  \};\par
\par
  /**\par
   * Helper function for defineProperty that returns the getter to use for the\par
   * property.\par
   * @param \{string\} name\par
   * @param \{cr.PropertyKind\} kind\par
   * @return \{function():*\} The getter for the property.\par
   */\par
  function getGetter(name, kind) \{\par
    switch (kind) \{\par
      case PropertyKind.JS:\par
        var privateName = name + '_';\par
        return function() \{\par
          return this[privateName];\par
        \};\par
      case PropertyKind.ATTR:\par
        var attributeName = getAttributeName(name);\par
        return function() \{\par
          return this.getAttribute(attributeName);\par
        \};\par
      case PropertyKind.BOOL_ATTR:\par
        var attributeName = getAttributeName(name);\par
        return function() \{\par
          return this.hasAttribute(attributeName);\par
        \};\par
    \}\par
  \}\par
\par
  /**\par
   * Helper function for defineProperty that returns the setter of the right\par
   * kind.\par
   * @param \{string\} name The name of the property we are defining the setter\par
   *     for.\par
   * @param \{cr.PropertyKind\} kind The kind of property we are getting the\par
   *     setter for.\par
   * @param \{function(*):void\} opt_setHook A function to run after the property\par
   *     is set, but before the propertyChange event is fired.\par
   * @return \{function(*):void\} The function to use as a setter.\par
   */\par
  function getSetter(name, kind, opt_setHook) \{\par
    switch (kind) \{\par
      case PropertyKind.JS:\par
        var privateName = name + '_';\par
        return function(value) \{\par
          var oldValue = this[privateName];\par
          if (value !== oldValue) \{\par
            this[privateName] = value;\par
            if (opt_setHook)\par
              opt_setHook.call(this, value, oldValue);\par
            dispatchPropertyChange(this, name, value, oldValue);\par
          \}\par
        \};\par
\par
      case PropertyKind.ATTR:\par
        var attributeName = getAttributeName(name);\par
        return function(value) \{\par
          var oldValue = this[attributeName];\par
          if (value !== oldValue) \{\par
            if (value == undefined)\par
              this.removeAttribute(attributeName);\par
            else\par
              this.setAttribute(attributeName, value);\par
            if (opt_setHook)\par
              opt_setHook.call(this, value, oldValue);\par
            dispatchPropertyChange(this, name, value, oldValue);\par
          \}\par
        \};\par
\par
      case PropertyKind.BOOL_ATTR:\par
        var attributeName = getAttributeName(name);\par
        return function(value) \{\par
          var oldValue = this[attributeName];\par
          if (value !== oldValue) \{\par
            if (value)\par
              this.setAttribute(attributeName, name);\par
            else\par
              this.removeAttribute(attributeName);\par
            if (opt_setHook)\par
              opt_setHook.call(this, value, oldValue);\par
            dispatchPropertyChange(this, name, value, oldValue);\par
          \}\par
        \};\par
    \}\par
  \}\par
\par
  /**\par
   * Defines a property on an object. When the setter changes the value a\par
   * property change event with the type \{@code name + 'Change'\} is fired.\par
   * @param \{!Object\} obj The object to define the property for.\par
   * @param \{string\} name The name of the property.\par
   * @param \{cr.PropertyKind=\} opt_kind What kind of underlying storage to use.\par
   * @param \{function(*):void\} opt_setHook A function to run after the\par
   *     property is set, but before the propertyChange event is fired.\par
   */\par
  function defineProperty(obj, name, opt_kind, opt_setHook) \{\par
    if (typeof obj == 'function')\par
      obj = obj.prototype;\par
\par
    var kind = opt_kind || PropertyKind.JS;\par
\par
    if (!obj.__lookupGetter__(name))\par
      obj.__defineGetter__(name, getGetter(name, kind));\par
\par
    if (!obj.__lookupSetter__(name))\par
      obj.__defineSetter__(name, getSetter(name, kind, opt_setHook));\par
  \}\par
\par
  /**\par
   * Counter for use with createUid\par
   */\par
  var uidCounter = 1;\par
\par
  /**\par
   * @return \{number\} A new unique ID.\par
   */\par
  function createUid() \{\par
    return uidCounter++;\par
  \}\par
\par
  /**\par
   * Returns a unique ID for the item. This mutates the item so it needs to be\par
   * an object\par
   * @param \{!Object\} item The item to get the unique ID for.\par
   * @return \{number\} The unique ID for the item.\par
   */\par
  function getUid(item) \{\par
    if (item.hasOwnProperty('uid'))\par
      return item.uid;\par
    return item.uid = createUid();\par
  \}\par
\par
  /**\par
   * Dispatches a simple event on an event target.\par
   * @param \{!EventTarget\} target The event target to dispatch the event on.\par
   * @param \{string\} type The type of the event.\par
   * @param \{boolean=\} opt_bubbles Whether the event bubbles or not.\par
   * @param \{boolean=\} opt_cancelable Whether the default action of the event\par
   *     can be prevented.\par
   * @return \{boolean\} If any of the listeners called \{@code preventDefault\}\par
   *     during the dispatch this will return false.\par
   */\par
  function dispatchSimpleEvent(target, type, opt_bubbles, opt_cancelable) \{\par
    var e = new cr.Event(type, opt_bubbles, opt_cancelable);\par
    return target.dispatchEvent(e);\par
  \}\par
\par
  /**\par
   * @param \{string\} name\par
   * @param \{!Function\} fun\par
   */\par
  function define(name, fun) \{\par
    var obj = exportPath(name);\par
    var exports = fun();\par
    for (var propertyName in exports) \{\par
      // Maybe we should check the prototype chain here? The current usage\par
      // pattern is always using an object literal so we only care about own\par
      // properties.\par
      var propertyDescriptor = Object.getOwnPropertyDescriptor(exports,\par
                                                               propertyName);\par
      if (propertyDescriptor)\par
        Object.defineProperty(obj, propertyName, propertyDescriptor);\par
    \}\par
  \}\par
\par
  /**\par
   * Document used for various document related operations.\par
   * @type \{!Document\}\par
   */\par
  var doc = document;\par
\par
\par
  /**\par
   * Allows you to run func in the context of a different document.\par
   * @param \{!Document\} document The document to use.\par
   * @param \{function():*\} func The function to call.\par
   */\par
  function withDoc(document, func) \{\par
    var oldDoc = doc;\par
    doc = document;\par
    try \{\par
      func();\par
    \} finally \{\par
      doc = oldDoc;\par
    \}\par
  \}\par
\par
  /**\par
   * Adds a \{@code getInstance\} static method that always return the same\par
   * instance object.\par
   * @param \{!Function\} ctor The constructor for the class to add the static\par
   *     method to.\par
   */\par
  function addSingletonGetter(ctor) \{\par
    ctor.getInstance = function() \{\par
      return ctor.instance_ || (ctor.instance_ = new ctor());\par
    \};\par
  \}\par
\par
  return \{\par
    addSingletonGetter: addSingletonGetter,\par
    isChromeOS: isChromeOS,\par
    isMac: isMac,\par
    isWindows: isWindows,\par
    isLinux: isLinux,\par
    isViews: isViews,\par
    isTouchOptimized: isTouchOptimized,\par
    enablePlatformSpecificCSSRules: enablePlatformSpecificCSSRules,\par
    define: define,\par
    defineProperty: defineProperty,\par
    PropertyKind: PropertyKind,\par
    createUid: createUid,\par
    getUid: getUid,\par
    dispatchSimpleEvent: dispatchSimpleEvent,\par
    dispatchPropertyChange: dispatchPropertyChange,\par
\par
    /**\par
     * The document that we are currently using.\par
     * @type \{!Document\}\par
     */\par
    get doc() \{\par
      return doc;\par
    \},\par
    withDoc: withDoc,\par
    Event: CrEvent\par
  \};\par
\})();\par
</script>\par
<script>// Copyright (c) 2010 The Chromium Authors. All rights reserved.\par
// Use of this source code is governed by a BSD-style license that can be\par
// found in the LICENSE file.\par
\par
cr.define('cr.ui', function() \{\par
\par
  /**\par
   * Decorates elements as an instance of a class.\par
   * @param \{string|!Element\} source The way to find the element(s) to decorate.\par
   *     If this is a string then \{@code querySeletorAll\} is used to find the\par
   *     elements to decorate.\par
   * @param \{!Function\} constr The constructor to decorate with. The constr\par
   *     needs to have a \{@code decorate\} function.\par
   */\par
  function decorate(source, constr) \{\par
    var elements;\par
    if (typeof source == 'string')\par
      elements = cr.doc.querySelectorAll(source);\par
    else\par
      elements = [source];\par
\par
    for (var i = 0, el; el = elements[i]; i++) \{\par
      if (!(el instanceof constr))\par
        constr.decorate(el);\par
    \}\par
  \}\par
\par
  /**\par
   * Helper function for creating new element for define.\par
   */\par
  function createElementHelper(tagName, opt_bag) \{\par
    // Allow passing in ownerDocument to create in a different document.\par
    var doc;\par
    if (opt_bag && opt_bag.ownerDocument)\par
      doc = opt_bag.ownerDocument;\par
    else\par
      doc = cr.doc;\par
    return doc.createElement(tagName);\par
  \}\par
\par
  /**\par
   * Creates the constructor for a UI element class.\par
   *\par
   * Usage:\par
   * <pre>\par
   * var List = cr.ui.define('list');\par
   * List.prototype = \{\par
   *   __proto__: HTMLUListElement.prototype,\par
   *   decorate: function() \{\par
   *     ...\par
   *   \},\par
   *   ...\par
   * \};\par
   * </pre>\par
   *\par
   * @param \{string|Function\} tagNameOrFunction The tagName or\par
   *     function to use for newly created elements. If this is a function it\par
   *     needs to return a new element when called.\par
   * @return \{function(Object=):Element\} The constructor function which takes\par
   *     an optional property bag. The function also has a static\par
   *     \{@code decorate\} method added to it.\par
   */\par
  function define(tagNameOrFunction) \{\par
    var createFunction, tagName;\par
    if (typeof tagNameOrFunction == 'function') \{\par
      createFunction = tagNameOrFunction;\par
      tagName = '';\par
    \} else \{\par
      createFunction = createElementHelper;\par
      tagName = tagNameOrFunction;\par
    \}\par
\par
    /**\par
     * Creates a new UI element constructor.\par
     * @param \{Object=\} opt_propertyBag Optional bag of properties to set on the\par
     *     object after created. The property \{@code ownerDocument\} is special\par
     *     cased and it allows you to create the element in a different\par
     *     document than the default.\par
     * @constructor\par
     */\par
    function f(opt_propertyBag) \{\par
      var el = createFunction(tagName, opt_propertyBag);\par
      f.decorate(el);\par
      for (var propertyName in opt_propertyBag) \{\par
        el[propertyName] = opt_propertyBag[propertyName];\par
      \}\par
      return el;\par
    \}\par
\par
    /**\par
     * Decorates an element as a UI element class.\par
     * @param \{!Element\} el The element to decorate.\par
     */\par
    f.decorate = function(el) \{\par
      el.__proto__ = f.prototype;\par
      el.decorate();\par
    \};\par
\par
    return f;\par
  \}\par
\par
  /**\par
   * Input elements do not grow and shrink with their content. This is a simple\par
   * (and not very efficient) way of handling shrinking to content with support\par
   * for min width and limited by the width of the parent element.\par
   * @param \{HTMLElement\} el The element to limit the width for.\par
   * @param \{number\} parentEl The parent element that should limit the size.\par
   * @param \{number\} min The minimum width.\par
   */\par
  function limitInputWidth(el, parentEl, min) \{\par
    // Needs a size larger than borders\par
    el.style.width = '10px';\par
    var doc = el.ownerDocument;\par
    var win = doc.defaultView;\par
    var computedStyle = win.getComputedStyle(el);\par
    var parentComputedStyle = win.getComputedStyle(parentEl);\par
    var rtl = computedStyle.direction == 'rtl';\par
\par
    // To get the max width we get the width of the treeItem minus the position\par
    // of the input.\par
    var inputRect = el.getBoundingClientRect();  // box-sizing\par
    var parentRect = parentEl.getBoundingClientRect();\par
    var startPos = rtl ? parentRect.right - inputRect.right :\par
        inputRect.left - parentRect.left;\par
\par
    // Add up border and padding of the input.\par
    var inner = parseInt(computedStyle.borderLeftWidth, 10) +\par
        parseInt(computedStyle.paddingLeft, 10) +\par
        parseInt(computedStyle.paddingRight, 10) +\par
        parseInt(computedStyle.borderRightWidth, 10);\par
\par
    // We also need to subtract the padding of parent to prevent it to overflow.\par
    var parentPadding = rtl ? parseInt(parentComputedStyle.paddingLeft, 10) :\par
        parseInt(parentComputedStyle.paddingRight, 10);\par
\par
    var max = parentEl.clientWidth - startPos - inner - parentPadding;\par
\par
    function limit() \{\par
      if (el.scrollWidth > max) \{\par
        el.style.width = max + 'px';\par
      \} else \{\par
        el.style.width = 0;\par
        var sw = el.scrollWidth;\par
        if (sw < min) \{\par
          el.style.width = min + 'px';\par
        \} else \{\par
          el.style.width = sw + 'px';\par
        \}\par
      \}\par
    \}\par
\par
    el.addEventListener('input', limit);\par
    limit();\par
  \}\par
\par
  return \{\par
    decorate: decorate,\par
    define: define,\par
    limitInputWidth: limitInputWidth\par
  \};\par
\});\par
</script>\par
<script>// Copyright (c) 2011 The Chromium Authors. All rights reserved.\par
// Use of this source code is governed by a BSD-style license that can be\par
// found in the LICENSE file.\par
\par
// require: event_tracker.js\par
\par
cr.define('cr.ui', function() \{\par
\par
  // The arrow location specifies how the arrow and bubble are positioned in\par
  // relation to the anchor node.\par
  const ArrowLocation = \{\par
    // The arrow is positioned at the top and the start of the bubble. In left\par
    // to right mode this is the top left. The entire bubble is positioned below\par
    // the anchor node.\par
    TOP_START : "top-start",\par
    // The arrow is positioned at the top and the end of the bubble. In left to\par
    // right mode this is the top right. The entire bubble is positioned below\par
    // the anchor node.\par
    TOP_END : "top-end",\par
    // The arrow is positioned at the bottom and the start of the bubble. In\par
    // left to right mode this is the bottom left. The entire bubble is\par
    // positioned above the anchor node.\par
    BOTTOM_START : "bottom-start",\par
    // The arrow is positioned at the bottom and the end of the bubble. In\par
    // left to right mode this is the bottom right. The entire bubble is\par
    // positioned above the anchor node.\par
    BOTTOM_END : "bottom-end"\par
  \};\par
\par
  // The bubble alignment specifies the horizontal position of the bubble in\par
  // relation to the anchor node.\par
  const BubbleAlignment = \{\par
    // The bubble is positioned so that the tip of the arrow points to the\par
    // middle of the anchor node.\par
    ARROW_TO_MID_ANCHOR : "arrow-to-mid-anchor",\par
    // The bubble is positioned so that the edge nearest to the arrow is lined\par
    // up with the edge of the anchor node.\par
    BUBBLE_EDGE_TO_ANCHOR_EDGE : "bubble-edge-anchor-edge"\par
  \};\par
\par
  // The horizontal distance between the tip of the arrow and the start or the\par
  // end of the bubble (as specified by the arrow location).\par
  const ARROW_OFFSET_X = 30;\par
\par
  // The vertical distance between the tip of the arrow and the bottom or top of\par
  // the bubble (as specified by the arrow location). Note, if you change this\par
  // then you should also change the "top" and "bottom" values for .bubble-arrow\par
  // in bubble.css.\par
  const ARROW_OFFSET_Y = 8;\par
\par
  /**\par
   * Bubble is a free-floating informational bubble with a triangular arrow\par
   * that points at a place of interest on the page.\par
   */\par
  var Bubble = cr.ui.define('div');\par
\par
  Bubble.prototype = \{\par
    __proto__: HTMLDivElement.prototype,\par
\par
    decorate: function() \{\par
      this.className = 'bubble';\par
      this.innerHTML =\par
          '<div class=\\"bubble-contents\\"></div>' +\par
          '<div class=\\"bubble-close\\"></div>' +\par
          '<div class=\\"bubble-shadow\\"></div>' +\par
          '<div class=\\"bubble-arrow\\"></div>';\par
\par
      this.hidden = true;\par
      this.handleCloseEvent = this.hide;\par
      this.deactivateToDismissDelay_ = 0;\par
      this.bubbleAlignment = BubbleAlignment.ARROW_TO_MID_ANCHOR;\par
    \},\par
\par
    /**\par
     * Sets the child node of the bubble.\par
     * @param \{node\} An HTML element\par
     */\par
    set content(node) \{\par
      var bubbleContent = this.querySelector('.bubble-contents');\par
      bubbleContent.innerHTML = "";\par
      bubbleContent.appendChild(node);\par
    \},\par
\par
    /**\par
     * Handles close event which is triggered when the close button\par
     * is clicked. By default is set to this.hide.\par
     * @param \{function\} A function with no parameters\par
     */\par
    set handleCloseEvent(func) \{\par
      this.handleCloseEvent_ = func;\par
    \},\par
\par
    /**\par
     * Sets the anchor node, i.e. the node that this bubble points at.\par
     * @param \{HTMLElement\} node The new anchor node.\par
     */\par
    set anchorNode(node) \{\par
      this.anchorNode_ = node;\par
\par
      if (!this.hidden)\par
        this.reposition();\par
    \},\par
\par
    /**\par
     * Sets the arrow location.\par
     * @param \{cr.ui.ArrowLocation\} arrowLocation The new arrow location.\par
     */\par
    setArrowLocation: function(arrowLocation) \{\par
      this.isRight_ = arrowLocation == ArrowLocation.TOP_END ||\par
                      arrowLocation == ArrowLocation.BOTTOM_END;\par
      if (document.documentElement.dir == 'rtl')\par
        this.isRight_ = !this.isRight_;\par
      this.isTop_ = arrowLocation == ArrowLocation.TOP_START ||\par
                    arrowLocation == ArrowLocation.TOP_END;\par
\par
      var bubbleArrow = this.querySelector('.bubble-arrow');\par
      bubbleArrow.setAttribute('is-right', this.isRight_);\par
      bubbleArrow.setAttribute('is-top', this.isTop_);\par
\par
      if (!this.hidden)\par
        this.reposition();\par
    \},\par
\par
    /**\par
     * Sets the bubble alignment.\par
     * @param \{cr.ui.BubbleAlignment\} alignment The new bubble alignment.\par
     */\par
    set bubbleAlignment(alignment) \{\par
      this.bubbleAlignment_ = alignment;\par
    \},\par
\par
    /**\par
     * Sets the delay before the user is allowed to click outside the bubble\par
     * to dismiss it. Using a delay makes it less likely that the user will\par
     * unintentionally dismiss the bubble.\par
     * @param \{int\} delay The delay in miliseconds.\par
     */\par
    set deactivateToDismissDelay(delay) \{\par
      this.deactivateToDismissDelay_ = delay;\par
    \},\par
\par
    /**\par
     * Hides or shows the close button.\par
     * @param \{Boolean\} isVisible True if the close button should be visible.\par
     */\par
    setCloseButtonVisible: function(isVisible) \{\par
      this.querySelector('.bubble-close').hidden = !isVisible;\par
    \},\par
\par
    /**\par
     * Updates the position of the bubble. This is automatically called when\par
     * the window is resized, but should also be called any time the layout\par
     * may have changed.\par
     */\par
    reposition: function() \{\par
      var clientRect = this.anchorNode_.getBoundingClientRect();\par
\par
      var left;\par
      if (this.bubbleAlignment_ ==\par
          BubbleAlignment.BUBBLE_EDGE_TO_ANCHOR_EDGE) \{\par
        left = this.isRight_ ? clientRect.right - this.clientWidth :\par
            clientRect.left;\par
      \} else \{\par
        var anchorMid = (clientRect.left + clientRect.right) / 2;\par
        left = this.isRight_ ? anchorMid - this.clientWidth + ARROW_OFFSET_X :\par
            anchorMid - ARROW_OFFSET_X;\par
      \}\par
      var top = this.isTop_ ? clientRect.bottom + ARROW_OFFSET_Y :\par
          clientRect.top - this.clientHeight - ARROW_OFFSET_Y;\par
\par
      this.style.left = left + 'px';\par
      this.style.top = top + 'px';\par
    \},\par
\par
    /**\par
     * Starts showing the bubble. The bubble will show until the user clicks\par
     * away or presses Escape.\par
     */\par
    show: function() \{\par
      if (!this.hidden)\par
        return;\par
\par
      document.body.appendChild(this);\par
      this.hidden = false;\par
      this.reposition();\par
      this.showTime_ = Date.now();\par
\par
      this.eventTracker_ = new EventTracker;\par
      this.eventTracker_.add(window, 'resize', this.reposition.bind(this));\par
\par
      var doc = this.ownerDocument;\par
      this.eventTracker_.add(doc, 'keydown', this, true);\par
      this.eventTracker_.add(doc, 'mousedown', this, true);\par
    \},\par
\par
    /**\par
     * Hides the bubble from view.\par
     */\par
    hide: function() \{\par
      this.hidden = true;\par
      this.eventTracker_.removeAll();\par
      this.parentNode.removeChild(this);\par
    \},\par
\par
    /**\par
     * Handles keydown and mousedown events, dismissing the bubble if\par
     * necessary.\par
     * @param \{Event\} e The event.\par
     */\par
    handleEvent: function(e) \{\par
      switch (e.type) \{\par
        case 'keydown': \{\par
          if (e.keyCode == 27)  // Esc\par
            this.hide();\par
          break;\par
        \}\par
        case 'mousedown': \{\par
          if (e.target == this.querySelector('.bubble-close')) \{\par
            this.handleCloseEvent_();\par
          \} else if (!this.contains(e.target)) \{\par
            if (Date.now() - this.showTime_ < this.deactivateToDismissDelay_)\par
              return;\par
            this.hide();\par
          \} else \{\par
            return;\par
          \}\par
          break;\par
        \}\par
      \}\par
    \},\par
  \};\par
\par
  return \{\par
    ArrowLocation : ArrowLocation,\par
    Bubble : Bubble,\par
    BubbleAlignment : BubbleAlignment\par
  \};\par
\});\par
</script>\par
<script>// Copyright (c) 2012 The Chromium Authors. All rights reserved.\par
// Use of this source code is governed by a BSD-style license that can be\par
// found in the LICENSE file.\par
\par
/**\par
 * @fileoverview Card slider implementation. Allows you to create interactions\par
 * that have items that can slide left to right to reveal additional items.\par
 * Works by adding the necessary event handlers to a specific DOM structure\par
 * including a frame, container and cards.\par
 * - The frame defines the boundary of one item. Each card will be expanded to\par
 *   fill the width of the frame. This element is also overflow hidden so that\par
 *   the additional items left / right do not trigger horizontal scrolling.\par
 * - The container is what all the touch events are attached to. This element\par
 *   will be expanded to be the width of all cards.\par
 * - The cards are the individual viewable items. There should be one card for\par
 *   each item in the list. Only one card will be visible at a time. Two cards\par
 *   will be visible while you are transitioning between cards.\par
 *\par
 * This class is designed to work well on any hardware-accelerated touch device.\par
 * It should still work on pre-hardware accelerated devices it just won't feel\par
 * very good. It should also work well with a mouse.\par
 */\par
\par
// Use an anonymous function to enable strict mode just for this file (which\par
// will be concatenated with other files when embedded in Chrome\par
cr.define('cr.ui', function() \{\par
  'use strict';\par
\par
  /**\par
   * @constructor\par
   * @param \{!Element\} frame The bounding rectangle that cards are visible in.\par
   * @param \{!Element\} container The surrounding element that will have event\par
   *     listeners attached to it.\par
   * @param \{number\} cardWidth The width of each card should have.\par
   */\par
  function CardSlider(frame, container, cardWidth) \{\par
    /**\par
     * @type \{!Element\}\par
     * @private\par
     */\par
    this.frame_ = frame;\par
\par
    /**\par
     * @type \{!Element\}\par
     * @private\par
     */\par
    this.container_ = container;\par
\par
    /**\par
     * Array of card elements.\par
     * @type \{!Array.<!Element>\}\par
     * @private\par
     */\par
    this.cards_ = [];\par
\par
    /**\par
     * Index of currently shown card.\par
     * @type \{number\}\par
     * @private\par
     */\par
    this.currentCard_ = -1;\par
\par
    /**\par
     * @type \{number\}\par
     * @private\par
     */\par
    this.cardWidth_ = cardWidth;\par
\par
    /**\par
     * @type \{!cr.ui.TouchHandler\}\par
     * @private\par
     */\par
    this.touchHandler_ = new cr.ui.TouchHandler(this.container_);\par
  \}\par
\par
\par
  /**\par
   * The time to transition between cards when animating. Measured in ms.\par
   * @type \{number\}\par
   * @private\par
   * @const\par
   */\par
  CardSlider.TRANSITION_TIME_ = 200;\par
\par
\par
  /**\par
   * The minimum velocity required to transition cards if they did not drag past\par
   * the halfway point between cards. Measured in pixels / ms.\par
   * @type \{number\}\par
   * @private\par
   * @const\par
   */\par
  CardSlider.TRANSITION_VELOCITY_THRESHOLD_ = 0.2;\par
\par
\par
  CardSlider.prototype = \{\par
    /**\par
     * The current left offset of the container relative to the frame.\par
     * @type \{number\}\par
     * @private\par
     */\par
    currentLeft_: 0,\par
\par
    /**\par
     * Initialize all elements and event handlers. Must call after construction\par
     * and before usage.\par
     */\par
    initialize: function() \{\par
      var view = this.container_.ownerDocument.defaultView;\par
      assert(view.getComputedStyle(this.container_).display == '-webkit-box',\par
          'Container should be display -webkit-box.');\par
      assert(view.getComputedStyle(this.frame_).overflow == 'hidden',\par
          'Frame should be overflow hidden.');\par
      assert(view.getComputedStyle(this.container_).position == 'static',\par
          'Container should be position static.');\par
\par
      this.updateCardWidths_();\par
\par
      this.mouseWheelScrollAmount_ = 0;\par
      this.mouseWheelCardSelected_ = false;\par
      this.mouseWheelIsContinuous_ = false;\par
      this.scrollClearTimeout_ = null;\par
      this.frame_.addEventListener('mousewheel',\par
                                   this.onMouseWheel_.bind(this));\par
      this.container_.addEventListener(\par
          'webkitTransitionEnd', this.onWebkitTransitionEnd_.bind(this));\par
\par
      // Also support touch events in case a touch screen happens to be\par
      // available.  Ideally we would support touch events whenever they\par
      // are fired, but for now restrict this extra code to when we know\par
      // we want to support touch input.\par
      if (cr.isTouchOptimized) \{\par
        var TouchHandler = cr.ui.TouchHandler;\par
        this.container_.addEventListener(TouchHandler.EventType.TOUCH_START,\par
                                         this.onTouchStart_.bind(this));\par
        this.container_.addEventListener(TouchHandler.EventType.DRAG_START,\par
                                         this.onDragStart_.bind(this));\par
        this.container_.addEventListener(TouchHandler.EventType.DRAG_MOVE,\par
                                         this.onDragMove_.bind(this));\par
        this.container_.addEventListener(TouchHandler.EventType.DRAG_END,\par
                                         this.onDragEnd_.bind(this));\par
\par
        this.touchHandler_.enable(/* opt_capture */ false);\par
      \}\par
    \},\par
\par
    /**\par
     * Use in cases where the width of the frame has changed in order to update\par
     * the width of cards. For example should be used when orientation changes\par
     * in full width sliders.\par
     * @param \{number\} newCardWidth Width all cards should have, in pixels.\par
     */\par
    resize: function(newCardWidth) \{\par
      if (newCardWidth != this.cardWidth_) \{\par
        this.cardWidth_ = newCardWidth;\par
\par
        this.updateCardWidths_();\par
\par
        // Must upate the transform on the container to show the correct card.\par
        this.transformToCurrentCard_();\par
      \}\par
    \},\par
\par
    /**\par
     * Sets the cards used. Can be called more than once to switch card sets.\par
     * @param \{!Array.<!Element>\} cards The individual viewable cards.\par
     * @param \{number\} index Index of the card to in the new set of cards to\par
     *     navigate to.\par
     */\par
    setCards: function(cards, index) \{\par
      assert(index >= 0 && index < cards.length,\par
          'Invalid index in CardSlider#setCards');\par
      this.cards_ = cards;\par
\par
      this.updateCardWidths_();\par
\par
      // Jump to the given card index.\par
      this.selectCard(index);\par
    \},\par
\par
    /**\par
     * Updates the width of each card.\par
     * @private\par
     */\par
    updateCardWidths_: function() \{\par
      for (var i = 0, card; card = this.cards_[i]; i++)\par
        card.style.width = this.cardWidth_ + 'px';\par
    \},\par
\par
    /**\par
     * Returns the index of the current card.\par
     * @return \{number\} index of the current card.\par
     */\par
    get currentCard() \{\par
      return this.currentCard_;\par
    \},\par
\par
    /**\par
     * Allows setting the current card index.\par
     * @param \{number\} index A new index to set the current index to.\par
     * @return \{number\} The new index after having been set.\par
     */\par
    set currentCard(index) \{\par
      return (this.currentCard_ = index);\par
    \},\par
\par
    /**\par
     * Returns the number of cards.\par
     * @return \{number\} number of cards.\par
     */\par
    get cardCount() \{\par
      return this.cards_.length;\par
    \},\par
\par
    /**\par
     * Returns the current card itself.\par
     * @return \{!Element\} the currently shown card.\par
     */\par
    get currentCardValue() \{\par
      return this.cards_[this.currentCard_];\par
    \},\par
\par
    /**\par
     * Handle horizontal scrolls to flip between pages.\par
     * @private\par
     */\par
    onMouseWheel_: function(e) \{\par
      if (e.wheelDeltaX == 0)\par
        return;\par
\par
      // Prevent OS X 10.7+ history swiping on the NTP.\par
      e.preventDefault();\par
\par
      // Continuous devices such as an Apple Touchpad or Apple MagicMouse will\par
      // send arbitrary delta values. Conversly, standard mousewheels will\par
      // send delta values in increments of 120.  (There is of course a small\par
      // chance we mistake a continuous device for a non-continuous device.\par
      // Unfortunately there isn't a better way to do this until real touch\par
      // events are available to desktop clients.)\par
      var DISCRETE_DELTA = 120;\par
      if (e.wheelDeltaX % DISCRETE_DELTA)\par
        this.mouseWheelIsContinuous_ = true;\par
\par
      if (this.mouseWheelIsContinuous_) \{\par
        // For continuous devices, detect a page swipe when the accumulated\par
        // delta matches a pre-defined threshhold.  After changing the page,\par
        // ignore wheel events for a short time before repeating this process.\par
        if (this.mouseWheelCardSelected_) return;\par
        this.mouseWheelScrollAmount_ += e.wheelDeltaX;\par
        if (Math.abs(this.mouseWheelScrollAmount_) >= 600) \{\par
          var pagesToScroll = this.mouseWheelScrollAmount_ > 0 ? 1 : -1;\par
          if (!isRTL())\par
            pagesToScroll *= -1;\par
          var newCardIndex = this.currentCard + pagesToScroll;\par
          newCardIndex = Math.min(this.cards_.length - 1,\par
                                  Math.max(0, newCardIndex));\par
          this.selectCard(newCardIndex, true);\par
          this.mouseWheelCardSelected_ = true;\par
        \}\par
      \} else \{\par
        // For discrete devices, consider each wheel tick a page change.\par
        var pagesToScroll = e.wheelDeltaX / DISCRETE_DELTA;\par
        if (!isRTL())\par
          pagesToScroll *= -1;\par
        var newCardIndex = this.currentCard + pagesToScroll;\par
        newCardIndex = Math.min(this.cards_.length - 1,\par
                                Math.max(0, newCardIndex));\par
        this.selectCard(newCardIndex, true);\par
      \}\par
\par
      // We got a mouse wheel event, so cancel any pending scroll wheel timeout.\par
      if (this.scrollClearTimeout_ != null)\par
        clearTimeout(this.scrollClearTimeout_);\par
      // If we didn't use up all the scroll, hold onto it for a little bit, but\par
      // drop it after a delay.\par
      if (this.mouseWheelScrollAmount_ != 0) \{\par
        this.scrollClearTimeout_ =\par
            setTimeout(this.clearMouseWheelScroll_.bind(this), 500);\par
      \}\par
    \},\par
\par
    /**\par
     * Resets the amount of horizontal scroll we've seen to 0. See\par
     * onMouseWheel_.\par
     * @private\par
     */\par
    clearMouseWheelScroll_: function() \{\par
      this.mouseWheelScrollAmount_ = 0;\par
      this.mouseWheelCardSelected_ = false;\par
    \},\par
\par
    /**\par
     * Handles the ends of -webkit-transitions on -webkit-transform (animated\par
     * card switches).\par
     * @param \{Event\} e The webkitTransitionEnd event.\par
     * @private\par
     */\par
    onWebkitTransitionEnd_: function(e) \{\par
      // Ignore irrelevant transitions that might bubble up.\par
      if (e.target !== this.container_ ||\par
          e.propertyName != '-webkit-transform') \{\par
        return;\par
      \}\par
      this.fireChangeEndedEvent_(true);\par
    \},\par
\par
    /**\par
     * Dispatches a simple event to tell subscribers we're done moving to the\par
     * newly selected card.\par
     * @param \{boolean\} wasAnimated whether or not the change was animated.\par
     * @private\par
     */\par
    fireChangeEndedEvent_: function(wasAnimated) \{\par
      var e = document.createEvent('Event');\par
      e.initEvent('cardSlider:card_change_ended', true, true);\par
      e.cardSlider = this;\par
      e.changedTo = this.currentCard_;\par
      e.wasAnimated = wasAnimated;\par
      this.container_.dispatchEvent(e);\par
    \},\par
\par
    /**\par
     * Add a card to the card slider at a particular index. If the card being\par
     * added is inserted in front of the current card, cardSlider.currentCard\par
     * will be adjusted accordingly (to current card + 1).\par
     * @param \{!Node\} card A card that will be added to the card slider.\par
     * @param \{number\} index An index at which the given |card| should be\par
     *     inserted. Must be positive and less than the number of cards.\par
     */\par
    addCardAtIndex: function(card, index) \{\par
      assert(card instanceof Node, '|card| isn\\'t a Node');\par
      this.assertValidIndex_(index);\par
      this.cards_ = Array.prototype.concat.call(\par
          this.cards_.slice(0, index), card, this.cards_.slice(index));\par
\par
      if (this.currentCard_ == -1)\par
        this.currentCard_ = 0;\par
      else if (index <= this.currentCard_)\par
        this.selectCard(this.currentCard_ + 1, false, true);\par
\par
      this.fireAddedEvent_(card, index);\par
    \},\par
\par
    /**\par
     * Append a card to the end of the list.\par
     * @param \{!Node\} card A card to add at the end of the card slider.\par
     */\par
    appendCard: function(card) \{\par
      assert(card instanceof Node, '|card| isn\\'t a Node');\par
      this.cards_.push(card);\par
      this.fireAddedEvent_(card, this.cards_.length - 1);\par
    \},\par
\par
    /**\par
     * Dispatches a simple event to tell interested subscribers that a card was\par
     * added to this card slider.\par
     * @param \{Node\} card The recently added card.\par
     * @param \{number\} index The position of the newly added card.\par
     * @private\par
     */\par
    fireAddedEvent_: function(card, index) \{\par
      this.assertValidIndex_(index);\par
      var e = document.createEvent('Event');\par
      e.initEvent('cardSlider:card_added', true, true);\par
      e.addedIndex = index;\par
      e.addedCard = card;\par
      this.container_.dispatchEvent(e);\par
    \},\par
\par
    /**\par
     * Removes a card by index from the card slider. If the card to be removed\par
     * is the current card or in front of the current card, the current card\par
     * will be updated (to current card - 1).\par
     * @param \{!Node\} card A card to be removed.\par
     */\par
    removeCard: function(card) \{\par
      assert(card instanceof Node, '|card| isn\\'t a Node');\par
      this.removeCardAtIndex(this.cards_.indexOf(card));\par
    \},\par
\par
    /**\par
     * Removes a card by index from the card slider. If the card to be removed\par
     * is the current card or in front of the current card, the current card\par
     * will be updated (to current card - 1).\par
     * @param \{number\} index The index of the tile that should be removed.\par
     */\par
    removeCardAtIndex: function(index) \{\par
      this.assertValidIndex_(index);\par
      var removed = this.cards_.splice(index, 1).pop();\par
\par
      if (this.cards_.length == 0)\par
        this.currentCard_ = -1;\par
      else if (index < this.currentCard_)\par
        this.selectCard(this.currentCard_ - 1, false, true);\par
\par
      this.fireRemovedEvent_(removed, index);\par
    \},\par
\par
    /**\par
     * Dispatches a cardSlider:card_removed event so interested subscribers know\par
     * when a card was removed from this card slider.\par
     * @param \{Node\} card The recently removed card.\par
     * @param \{number\} index The index of the card before it was removed.\par
     * @private\par
     */\par
    fireRemovedEvent_: function(card, index) \{\par
      var e = document.createEvent('Event');\par
      e.initEvent('cardSlider:card_removed', true, true);\par
      e.removedCard = card;\par
      e.removedIndex = index;\par
      this.container_.dispatchEvent(e);\par
    \},\par
\par
    /**\par
     * Checks the the given |index| exists in this.cards_.\par
     * @param \{number\} index An index to check.\par
     * @private\par
     */\par
    assertValidIndex_: function(index) \{\par
      assert(index >= 0 && index < this.cards_.length);\par
    \},\par
\par
    /**\par
     * Selects a new card, ensuring that it is a valid index, transforming the\par
     * view and possibly calling the change card callback.\par
     * @param \{number\} newCardIndex Index of card to show.\par
     * @param \{boolean=\} opt_animate If true will animate transition from\par
     *     current position to new position.\par
     * @param \{boolean=\} opt_dontNotify If true, don't tell subscribers that\par
     *     we've changed cards.\par
     */\par
    selectCard: function(newCardIndex, opt_animate, opt_dontNotify) \{\par
      this.assertValidIndex_(newCardIndex);\par
\par
      var previousCard = this.currentCardValue;\par
      var isChangingCard =\par
          !this.cards_[newCardIndex].classList.contains('selected-card');\par
\par
      if (isChangingCard) \{\par
        if (previousCard)\par
          previousCard.classList.remove('selected-card');\par
        this.currentCard_ = newCardIndex;\par
        this.currentCardValue.classList.add('selected-card');\par
      \}\par
\par
      var willTransitionHappen = this.transformToCurrentCard_(opt_animate);\par
\par
      if (isChangingCard && !opt_dontNotify) \{\par
        var event = document.createEvent('Event');\par
        event.initEvent('cardSlider:card_changed', true, true);\par
        event.cardSlider = this;\par
        event.wasAnimated = !!opt_animate;\par
        this.container_.dispatchEvent(event);\par
\par
        // We also dispatch an event on the cards themselves.\par
        if (previousCard) \{\par
          cr.dispatchSimpleEvent(previousCard, 'carddeselected',\par
                                 true, true);\par
        \}\par
        cr.dispatchSimpleEvent(this.currentCardValue, 'cardselected',\par
                               true, true);\par
      \}\par
\par
      // If we're not changing, animated, or transitioning, fire a\par
      // cardSlider:card_change_ended event right away.\par
      if ((!isChangingCard || !opt_animate || !willTransitionHappen) &&\par
          !opt_dontNotify) \{\par
        this.fireChangeEndedEvent_(false);\par
      \}\par
    \},\par
\par
    /**\par
     * Selects a card from the stack. Passes through to selectCard.\par
     * @param \{Node\} newCard The card that should be selected.\par
     * @param \{boolean=\} opt_animate Whether to animate.\par
     */\par
    selectCardByValue: function(newCard, opt_animate) \{\par
      var i = this.cards_.indexOf(newCard);\par
      assert(i != -1);\par
      this.selectCard(i, opt_animate);\par
    \},\par
\par
    /**\par
     * Centers the view on the card denoted by this.currentCard. Can either\par
     * animate to that card or snap to it.\par
     * @param \{boolean=\} opt_animate If true will animate transition from\par
     *     current position to new position.\par
     * @return \{boolean\} Whether or not a transformation was necessary.\par
     * @private\par
     */\par
    transformToCurrentCard_: function(opt_animate) \{\par
      var prevLeft = this.currentLeft_;\par
      this.currentLeft_ = -this.cardWidth_ *\par
          (isRTL() ? this.cards_.length - this.currentCard - 1 :\par
                     this.currentCard);\par
\par
      // If there's no change, return something to let the caller know there\par
      // won't be a transition occuring.\par
      if (prevLeft == this.currentLeft_)\par
        return false;\par
\par
      // Animate to the current card, which will either transition if the\par
      // current card is new, or reset the existing card if we didn't drag\par
      // enough to change cards.\par
      var transition = '';\par
      if (opt_animate) \{\par
        transition = '-webkit-transform ' + CardSlider.TRANSITION_TIME_ +\par
                     'ms ease-in-out';\par
      \}\par
      this.container_.style.WebkitTransition = transition;\par
      this.translateTo_(this.currentLeft_);\par
\par
      return true;\par
    \},\par
\par
    /**\par
     * Moves the view to the specified position.\par
     * @param \{number\} x Horizontal position to move to.\par
     * @private\par
     */\par
    translateTo_: function(x) \{\par
      // We use a webkitTransform to slide because this is GPU accelerated on\par
      // Chrome and iOS.  Once Chrome does GPU acceleration on the position\par
      // fixed-layout elements we could simply set the element's position to\par
      // fixed and modify 'left' instead.\par
      this.container_.style.WebkitTransform = 'translate3d(' + x + 'px, 0, 0)';\par
    \},\par
\par
    /* Touch ******************************************************************/\par
\par
    /**\par
     * Clear any transition that is in progress and enable dragging for the\par
     * touch.\par
     * @param \{!cr.ui.TouchHandler.Event\} e The TouchHandler event.\par
     * @private\par
     */\par
    onTouchStart_: function(e) \{\par
      this.container_.style.WebkitTransition = '';\par
      e.enableDrag = true;\par
    \},\par
\par
    /**\par
     * Tell the TouchHandler that dragging is acceptable when the user begins by\par
     * scrolling horizontally.\par
     * @param \{!cr.ui.TouchHandler.Event\} e The TouchHandler event.\par
     * @private\par
     */\par
    onDragStart_: function(e) \{\par
      e.enableDrag = Math.abs(e.dragDeltaX) > Math.abs(e.dragDeltaY);\par
    \},\par
\par
    /**\par
     * On each drag move event reposition the container appropriately so the\par
     * cards look like they are sliding.\par
     * @param \{!cr.ui.TouchHandler.Event\} e The TouchHandler event.\par
     * @private\par
     */\par
    onDragMove_: function(e) \{\par
      var deltaX = e.dragDeltaX;\par
      // If dragging beyond the first or last card then apply a backoff so the\par
      // dragging feels stickier than usual.\par
      if (!this.currentCard && deltaX > 0 ||\par
          this.currentCard == (this.cards_.length - 1) && deltaX < 0) \{\par
        deltaX /= 2;\par
      \}\par
      this.translateTo_(this.currentLeft_ + deltaX);\par
    \},\par
\par
    /**\par
     * On drag end events we may want to transition to another card, depending\par
     * on the ending position of the drag and the velocity of the drag.\par
     * @param \{!cr.ui.TouchHandler.Event\} e The TouchHandler event.\par
     * @private\par
     */\par
    onDragEnd_: function(e) \{\par
      var deltaX = e.dragDeltaX;\par
      var velocity = this.touchHandler_.getEndVelocity().x;\par
      var newX = this.currentLeft_ + deltaX;\par
      var newCardIndex = Math.round(-newX / this.cardWidth_);\par
\par
      if (newCardIndex == this.currentCard && Math.abs(velocity) >\par
          CardSlider.TRANSITION_VELOCITY_THRESHOLD_) \{\par
        // If the drag wasn't far enough to change cards but the velocity was\par
        // high enough to transition anyways. If the velocity is to the left\par
        // (negative) then the user wishes to go right (card +1).\par
        newCardIndex += velocity > 0 ? -1 : 1;\par
      \}\par
\par
      this.selectCard(newCardIndex, /* animate */ true);\par
    \},\par
\par
    /**\par
     * Cancel any current touch/slide as if we saw a touch end\par
     */\par
    cancelTouch: function() \{\par
      // Stop listening to any current touch\par
      this.touchHandler_.cancelTouch();\par
\par
      // Ensure we're at a card bounary\par
      this.transformToCurrentCard_(true);\par
    \},\par
  \};\par
\par
  return \{\par
    CardSlider: CardSlider\par
  \};\par
\});\par
</script>\par
<script>// Copyright (c) 2012 The Chromium Authors. All rights reserved.\par
// Use of this source code is governed by a BSD-style license that can be\par
// found in the LICENSE file.\par
\par
cr.define('cr.ui', function() \{\par
\par
  const Menu = cr.ui.Menu;\par
\par
  /**\par
   * Handles context menus.\par
   * @constructor\par
   */\par
  function ContextMenuHandler() \{\}\par
\par
  ContextMenuHandler.prototype = \{\par
\par
    /**\par
     * The menu that we are currently showing.\par
     * @type \{cr.ui.Menu\}\par
     */\par
    menu_: null,\par
    get menu() \{\par
      return this.menu_;\par
    \},\par
\par
    /**\par
     * Shows a menu as a context menu.\par
     * @param \{!Event\} e The event triggering the show (usally a contextmenu\par
     *     event).\par
     * @param \{!cr.ui.Menu\} menu The menu to show.\par
     */\par
    showMenu: function(e, menu) \{\par
      this.menu_ = menu;\par
\par
      menu.style.display = 'block';\par
      // when the menu is shown we steal all keyboard events.\par
      var doc = menu.ownerDocument;\par
      doc.addEventListener('keydown', this, true);\par
      doc.addEventListener('mousedown', this, true);\par
      doc.addEventListener('blur', this, true);\par
      doc.defaultView.addEventListener('resize', this);\par
      menu.addEventListener('contextmenu', this);\par
      menu.addEventListener('activate', this);\par
      this.positionMenu_(e, menu);\par
    \},\par
\par
    /**\par
     * Hide the currently shown menu.\par
     */\par
    hideMenu: function() \{\par
      var menu = this.menu;\par
      if (!menu)\par
        return;\par
\par
      menu.style.display = 'none';\par
      var doc = menu.ownerDocument;\par
      doc.removeEventListener('keydown', this, true);\par
      doc.removeEventListener('mousedown', this, true);\par
      doc.removeEventListener('blur', this, true);\par
      doc.defaultView.removeEventListener('resize', this);\par
      menu.removeEventListener('contextmenu', this);\par
      menu.removeEventListener('activate', this);\par
      menu.selectedIndex = -1;\par
      this.menu_ = null;\par
\par
      // On windows we might hide the menu in a right mouse button up and if\par
      // that is the case we wait some short period before we allow the menu\par
      // to be shown again.\par
      this.hideTimestamp_ = cr.isWindows ? Date.now() : 0;\par
    \},\par
\par
    /**\par
     * Positions the menu\par
     * @param \{!Event\} e The event object triggering the showing.\par
     * @param \{!cr.ui.Menu\} menu The menu to position.\par
     * @private\par
     */\par
    positionMenu_: function(e, menu) \{\par
      // TODO(arv): Handle scrolled documents when needed.\par
\par
      var element = e.currentTarget;\par
      var x, y;\par
      // When the user presses the context menu key (on the keyboard) we need\par
      // to detect this.\par
      if (this.keyIsDown_) \{\par
        var rect = element.getRectForContextMenu ?\par
                       element.getRectForContextMenu() :\par
                       element.getBoundingClientRect();\par
        var offset = Math.min(rect.width, rect.height) / 2;\par
        x = rect.left + offset;\par
        y = rect.top + offset;\par
      \} else \{\par
        x = e.clientX;\par
        y = e.clientY;\par
      \}\par
\par
      cr.ui.positionPopupAtPoint(x, y, menu);\par
    \},\par
\par
    /**\par
     * Handles event callbacks.\par
     * @param \{!Event\} e The event object.\par
     */\par
    handleEvent: function(e) \{\par
      // Keep track of keydown state so that we can use that to determine the\par
      // reason for the contextmenu event.\par
      switch (e.type) \{\par
        case 'keydown':\par
          this.keyIsDown_ = !e.ctrlKey && !e.altKey &&\par
              // context menu key or Shift-F10\par
              (e.keyCode == 93 && !e.shiftKey ||\par
               e.keyIdentifier == 'F10' && e.shiftKey);\par
          break;\par
\par
        case 'keyup':\par
          this.keyIsDown_ = false;\par
          break;\par
      \}\par
\par
      // Context menu is handled even when we have no menu.\par
      if (e.type != 'contextmenu' && !this.menu)\par
        return;\par
\par
      switch (e.type) \{\par
        case 'mousedown':\par
          if (!this.menu.contains(e.target))\par
            this.hideMenu();\par
          else\par
            e.preventDefault();\par
          break;\par
        case 'keydown':\par
          // keyIdentifier does not report 'Esc' correctly\par
          if (e.keyCode == 27 /* Esc */) \{\par
            this.hideMenu();\par
            e.stopPropagation();\par
            e.preventDefault();\par
\par
          // If the menu is visible we let it handle all the keyboard events.\par
          \} else if (this.menu) \{\par
            this.menu.handleKeyDown(e);\par
            e.preventDefault();\par
            e.stopPropagation();\par
          \}\par
          break;\par
\par
        case 'activate':\par
        case 'blur':\par
        case 'resize':\par
          this.hideMenu();\par
          break;\par
\par
        case 'contextmenu':\par
          if ((!this.menu || !this.menu.contains(e.target)) &&\par
              (!this.hideTimestamp_ || Date.now() - this.hideTimestamp_ > 50))\par
            this.showMenu(e, e.currentTarget.contextMenu);\par
          e.preventDefault();\par
          // Don't allow elements further up in the DOM to show their menus.\par
          e.stopPropagation();\par
          break;\par
      \}\par
    \},\par
\par
    /**\par
     * Adds a contextMenu property to an element or element class.\par
     * @param \{!Element|!Function\} element The element or class to add the\par
     *     contextMenu property to.\par
     */\par
    addContextMenuProperty: function(element) \{\par
      if (typeof element == 'function')\par
        element = element.prototype;\par
\par
      element.__defineGetter__('contextMenu', function() \{\par
        return this.contextMenu_;\par
      \});\par
      element.__defineSetter__('contextMenu', function(menu) \{\par
        var oldContextMenu = this.contextMenu;\par
\par
        if (typeof menu == 'string' && menu[0] == '#') \{\par
          menu = this.ownerDocument.getElementById(menu.slice(1));\par
          cr.ui.decorate(menu, Menu);\par
        \}\par
\par
        if (menu === oldContextMenu)\par
          return;\par
\par
        if (oldContextMenu && !menu) \{\par
          this.removeEventListener('contextmenu', contextMenuHandler);\par
          this.removeEventListener('keydown', contextMenuHandler);\par
          this.removeEventListener('keyup', contextMenuHandler);\par
        \}\par
        if (menu && !oldContextMenu) \{\par
          this.addEventListener('contextmenu', contextMenuHandler);\par
          this.addEventListener('keydown', contextMenuHandler);\par
          this.addEventListener('keyup', contextMenuHandler);\par
        \}\par
\par
        this.contextMenu_ = menu;\par
\par
        if (menu && menu.id)\par
          this.setAttribute('contextmenu', '#' + menu.id);\par
\par
        cr.dispatchPropertyChange(this, 'contextMenu', menu, oldContextMenu);\par
      \});\par
\par
      if (!element.getRectForContextMenu) \{\par
        /**\par
         * @return \{!ClientRect\} The rect to use for positioning the context\par
         *     menu when the context menu is not opened using a mouse position.\par
         */\par
        element.getRectForContextMenu = function() \{\par
          return this.getBoundingClientRect();\par
        \};\par
      \}\par
    \},\par
\par
    /**\par
     * Sets the given contextMenu to the given element. A contextMenu property\par
     * would be added if necessary.\par
     * @param \{!Element\} element The element or class to set the contextMenu to.\par
     * @param \{!cr.ui.Menu\} contextMenu The contextMenu property to be set.\par
     */\par
    setContextMenu: function(element, contextMenu) \{\par
      if (!element.contextMenu)\par
        this.addContextMenuProperty(element);\par
      element.contextMenu = contextMenu;\par
    \}\par
  \};\par
\par
  /**\par
   * The singleton context menu handler.\par
   * @type \{!ContextMenuHandler\}\par
   */\par
  var contextMenuHandler = new ContextMenuHandler;\par
\par
  // Export\par
  return \{\par
    contextMenuHandler: contextMenuHandler\par
  \};\par
\});\par
</script>\par
<script>// Copyright (c) 2011 The Chromium Authors. All rights reserved.\par
// Use of this source code is governed by a BSD-style license that can be\par
// found in the LICENSE file.\par
\par
/**\par
 * @fileoverview DragWrapper\par
 * A class for simplifying HTML5 drag and drop. Classes should use this to\par
 * handle the nitty gritty of nested drag enters and leaves.\par
 */\par
cr.define('cr.ui', function() \{\par
  /**\par
   * Creates a DragWrapper which listens for drag target events on |target| and\par
   * delegates event handling to |handler|. The |handler| must implement:\par
   *   shouldAcceptDrag\par
   *   doDragEnter\par
   *   doDragLeave\par
   *   doDragOver\par
   *   doDrop\par
   */\par
  function DragWrapper(target, handler) \{\par
    this.initialize(target, handler);\par
  \}\par
\par
  DragWrapper.prototype = \{\par
    initialize: function(target, handler) \{\par
      target.addEventListener('dragenter',\par
                              this.onDragEnter_.bind(this));\par
      target.addEventListener('dragover', this.onDragOver_.bind(this));\par
      target.addEventListener('drop', this.onDrop_.bind(this));\par
      target.addEventListener('dragleave', this.onDragLeave_.bind(this));\par
\par
      this.target_ = target;\par
      this.handler_ = handler;\par
    \},\par
\par
    /**\par
     * The number of un-paired dragenter events that have fired on |this|. This\par
     * is incremented by |onDragEnter_| and decremented by |onDragLeave_|. This\par
     * is necessary because dragging over child widgets will fire additional\par
     * enter and leave events on |this|. A non-zero value does not necessarily\par
     * indicate that |isCurrentDragTarget()| is true.\par
     * @type \{number\}\par
     * @private\par
     */\par
    dragEnters_: 0,\par
\par
    /**\par
     * Whether the tile page is currently being dragged over with data it can\par
     * accept.\par
     * @type \{boolean\}\par
     */\par
    get isCurrentDragTarget() \{\par
      return this.target_.classList.contains('drag-target');\par
    \},\par
\par
    /**\par
     * Handler for dragenter events fired on |target_|.\par
     * @param \{Event\} e A MouseEvent for the drag.\par
     * @private\par
     */\par
    onDragEnter_: function(e) \{\par
      if (++this.dragEnters_ == 1) \{\par
        if (this.handler_.shouldAcceptDrag(e)) \{\par
          this.target_.classList.add('drag-target');\par
          this.handler_.doDragEnter(e);\par
        \}\par
      \} else \{\par
        // Sometimes we'll get an enter event over a child element without an\par
        // over event following it. In this case we have to still call the\par
        // drag over handler so that we make the necessary updates (one visible\par
        // symptom of not doing this is that the cursor's drag state will\par
        // flicker during drags).\par
        this.onDragOver_(e);\par
      \}\par
    \},\par
\par
    /**\par
     * Thunk for dragover events fired on |target_|.\par
     * @param \{Event\} e A MouseEvent for the drag.\par
     * @private\par
     */\par
    onDragOver_: function(e) \{\par
      if (!this.target_.classList.contains('drag-target'))\par
        return;\par
      this.handler_.doDragOver(e);\par
    \},\par
\par
    /**\par
     * Thunk for drop events fired on |target_|.\par
     * @param \{Event\} e A MouseEvent for the drag.\par
     * @private\par
     */\par
    onDrop_: function(e) \{\par
      this.dragEnters_ = 0;\par
      if (!this.target_.classList.contains('drag-target'))\par
        return;\par
      this.target_.classList.remove('drag-target');\par
      this.handler_.doDrop(e);\par
    \},\par
\par
    /**\par
     * Thunk for dragleave events fired on |target_|.\par
     * @param \{Event\} e A MouseEvent for the drag.\par
     * @private\par
     */\par
    onDragLeave_: function(e) \{\par
      if (--this.dragEnters_ > 0)\par
        return;\par
\par
      this.target_.classList.remove('drag-target');\par
      this.handler_.doDragLeave(e);\par
    \},\par
  \};\par
\par
  return \{\par
    DragWrapper: DragWrapper\par
  \};\par
\});\par
</script>\par
<script>// Copyright (c) 2012 The Chromium Authors. All rights reserved.\par
// Use of this source code is governed by a BSD-style license that can be\par
// found in the LICENSE file.\par
\par
// require: event_tracker.js\par
\par
cr.define('cr.ui', function() \{\par
  'use strict';\par
\par
  /**\par
   * ExpandableBubble is a free-floating compact informational bubble with an\par
   * arrow that points at a place of interest on the page. When clicked, the\par
   * bubble expands to show more of its content. Width of the bubble is the\par
   * width of the node it is overlapping when unexpanded. Expanded, it is of a\par
   * fixed width, but variable height. Currently the arrow is always positioned\par
   * at the bottom right and points down.\par
   * @constructor\par
   * @extends \{cr.ui.div\}\par
   */\par
  var ExpandableBubble = cr.ui.define('div');\par
\par
  ExpandableBubble.prototype = \{\par
    __proto__: HTMLDivElement.prototype,\par
\par
    /** @inheritDoc */\par
    decorate: function() \{\par
      this.className = 'expandable-bubble';\par
      this.innerHTML =\par
          '<div class="expandable-bubble-contents">' +\par
            '<div class="expandable-bubble-title"></div>' +\par
            '<div class="expandable-bubble-main" hidden></div>' +\par
          '</div>' +\par
          '<div class="expandable-bubble-close" hidden></div>';\par
\par
      this.hidden = true;\par
      this.bubbleSuppressed = false;\par
      this.handleCloseEvent = this.hide;\par
    \},\par
\par
    /**\par
     * Sets the title of the bubble. The title is always visible when the\par
     * bubble is visible.\par
     * @type \{Node\} An HTML element to set as the title.\par
     */\par
    set contentTitle(node) \{\par
      var bubbleTitle = this.querySelector('.expandable-bubble-title');\par
      bubbleTitle.textContent = '';\par
      bubbleTitle.appendChild(node);\par
    \},\par
\par
    /**\par
     * Sets the content node of the bubble. The content node is only visible\par
     * when the bubble is expanded.\par
     * @param \{Node\} An HTML element.\par
     */\par
    set content(node) \{\par
      var bubbleMain = this.querySelector('.expandable-bubble-main');\par
      bubbleMain.textContent = '';\par
      bubbleMain.appendChild(node);\par
    \},\par
\par
    /**\par
     * Sets the anchor node, i.e. the node that this bubble points at and\par
     * partially overlaps.\par
     * @param \{HTMLElement\} node The new anchor node.\par
     */\par
    set anchorNode(node) \{\par
      this.anchorNode_ = node;\par
\par
      if (!this.hidden)\par
        this.resizeAndReposition();\par
    \},\par
\par
    /**\par
     * Handles the close event which is triggered when the close button\par
     * is clicked. By default is set to this.hide.\par
     * @param \{function\} A function with no parameters\par
     */\par
    set handleCloseEvent(func) \{\par
      this.handleCloseEvent_ = func;\par
    \},\par
\par
    /**\par
     * Temporarily suppresses the bubble from view (and toggles it back).\par
     * 'Suppressed' and 'hidden' are two bubble states that both indicate that\par
     * the bubble should not be visible, but when you 'un-suppress' a bubble,\par
     * only a suppressed bubble becomes visible. This can be handy, for example,\par
     * if the user switches away from the app card (then we need to know which\par
     * bubbles to show (only the suppressed ones, not the hidden ones). Hiding\par
     * and un-hiding a bubble overrides the suppressed state (a bubble cannot\par
     * be suppressed but not hidden).\par
     */\par
    set suppressed(suppress) \{\par
      if (suppress) \{\par
        // If the bubble is already hidden, then we don't need to suppress it.\par
        if (this.hidden)\par
          return;\par
\par
        this.hidden = true;\par
      \} else if (this.bubbleSuppressed) \{\par
        this.hidden = false;\par
      \}\par
      this.bubbleSuppressed = suppress;\par
      this.resizeAndReposition(this);\par
    \},\par
\par
    /**\par
     * Updates the position of the bubble.\par
     * @private\par
     */\par
    reposition_: function() \{\par
      var clientRect = this.anchorNode_.getBoundingClientRect();\par
\par
      // Center bubble in collapsed mode (if it doesn't take up all the room we\par
      // have).\par
      var offset = 0;\par
      if (!this.expanded)\par
        offset = (clientRect.width - parseInt(this.style.width)) / 2;\par
      this.style.left = this.style.right = clientRect.left + offset + 'px';\par
\par
      var top = Math.max(0, clientRect.top - 4);\par
      this.style.top = this.expanded ?\par
          (top - this.offsetHeight + this.unexpandedHeight) + 'px' :\par
          top + 'px';\par
    \},\par
\par
    /**\par
     * Resizes the bubble and then repositions it.\par
     * @private\par
     */\par
    resizeAndReposition: function() \{\par
      var clientRect = this.anchorNode_.getBoundingClientRect();\par
      var width = clientRect.width;\par
\par
      var bubbleTitle = this.querySelector('.expandable-bubble-title');\par
      var closeElement = this.querySelector('.expandable-bubble-close');\par
      var closeWidth = this.expanded ? closeElement.clientWidth : 0;\par
      var margin = 15;\par
\par
      // Suppress the width style so we can get it to calculate its width.\par
      // We'll set the right width again when we are done.\par
      bubbleTitle.style.width = '';\par
\par
      if (this.expanded) \{\par
        // We always show the full title but never show less width than 250\par
        // pixels.\par
        var expandedWidth =\par
            Math.max(250, bubbleTitle.scrollWidth + closeWidth + margin);\par
        this.style.marginLeft = (width - expandedWidth) + 'px';\par
        width = expandedWidth;\par
      \} else \{\par
        var newWidth = Math.min(bubbleTitle.scrollWidth + margin, width);\par
        // If we've maxed out in width then apply the mask.\par
        this.masked = newWidth == width;\par
        width = newWidth;\par
        this.style.marginLeft = '0';\par
      \}\par
\par
      // Width is determined by the width of the title (when not expanded) but\par
      // capped to the width of the anchor node.\par
      this.style.width = width + 'px';\par
      bubbleTitle.style.width = Math.max(0, width - margin - closeWidth) + 'px';\par
\par
      // Also reposition the bubble -- dimensions have potentially changed.\par
      this.reposition_();\par
    \},\par
\par
    /*\par
     * Expand the bubble (bringing the full content into view).\par
     * @private\par
     */\par
    expandBubble_: function() \{\par
      this.querySelector('.expandable-bubble-main').hidden = false;\par
      this.querySelector('.expandable-bubble-close').hidden = false;\par
      this.expanded = true;\par
      this.resizeAndReposition();\par
    \},\par
\par
    /**\par
     * Collapse the bubble, hiding the main content and the close button.\par
     * This is automatically called when the window is resized.\par
     * @private\par
     */\par
    collapseBubble_: function() \{\par
      this.querySelector('.expandable-bubble-main').hidden = true;\par
      this.querySelector('.expandable-bubble-close').hidden = true;\par
      this.expanded = false;\par
      this.resizeAndReposition();\par
    \},\par
\par
    /**\par
     * The onclick handler for the notification (expands the bubble).\par
     * @param \{Event\} e The event.\par
     * @private\par
     */\par
    onNotificationClick_ : function(e) \{\par
      if (!this.contains(e.target))\par
        return;\par
\par
      if (!this.expanded) \{\par
        // Save the height of the unexpanded bubble, so we can make sure to\par
        // position it correctly (arrow points in the same location) after\par
        // we expand it.\par
        this.unexpandedHeight = this.offsetHeight;\par
      \}\par
\par
      this.expandBubble_();\par
    \},\par
\par
    /**\par
     * Shows the bubble. The bubble will start collapsed and expand when\par
     * clicked.\par
     */\par
    show: function() \{\par
      if (!this.hidden)\par
        return;\par
\par
      document.body.appendChild(this);\par
      this.hidden = false;\par
      this.resizeAndReposition();\par
\par
      this.eventTracker_ = new EventTracker;\par
      this.eventTracker_.add(window,\par
                             'load', this.resizeAndReposition.bind(this));\par
      this.eventTracker_.add(window,\par
                             'resize', this.resizeAndReposition.bind(this));\par
      this.eventTracker_.add(this, 'click', this.onNotificationClick_);\par
\par
      var doc = this.ownerDocument;\par
      this.eventTracker_.add(doc, 'keydown', this, true);\par
      this.eventTracker_.add(doc, 'mousedown', this, true);\par
    \},\par
\par
    /**\par
     * Hides the bubble from view.\par
     */\par
    hide: function() \{\par
      this.hidden = true;\par
      this.bubbleSuppressed = false;\par
      this.eventTracker_.removeAll();\par
      this.parentNode.removeChild(this);\par
    \},\par
\par
    /**\par
     * Handles keydown and mousedown events, dismissing the bubble if\par
     * necessary.\par
     * @param \{Event\} e The event.\par
     * @private\par
     */\par
    handleEvent: function(e) \{\par
      var handled = false;\par
      switch (e.type) \{\par
        case 'keydown':\par
          if (e.keyCode == 27) \{  // Esc.\par
            if (this.expanded) \{\par
              this.collapseBubble_();\par
              handled = true;\par
            \}\par
          \}\par
          break;\par
\par
        case 'mousedown':\par
          if (e.target == this.querySelector('.expandable-bubble-close')) \{\par
            this.handleCloseEvent_();\par
            handled = true;\par
          \} else if (!this.contains(e.target)) \{\par
            if (this.expanded) \{\par
              this.collapseBubble_();\par
              handled = true;\par
            \}\par
          \}\par
          break;\par
      \}\par
\par
      if (handled) \{\par
        // The bubble emulates a focus grab when expanded, so when we've\par
        // collapsed/hide the bubble we consider the event handles and don't\par
        // need to propagate it further.\par
        e.stopPropagation();\par
        e.preventDefault();\par
      \}\par
    \},\par
  \};\par
\par
  /**\par
   * Whether the bubble is expanded or not.\par
   * @type \{boolean\}\par
   */\par
  cr.defineProperty(ExpandableBubble, 'expanded', cr.PropertyKind.BOOL_ATTR);\par
\par
  /**\par
   * Whether the title needs to be masked out towards the right, which indicates\par
   * to the user that part of the text is clipped. This is only used when the\par
   * bubble is collapsed and the title doesn't fit because it is maxed out in\par
   * width within the anchored node.\par
   * @type \{boolean\}\par
   */\par
  cr.defineProperty(ExpandableBubble, 'masked', cr.PropertyKind.BOOL_ATTR);\par
\par
  return \{\par
    ExpandableBubble: ExpandableBubble\par
  \};\par
\});\par
</script>\par
<script>// Copyright (c) 2010 The Chromium Authors. All rights reserved.\par
// Use of this source code is governed by a BSD-style license that can be\par
// found in the LICENSE file.\par
\par
cr.define('cr.ui', function() \{\par
\par
  const MenuItem = cr.ui.MenuItem;\par
\par
  /**\par
   * Creates a new menu element.\par
   * @param \{Object=\} opt_propertyBag Optional properties.\par
   * @constructor\par
   * @extends \{HTMLMenuElement\}\par
   */\par
  var Menu = cr.ui.define('menu');\par
\par
  Menu.prototype = \{\par
    __proto__: HTMLMenuElement.prototype,\par
\par
    selectedIndex_: -1,\par
\par
    /**\par
     * Initializes the menu element.\par
     */\par
    decorate: function() \{\par
      this.addEventListener('mouseover', this.handleMouseOver_);\par
      this.addEventListener('mouseout', this.handleMouseOut_);\par
\par
      // Decorate the children as menu items.\par
      var children = this.children;\par
      for (var i = 0, child; child = children[i]; i++) \{\par
        cr.ui.decorate(child, MenuItem);\par
      \}\par
    \},\par
\par
    /**\par
     * Walks up the ancestors until a menu item belonging to this menu is found.\par
     * @param \{Element\} el\par
     * @return \{cr.ui.MenuItem\} The found menu item or null.\par
     * @private\par
     */\par
    findMenuItem_: function(el) \{\par
      while (el && el.parentNode != this) \{\par
        el = el.parentNode;\par
      \}\par
      return el;\par
    \},\par
\par
    /**\par
     * Handles mouseover events and selects the hovered item.\par
     * @param \{Event\} e The mouseover event.\par
     * @private\par
     */\par
    handleMouseOver_: function(e) \{\par
      var overItem = this.findMenuItem_(e.target);\par
      this.selectedItem = overItem;\par
    \},\par
\par
    /**\par
     * Handles mouseout events and deselects any selected item.\par
     * @param \{Event\} e The mouseout event.\par
     * @private\par
     */\par
    handleMouseOut_: function(e) \{\par
      this.selectedItem = null;\par
    \},\par
\par
    /**\par
     * The selected menu item or null if none.\par
     * @type \{cr.ui.MenuItem\}\par
     */\par
    get selectedItem() \{\par
      return this.children[this.selectedIndex];\par
    \},\par
    set selectedItem(item) \{\par
      var index = Array.prototype.indexOf.call(this.children, item);\par
      this.selectedIndex = index;\par
    \},\par
\par
    /**\par
     * This is the function that handles keyboard navigation. This is usually\par
     * called by the element responsible for managing the menu.\par
     * @param \{Event\} e The keydown event object.\par
     * @return \{boolean\} Whether the event was handled be the menu.\par
     */\par
    handleKeyDown: function(e) \{\par
      var item = this.selectedItem;\par
\par
      var self = this;\par
      function selectNextVisible(m) \{\par
        var children = self.children;\par
        var len = children.length;\par
        var i = self.selectedIndex;\par
        if (i == -1 && m == -1) \{\par
          // Edge case when we need to go the last item fisrt.\par
          i = 0;\par
        \}\par
        while (true) \{\par
          i = (i + m + len) % len;\par
          item = children[i];\par
          if (item && !item.isSeparator() && !item.hidden)\par
            break;\par
        \}\par
        if (item)\par
          self.selectedIndex = i;\par
      \}\par
\par
      switch (e.keyIdentifier) \{\par
        case 'Down':\par
          selectNextVisible(1);\par
          return true;\par
        case 'Up':\par
          selectNextVisible(-1);\par
          return true;\par
        case 'Enter':\par
        case 'U+0020': // Space\par
          if (item) \{\par
            if (cr.dispatchSimpleEvent(item, 'activate', true, true)) \{\par
              if (item.command)\par
                item.command.execute();\par
            \}\par
          \}\par
          return true;\par
      \}\par
\par
      return false;\par
    \}\par
  \};\par
\par
  function selectedIndexChanged(selectedIndex, oldSelectedIndex) \{\par
    var oldSelectedItem = this.children[oldSelectedIndex];\par
    if (oldSelectedItem)\par
      oldSelectedItem.selected = false;\par
    var item = this.selectedItem;\par
    if (item)\par
      item.selected = true;\par
  \}\par
  /**\par
   * The selected menu item.\par
   * @type \{number\}\par
   */\par
  cr.defineProperty(Menu, 'selectedIndex', cr.PropertyKind.JS,\par
      selectedIndexChanged);\par
\par
  // Export\par
  return \{\par
    Menu: Menu\par
  \};\par
\});\par
</script>\par
<script>// Copyright (c) 2011 The Chromium Authors. All rights reserved.\par
// Use of this source code is governed by a BSD-style license that can be\par
// found in the LICENSE file.\par
\par
cr.define('cr.ui', function() \{\par
  const Command = cr.ui.Command;\par
\par
  /**\par
   * Creates a new menu item element.\par
   * @param \{Object=\} opt_propertyBag Optional properties.\par
   * @constructor\par
   * @extends \{HTMLDivElement\}\par
   */\par
  var MenuItem = cr.ui.define('div');\par
\par
  /**\par
   * Creates a new menu separator element.\par
   * @return \{cr.ui.MenuItem\}\par
   */\par
  MenuItem.createSeparator = function() \{\par
    var el = cr.doc.createElement('hr');\par
    MenuItem.decorate(el);\par
    return el;\par
  \};\par
\par
  MenuItem.prototype = \{\par
    __proto__: HTMLButtonElement.prototype,\par
\par
    /**\par
     * Initializes the menu item.\par
     */\par
    decorate: function() \{\par
      var commandId;\par
      if ((commandId = this.getAttribute('command')))\par
        this.command = commandId;\par
\par
      this.addEventListener('mouseup', this.handleMouseUp_);\par
\par
      // Adding the 'custom-appearance' class prevents button.css from changing\par
      // the appearance of this element.\par
      this.classList.add('custom-appearance');\par
    \},\par
\par
    /**\par
     * The command associated with this menu item. If this is set to a string\par
     * of the form "#element-id" then the element is looked up in the document\par
     * of the command.\par
     * @type \{cr.ui.Command\}\par
     */\par
    command_: null,\par
    get command() \{\par
      return this.command_;\par
    \},\par
    set command(command) \{\par
      if (this.command_) \{\par
        this.command_.removeEventListener('labelChange', this);\par
        this.command_.removeEventListener('disabledChange', this);\par
        this.command_.removeEventListener('hiddenChange', this);\par
        this.command_.removeEventListener('checkedChange', this);\par
      \}\par
\par
      if (typeof command == 'string' && command[0] == '#') \{\par
        command = this.ownerDocument.getElementById(command.slice(1));\par
        cr.ui.decorate(command, Command);\par
      \}\par
\par
      this.command_ = command;\par
      if (command) \{\par
        if (command.id)\par
          this.setAttribute('command', '#' + command.id);\par
\par
        this.label = command.label;\par
        this.disabled = command.disabled;\par
        this.hidden = command.hidden;\par
\par
        this.command_.addEventListener('labelChange', this);\par
        this.command_.addEventListener('disabledChange', this);\par
        this.command_.addEventListener('hiddenChange', this);\par
        this.command_.addEventListener('checkedChange', this);\par
      \}\par
    \},\par
\par
    /**\par
     * The text label.\par
     * @type \{string\}\par
     */\par
    get label() \{\par
      return this.textContent;\par
    \},\par
    set label(label) \{\par
      this.textContent = label;\par
    \},\par
\par
    /**\par
     * @return \{boolean\} Whether the menu item is a separator.\par
     */\par
    isSeparator: function() \{\par
      return this.tagName == 'HR';\par
    \},\par
\par
    /**\par
     * Handles mouseup events. This dispatches an active event and if there\par
     * is an assiciated command then that is executed.\par
     * @param \{Event\} The mouseup event object.\par
     * @private\par
     */\par
    handleMouseUp_: function(e) \{\par
      if (!this.disabled && !this.isSeparator() && this.selected) \{\par
        // Dispatch command event followed by executing the command object.\par
        if (cr.dispatchSimpleEvent(this, 'activate', true, true)) \{\par
          var command = this.command;\par
          if (command)\par
            command.execute();\par
        \}\par
      \}\par
    \},\par
\par
    /**\par
     * Handles changes to the associated command.\par
     * @param \{Event\} e The event object.\par
     */\par
    handleEvent: function(e) \{\par
      switch (e.type) \{\par
        case 'disabledChange':\par
          this.disabled = this.command.disabled;\par
          break;\par
        case 'hiddenChange':\par
          this.hidden = this.command.hidden;\par
          break;\par
        case 'labelChange':\par
          this.label = this.command.label;\par
          break;\par
        case 'checkedChange':\par
          this.checked = this.command.checked;\par
          break;\par
      \}\par
    \}\par
  \};\par
\par
  /**\par
   * Whether the menu item is disabled or not.\par
   * @type \{boolean\}\par
   */\par
  cr.defineProperty(MenuItem, 'disabled', cr.PropertyKind.BOOL_ATTR);\par
\par
  /**\par
   * Whether the menu item is hidden or not.\par
   * @type \{boolean\}\par
   */\par
  cr.defineProperty(MenuItem, 'hidden', cr.PropertyKind.BOOL_ATTR);\par
\par
  /**\par
   * Whether the menu item is selected or not.\par
   * @type \{boolean\}\par
   */\par
  cr.defineProperty(MenuItem, 'selected', cr.PropertyKind.BOOL_ATTR);\par
\par
  /**\par
   * Whether the menu item is checked or not.\par
   * @type \{boolean\}\par
   */\par
  cr.defineProperty(MenuItem, 'checked', cr.PropertyKind.BOOL_ATTR);\par
\par
  // Export\par
  return \{\par
    MenuItem: MenuItem\par
  \};\par
\});\par
</script>\par
<script>// Copyright (c) 2010 The Chromium Authors. All rights reserved.\par
// Use of this source code is governed by a BSD-style license that can be\par
// found in the LICENSE file.\par
\par
/**\par
 * @fileoverview This file provides utility functions for position popups.\par
 */\par
\par
cr.define('cr.ui', function() \{\par
\par
  /**\par
   * Type def for rects as returned by getBoundingClientRect.\par
   * @typedef \{ \{left: number, top: number, width: number, height: number,\par
   *             right: number, bottom: number\}\}\par
   */\par
  var Rect;\par
\par
  /**\par
   * Enum for defining how to anchor a popup to an anchor element.\par
   * @enum \{number\}\par
   */\par
  const AnchorType = \{\par
    /**\par
     * The popup's right edge is aligned with the left edge of the anchor.\par
     * The popup's top edge is aligned with the top edge of the anchor.\par
     */\par
    BEFORE: 1,  // p: right, a: left, p: top, a: top\par
\par
    /**\par
     * The popop's left edge is aligned with the right edge of the anchor.\par
     * The popup's top edge is aligned with the top edge of the anchor.\par
     */\par
    AFTER: 2,  // p: left a: right, p: top, a: top\par
\par
    /**\par
     * The popop's bottom edge is aligned with the top edge of the anchor.\par
     * The popup's left edge is aligned with the left edge of the anchor.\par
     */\par
    ABOVE: 3,  // p: bottom, a: top, p: left, a: left\par
\par
    /**\par
     * The popop's top edge is aligned with the bottom edge of the anchor.\par
     * The popup's left edge is aligned with the left edge of the anchor.\par
     */\par
    BELOW: 4  // p: top, a: bottom, p: left, a: left\par
  \};\par
\par
  /**\par
   * Helper function for positionPopupAroundElement and positionPopupAroundRect.\par
   * @param \{!Rect\} anchorRect The rect for the anchor.\par
   * @param \{!HTMLElement\} popupElement The element used for the popup.\par
   * @param \{AnchorType\} type The type of anchoring to do.\par
   * @param \{boolean\} invertLeftRight Whether to invert the right/left\par
   *     alignment.\par
   */\par
  function positionPopupAroundRect(anchorRect, popupElement, type,\par
                                   invertLeftRight) \{\par
    var popupRect = popupElement.getBoundingClientRect();\par
    var availRect;\par
    var ownerDoc = popupElement.ownerDocument;\par
    var cs = ownerDoc.defaultView.getComputedStyle(popupElement);\par
    var docElement = ownerDoc.documentElement;\par
\par
    if (cs.position == 'fixed') \{\par
      // For 'fixed' positioned popups, the available rectangle should be based\par
      // on the viewport rather than the document.\par
      availRect = \{\par
        height: docElement.clientHeight,\par
        width: docElement.clientWidth,\par
        top: 0,\par
        bottom: docElement.clientHeight,\par
        left: 0,\par
        right: docElement.clientWidth\par
      \};\par
    \} else \{\par
      availRect = popupElement.offsetParent.getBoundingClientRect();\par
    \}\par
\par
    if (cs.direction == 'rtl')\par
      invertLeftRight = !invertLeftRight;\par
\par
    // Flip BEFORE, AFTER based on alignment.\par
    if (invertLeftRight) \{\par
      if (type == AnchorType.BEFORE)\par
        type = AnchorType.AFTER;\par
      else if (type == AnchorType.AFTER)\par
        type = AnchorType.BEFORE;\par
    \}\par
\par
    // Flip type based on available size\par
    switch (type) \{\par
      case AnchorType.BELOW:\par
        if (anchorRect.bottom + popupRect.height > availRect.height &&\par
            popupRect.height <= anchorRect.top) \{\par
          type = AnchorType.ABOVE;\par
        \}\par
        break;\par
      case AnchorType.ABOVE:\par
        if (popupRect.height > anchorRect.top &&\par
            anchorRect.bottom + popupRect.height <= availRect.height) \{\par
          type = AnchorType.BELOW;\par
        \}\par
        break;\par
      case AnchorType.AFTER:\par
        if (anchorRect.right + popupRect.width > availRect.width &&\par
            popupRect.width <= anchorRect.left) \{\par
          type = AnchorType.BEFORE;\par
        \}\par
        break;\par
      case AnchorType.BEFORE:\par
        if (popupRect.width > anchorRect.left &&\par
            anchorRect.right + popupRect.width <= availRect.width) \{\par
          type = AnchorType.AFTER;\par
        \}\par
        break;\par
    \}\par
    // flipping done\par
\par
    var style = popupElement.style;\par
    // Reset all directions.\par
    style.left = style.right = style.top = style.bottom = 'auto'\par
\par
    // Primary direction\par
    switch (type) \{\par
      case AnchorType.BELOW:\par
        if (anchorRect.bottom + popupRect.height <= availRect.height)\par
          style.top = anchorRect.bottom + 'px';\par
        else\par
          style.bottom = '0';\par
        break;\par
      case AnchorType.ABOVE:\par
        if (availRect.height - anchorRect.top >= 0)\par
          style.bottom = availRect.height - anchorRect.top + 'px';\par
        else\par
          style.top = '0';\par
        break;\par
      case AnchorType.AFTER:\par
        if (anchorRect.right + popupRect.width <= availRect.width)\par
          style.left = anchorRect.right + 'px';\par
        else\par
          style.right = '0';\par
        break;\par
      case AnchorType.BEFORE:\par
        if (availRect.width - anchorRect.left >= 0)\par
          style.right = availRect.width - anchorRect.left + 'px';\par
        else\par
          style.left = '0';\par
        break;\par
    \}\par
\par
    // Secondary direction\par
    switch (type) \{\par
      case AnchorType.BELOW:\par
      case AnchorType.ABOVE:\par
        if (invertLeftRight) \{\par
          // align right edges\par
          if (anchorRect.right - popupRect.width >= 0) \{\par
            style.right = availRect.width - anchorRect.right + 'px';\par
\par
          // align left edges\par
          \} else if (anchorRect.left + popupRect.width <= availRect.width) \{\par
            style.left = anchorRect.left + 'px';\par
\par
          // not enough room on either side\par
          \} else \{\par
            style.right = '0';\par
          \}\par
        \} else \{\par
          // align left edges\par
          if (anchorRect.left + popupRect.width <= availRect.width) \{\par
            style.left = anchorRect.left + 'px';\par
\par
          // align right edges\par
          \} else if (anchorRect.right - popupRect.width >= 0) \{\par
            style.right = availRect.width - anchorRect.right + 'px';\par
\par
          // not enough room on either side\par
          \} else \{\par
            style.left = '0';\par
          \}\par
        \}\par
        break;\par
\par
      case AnchorType.AFTER:\par
      case AnchorType.BEFORE:\par
        // align top edges\par
        if (anchorRect.top + popupRect.height <= availRect.height) \{\par
          style.top = anchorRect.top + 'px';\par
\par
        // align bottom edges\par
        \} else if (anchorRect.bottom - popupRect.height >= 0) \{\par
          style.bottom = availRect.height - anchorRect.bottom + 'px';\par
\par
          // not enough room on either side\par
        \} else \{\par
          style.top = '0';\par
        \}\par
        break;\par
    \}\par
  \}\par
\par
  /**\par
   * Positions a popup element relative to an anchor element. The popup element\par
   * should have position set to absolute and it should be a child of the body\par
   * element.\par
   * @param \{!HTMLElement\} anchorElement The element that the popup is anchored\par
   *     to.\par
   * @param \{!HTMLElement\} popupElement The popup element we are positioning.\par
   * @param \{AnchorType\} type The type of anchoring we want.\par
   * @param \{boolean\} invertLeftRight Whether to invert the right/left\par
   *     alignment.\par
   */\par
  function positionPopupAroundElement(anchorElement, popupElement, type,\par
                                      invertLeftRight) \{\par
    var anchorRect = anchorElement.getBoundingClientRect();\par
    positionPopupAroundRect(anchorRect, popupElement, type, invertLeftRight);\par
  \}\par
\par
  /**\par
   * Positions a popup around a point.\par
   * @param \{number\} x The client x position.\par
   * @param \{number\} y The client y position.\par
   * @param \{!HTMLElement\} popupElement The popup element we are positioning.\par
   */\par
  function positionPopupAtPoint(x, y, popupElement) \{\par
    var rect = \{\par
      left: x,\par
      top: y,\par
      width: 0,\par
      height: 0,\par
      right: x,\par
      bottom: y\par
    \};\par
    positionPopupAroundRect(rect, popupElement, AnchorType.BELOW);\par
  \}\par
\par
  // Export\par
  return \{\par
    AnchorType: AnchorType,\par
    positionPopupAroundElement: positionPopupAroundElement,\par
    positionPopupAtPoint: positionPopupAtPoint\par
  \};\par
\});\par
</script>\par
<script>// Copyright (c) 2011 The Chromium Authors. All rights reserved.\par
// Use of this source code is governed by a BSD-style license that can be\par
// found in the LICENSE file.\par
\par
cr.define('cr.ui', function() \{\par
  const Menu = cr.ui.Menu;\par
  const positionPopupAroundElement = cr.ui.positionPopupAroundElement;\par
\par
  /**\par
   * Creates a new menu button element.\par
   * @param \{Object=\} opt_propertyBag Optional properties.\par
   * @constructor\par
   * @extends \{HTMLButtonElement\}\par
   */\par
  var MenuButton = cr.ui.define('button');\par
\par
  MenuButton.prototype = \{\par
    __proto__: HTMLButtonElement.prototype,\par
\par
    /**\par
     * Initializes the menu button.\par
     */\par
    decorate: function() \{\par
      this.addEventListener('mousedown', this);\par
      this.addEventListener('keydown', this);\par
\par
      // Adding the 'custom-appearance' class prevents button.css from changing\par
      // the appearance of this element.\par
      this.classList.add('custom-appearance');\par
\par
      var menu;\par
      if ((menu = this.getAttribute('menu')))\par
        this.menu = menu;\par
\par
      // An event tracker for events we only connect to while the menu is\par
      // displayed.\par
      this.showingEvents_ = new EventTracker();\par
\par
      this.anchorType = cr.ui.AnchorType.BELOW;\par
      this.invertLeftRight = false;\par
    \},\par
\par
    /**\par
     * The menu associated with the menu button.\par
     * @type \{cr.ui.Menu\}\par
     */\par
    get menu() \{\par
      return this.menu_;\par
    \},\par
    set menu(menu) \{\par
      if (typeof menu == 'string' && menu[0] == '#') \{\par
        menu = this.ownerDocument.getElementById(menu.slice(1));\par
        cr.ui.decorate(menu, Menu);\par
      \}\par
\par
      this.menu_ = menu;\par
      if (menu) \{\par
        if (menu.id)\par
          this.setAttribute('menu', '#' + menu.id);\par
      \}\par
    \},\par
\par
    /**\par
     * Handles event callbacks.\par
     * @param \{Event\} e The event object.\par
     */\par
    handleEvent: function(e) \{\par
      if (!this.menu)\par
        return;\par
\par
      switch (e.type) \{\par
        case 'mousedown':\par
          if (e.currentTarget == this.ownerDocument) \{\par
            if (!this.contains(e.target) && !this.menu.contains(e.target))\par
              this.hideMenu();\par
            else\par
              e.preventDefault();\par
          \} else \{\par
            if (this.isMenuShown()) \{\par
              this.hideMenu();\par
            \} else if (e.button == 0) \{  // Only show the menu when using left\par
                                         // mouse button.\par
              this.showMenu();\par
              // Prevent the button from stealing focus on mousedown.\par
              e.preventDefault();\par
            \}\par
          \}\par
          break;\par
        case 'keydown':\par
          this.handleKeyDown(e);\par
          // If the menu is visible we let it handle all the keyboard events.\par
          if (this.isMenuShown() && e.currentTarget == this.ownerDocument) \{\par
            this.menu.handleKeyDown(e);\par
            e.preventDefault();\par
            e.stopPropagation();\par
          \}\par
          break;\par
\par
        case 'activate':\par
        case 'blur':\par
        case 'resize':\par
          this.hideMenu();\par
          break;\par
      \}\par
    \},\par
\par
    /**\par
     * Shows the menu.\par
     */\par
    showMenu: function() \{\par
      this.hideMenu();\par
\par
      this.menu.style.display = 'block';\par
      this.setAttribute('menu-shown', '');\par
\par
      // when the menu is shown we steal all keyboard events.\par
      var doc = this.ownerDocument;\par
      var win = doc.defaultView;\par
      this.showingEvents_.add(doc, 'keydown', this, true);\par
      this.showingEvents_.add(doc, 'mousedown', this, true);\par
      this.showingEvents_.add(doc, 'blur', this, true);\par
      this.showingEvents_.add(win, 'resize', this);\par
      this.showingEvents_.add(this.menu, 'activate', this);\par
      this.positionMenu_();\par
    \},\par
\par
    /**\par
     * Hides the menu. If your menu can go out of scope, make sure to call this\par
     * first.\par
     */\par
    hideMenu: function() \{\par
      if (!this.isMenuShown())\par
        return;\par
\par
      this.removeAttribute('menu-shown');\par
      this.menu.style.display = 'none';\par
\par
      this.showingEvents_.removeAll();\par
      this.menu.selectedIndex = -1;\par
    \},\par
\par
    /**\par
     * Whether the menu is shown.\par
     */\par
    isMenuShown: function() \{\par
      return this.hasAttribute('menu-shown');\par
    \},\par
\par
    /**\par
     * Positions the menu below the menu button. At this point we do not use any\par
     * advanced positioning logic to ensure the menu fits in the viewport.\par
     * @private\par
     */\par
    positionMenu_: function() \{\par
      positionPopupAroundElement(this, this.menu, this.anchorType,\par
                                 this.invertLeftRight);\par
    \},\par
\par
    /**\par
     * Handles the keydown event for the menu button.\par
     */\par
    handleKeyDown: function(e) \{\par
      switch (e.keyIdentifier) \{\par
        case 'Down':\par
        case 'Up':\par
        case 'Enter':\par
        case 'U+0020': // Space\par
          if (!this.isMenuShown())\par
            this.showMenu();\par
          e.preventDefault();\par
          break;\par
        case 'Esc':\par
        case 'U+001B': // Maybe this is remote desktop playing a prank?\par
          this.hideMenu();\par
          break;\par
      \}\par
    \}\par
  \};\par
\par
  // Export\par
  return \{\par
    MenuButton: MenuButton\par
  \};\par
\});\par
</script>\par
<script>// Copyright (c) 2011 The Chromium Authors. All rights reserved.\par
// Use of this source code is governed by a BSD-style license that can be\par
// found in the LICENSE file.\par
\par
/**\par
 * @fileoverview Touch Handler. Class that handles all touch events and\par
 * uses them to interpret higher level gestures and behaviors. TouchEvent is a\par
 * built in mobile safari type:\par
 * {{\field{\*\fldinst{HYPERLINK http://developer.apple.com/safari/library/documentation/UserExperience/Reference/TouchEventClassReference/TouchEvent/TouchEvent.html }}{\fldrslt{http://developer.apple.com/safari/library/documentation/UserExperience/Reference/TouchEventClassReference/TouchEvent/TouchEvent.html\ul0\cf0}}}}\f0\fs22 .\par
 * This class is intended to work with all webkit browsers, tested on Chrome and\par
 * iOS.\par
 *\par
 * The following types of gestures are currently supported.  See the definition\par
 * of TouchHandler.EventType for details.\par
 *\par
 * Single Touch:\par
 *      This provides simple single-touch events.  Any secondary touch is\par
 *      ignored.\par
 *\par
 * Drag:\par
 *      A single touch followed by some movement. This behavior will handle all\par
 *      of the required events and report the properties of the drag to you\par
 *      while the touch is happening and at the end of the drag sequence. This\par
 *      behavior will NOT perform the actual dragging (redrawing the element)\par
 *      for you, this responsibility is left to the client code.\par
 *\par
 * Long press:\par
 *     When your element is touched and held without any drag occuring, the\par
 *     LONG_PRESS event will fire.\par
 */\par
\par
// Use an anonymous function to enable strict mode just for this file (which\par
// will be concatenated with other files when embedded in Chrome)\par
cr.define('cr.ui', function() \{\par
  'use strict';\par
\par
  /**\par
   * A TouchHandler attaches to an Element, listents for low-level touch (or\par
   * mouse) events and dispatching higher-level events on the element.\par
   * @param \{!Element\} element The element to listen on and fire events\par
   * for.\par
   * @constructor\par
   */\par
  function TouchHandler(element) \{\par
    /**\par
     * @type \{!Element\}\par
     * @private\par
     */\par
    this.element_ = element;\par
\par
    /**\par
     * The absolute sum of all touch y deltas.\par
     * @type \{number\}\par
     * @private\par
     */\par
    this.totalMoveY_ = 0;\par
\par
    /**\par
     * The absolute sum of all touch x deltas.\par
     * @type \{number\}\par
     * @private\par
     */\par
    this.totalMoveX_ = 0;\par
\par
    /**\par
     * An array of tuples where the first item is the horizontal component of a\par
     * recent relevant touch and the second item is the touch's time stamp. Old\par
     * touches are removed based on the max tracking time and when direction\par
     * changes.\par
      * @type \{!Array.<number>\}\par
      * @private\par
      */\par
    this.recentTouchesX_ = [];\par
\par
    /**\par
     * An array of tuples where the first item is the vertical component of a\par
     * recent relevant touch and the second item is the touch's time stamp. Old\par
     * touches are removed based on the max tracking time and when direction\par
     * changes.\par
     * @type \{!Array.<number>\}\par
     * @private\par
     */\par
    this.recentTouchesY_ = [];\par
\par
    /**\par
     * Used to keep track of all events we subscribe to so we can easily clean\par
     * up\par
     * @type \{EventTracker\}\par
     * @private\par
     */\par
    this.events_ = new EventTracker();\par
  \}\par
\par
\par
  /**\par
   * DOM Events that may be fired by the TouchHandler at the element\par
   */\par
  TouchHandler.EventType = \{\par
    // Fired whenever the element is touched as the only touch to the device.\par
    // enableDrag defaults to false, set to true to permit dragging.\par
    TOUCH_START: 'touchHandler:touch_start',\par
\par
    // Fired when an element is held for a period of time.  Prevents dragging\par
    // from occuring (even if enableDrag was set to true).\par
    LONG_PRESS: 'touchHandler:long_press',\par
\par
    // If enableDrag was set to true at TOUCH_START, DRAG_START will fire when\par
    // the touch first moves sufficient distance.  enableDrag is set to true but\par
    // can be reset to false to cancel the drag.\par
    DRAG_START: 'touchHandler:drag_start',\par
\par
    // If enableDrag was true after DRAG_START, DRAG_MOVE will fire whenever the\par
    // touch is moved.\par
    DRAG_MOVE: 'touchHandler:drag_move',\par
\par
    // Fired just before TOUCH_END when a drag is released.  Correlates 1:1 with\par
    // a DRAG_START.\par
    DRAG_END: 'touchHandler:drag_end',\par
\par
    // Fired whenever a touch that is being tracked has been released.\par
    // Correlates 1:1 with a TOUCH_START.\par
    TOUCH_END: 'touchHandler:touch_end'\par
  \};\par
\par
\par
  /**\par
   * The type of event sent by TouchHandler\par
   * @constructor\par
   * @param \{string\} type The type of event (one of cr.ui.Grabber.EventType).\par
   * @param \{boolean\} bubbles Whether or not the event should bubble.\par
   * @param \{number\} clientX The X location of the touch.\par
   * @param \{number\} clientY The Y location of the touch.\par
   * @param \{!Element\} touchedElement The element at the current location of the\par
   *        touch.\par
   */\par
  TouchHandler.Event = function(type, bubbles, clientX, clientY,\par
      touchedElement) \{\par
    var event = document.createEvent('Event');\par
    event.initEvent(type, bubbles, true);\par
    event.__proto__ = TouchHandler.Event.prototype;\par
\par
    /**\par
     * The X location of the touch affected\par
     * @type \{number\}\par
     */\par
    event.clientX = clientX;\par
\par
    /**\par
     * The Y location of the touch affected\par
     * @type \{number\}\par
     */\par
    event.clientY = clientY;\par
\par
    /**\par
     * The element at the current location of the touch.\par
     * @type \{!Element\}\par
     */\par
    event.touchedElement = touchedElement;\par
\par
    return event;\par
  \};\par
\par
  TouchHandler.Event.prototype = \{\par
    __proto__: Event.prototype,\par
\par
    /**\par
     * For TOUCH_START and DRAG START events, set to true to enable dragging or\par
     * false to disable dragging.\par
     * @type \{boolean|undefined\}\par
     */\par
    enableDrag: undefined,\par
\par
    /**\par
     * For DRAG events, provides the horizontal component of the\par
     * drag delta. Drag delta is defined as the delta of the start touch\par
     * position and the current drag position.\par
     * @type \{number|undefined\}\par
     */\par
    dragDeltaX: undefined,\par
\par
    /**\par
     * For DRAG events, provides the vertical component of the\par
     * drag delta.\par
     * @type \{number|undefined\}\par
     */\par
    dragDeltaY: undefined\par
  \};\par
\par
  /**\par
   * Minimum movement of touch required to be considered a drag.\par
   * @type \{number\}\par
   * @private\par
   */\par
  TouchHandler.MIN_TRACKING_FOR_DRAG_ = 8;\par
\par
\par
  /**\par
   * The maximum number of ms to track a touch event. After an event is older\par
   * than this value, it will be ignored in velocity calculations.\par
   * @type \{number\}\par
   * @private\par
   */\par
  TouchHandler.MAX_TRACKING_TIME_ = 250;\par
\par
\par
  /**\par
   * The maximum number of touches to track.\par
   * @type \{number\}\par
   * @private\par
   */\par
  TouchHandler.MAX_TRACKING_TOUCHES_ = 5;\par
\par
\par
  /**\par
   * The maximum velocity to return, in pixels per millisecond, that is used\par
   * to guard against errors in calculating end velocity of a drag. This is a\par
   * very fast drag velocity.\par
   * @type \{number\}\par
   * @private\par
   */\par
  TouchHandler.MAXIMUM_VELOCITY_ = 5;\par
\par
\par
  /**\par
   * The velocity to return, in pixel per millisecond, when the time stamps on\par
   * the events are erroneous. The browser can return bad time stamps if the\par
   * thread is blocked for the duration of the drag. This is a low velocity to\par
   * prevent the content from moving quickly after a slow drag. It is less\par
   * jarring if the content moves slowly after a fast drag.\par
   * @type \{number\}\par
   * @private\par
   */\par
  TouchHandler.VELOCITY_FOR_INCORRECT_EVENTS_ = 1;\par
\par
  /**\par
   * The time, in milliseconds, that a touch must be held to be considered\par
   * 'long'.\par
   * @type \{number\}\par
   * @private\par
   */\par
  TouchHandler.TIME_FOR_LONG_PRESS_ = 500;\par
\par
  TouchHandler.prototype = \{\par
    /**\par
     * If defined, the identifer of the single touch that is active.  Note that\par
     * 0 is a valid touch identifier - it should not be treated equivalently to\par
     * undefined.\par
     * @type \{number|undefined\}\par
     * @private\par
     */\par
    activeTouch_: undefined,\par
\par
    /**\par
     * @type \{boolean|undefined\}\par
     * @private\par
     */\par
    tracking_: undefined,\par
\par
    /**\par
     * @type \{number|undefined\}\par
     * @private\par
     */\par
    startTouchX_: undefined,\par
\par
    /**\par
     * @type \{number|undefined\}\par
     * @private\par
     */\par
    startTouchY_: undefined,\par
\par
    /**\par
     * @type \{number|undefined\}\par
     * @private\par
     */\par
    endTouchX_: undefined,\par
\par
    /**\par
     * @type \{number|undefined\}\par
     * @private\par
     */\par
    endTouchY_: undefined,\par
\par
    /**\par
     * Time of the touchstart event.\par
     * @type \{number|undefined\}\par
     * @private\par
     */\par
    startTime_: undefined,\par
\par
    /**\par
     * The time of the touchend event.\par
     * @type \{number|undefined\}\par
     * @private\par
     */\par
    endTime_: undefined,\par
\par
    /**\par
     * @type \{number|undefined\}\par
     * @private\par
     */\par
    lastTouchX_: undefined,\par
\par
    /**\par
     * @type \{number|undefined\}\par
     * @private\par
     */\par
    lastTouchY_: undefined,\par
\par
    /**\par
     * @type \{number|undefined\}\par
     * @private\par
     */\par
    lastMoveX_: undefined,\par
\par
    /**\par
     * @type \{number|undefined\}\par
     * @private\par
     */\par
    lastMoveY_: undefined,\par
\par
    /**\par
     * @type \{number|undefined\}\par
     * @private\par
     */\par
    longPressTimeout_: undefined,\par
\par
    /**\par
     * If defined and true, the next click event should be swallowed\par
     * @type \{boolean|undefined\}\par
     * @private\par
     */\par
    swallowNextClick_: undefined,\par
\par
    /**\par
     * Start listenting for events.\par
     * @param \{boolean=\} opt_capture True if the TouchHandler should listen to\par
     *      during the capture phase.\par
     * @param \{boolean=\} opt_mouse True if the TouchHandler should generate\par
     *      events for mouse input (in addition to touch input).\par
     */\par
    enable: function(opt_capture, opt_mouse) \{\par
      var capture = !!opt_capture;\par
\par
      // Just listen to start events for now. When a touch is occuring we'll\par
      // want to be subscribed to move and end events on the document, but we\par
      // don't want to incur the cost of lots of no-op handlers on the document.\par
      this.events_.add(this.element_, 'touchstart', this.onStart_.bind(this),\par
                       capture);\par
      if (opt_mouse) \{\par
        this.events_.add(this.element_, 'mousedown',\par
                         this.mouseToTouchCallback_(this.onStart_.bind(this)),\par
                         capture);\par
      \}\par
\par
      // If the element is long-pressed, we may need to swallow a click\par
      this.events_.add(this.element_, 'click', this.onClick_.bind(this), true);\par
    \},\par
\par
    /**\par
     * Stop listening to all events.\par
     */\par
    disable: function() \{\par
      this.stopTouching_();\par
      this.events_.removeAll();\par
    \},\par
\par
    /**\par
     * Wraps a callback with translations of mouse events to touch events.\par
     * NOTE: These types really should be function(Event) but then we couldn't\par
     * use this with bind (which operates on any type of function).  Doesn't\par
     * JSDoc support some sort of polymorphic types?\par
     * @param \{Function\} callback The event callback.\par
     * @return \{Function\} The wrapping callback.\par
     * @private\par
     */\par
    mouseToTouchCallback_: function(callback) \{\par
      return function(e) \{\par
        // Note that there may be synthesizes mouse events caused by touch\par
        // events (a mouseDown after a touch-click).  We leave it up to the\par
        // client to worry about this if it matters to them (typically a short\par
        // mouseDown/mouseUp without a click is no big problem and it's not\par
        // obvious how we identify such synthesized events in a general way).\par
        var touch = \{\par
          // any fixed value will do for the identifier - there will only\par
          // ever be a single active 'touch' when using the mouse.\par
          identifier: 0,\par
          clientX: e.clientX,\par
          clientY: e.clientY,\par
          target: e.target\par
        \};\par
        e.touches = [];\par
        e.targetTouches = [];\par
        e.changedTouches = [touch];\par
        if (e.type != 'mouseup') \{\par
          e.touches[0] = touch;\par
          e.targetTouches[0] = touch;\par
        \}\par
        callback(e);\par
      \};\par
    \},\par
\par
    /**\par
     * Begin tracking the touchable element, it is eligible for dragging.\par
     * @private\par
     */\par
    beginTracking_: function() \{\par
      this.tracking_ = true;\par
    \},\par
\par
    /**\par
     * Stop tracking the touchable element, it is no longer dragging.\par
     * @private\par
     */\par
    endTracking_: function() \{\par
      this.tracking_ = false;\par
      this.dragging_ = false;\par
      this.totalMoveY_ = 0;\par
      this.totalMoveX_ = 0;\par
    \},\par
\par
    /**\par
     * Reset the touchable element as if we never saw the touchStart\par
     * Doesn't dispatch any end events - be careful of existing listeners.\par
     */\par
    cancelTouch: function() \{\par
      this.stopTouching_();\par
      this.endTracking_();\par
      // If clients needed to be aware of this, we could fire a cancel event\par
      // here.\par
    \},\par
\par
    /**\par
     * Record that touching has stopped\par
     * @private\par
     */\par
    stopTouching_: function() \{\par
      // Mark as no longer being touched\par
      this.activeTouch_ = undefined;\par
\par
      // If we're waiting for a long press, stop\par
      window.clearTimeout(this.longPressTimeout_);\par
\par
      // Stop listening for move/end events until there's another touch.\par
      // We don't want to leave handlers piled up on the document.\par
      // Note that there's no harm in removing handlers that weren't added, so\par
      // rather than track whether we're using mouse or touch we do both.\par
      this.events_.remove(document, 'touchmove');\par
      this.events_.remove(document, 'touchend');\par
      this.events_.remove(document, 'touchcancel');\par
      this.events_.remove(document, 'mousemove');\par
      this.events_.remove(document, 'mouseup');\par
    \},\par
\par
    /**\par
     * Touch start handler.\par
     * @param \{!TouchEvent\} e The touchstart event.\par
     * @private\par
     */\par
    onStart_: function(e) \{\par
      // Only process single touches.  If there is already a touch happening, or\par
      // two simultaneous touches then just ignore them.\par
      if (e.touches.length > 1)\par
        // Note that we could cancel an active touch here.  That would make\par
        // simultaneous touch behave similar to near-simultaneous. However, if\par
        // the user is dragging something, an accidental second touch could be\par
        // quite disruptive if it cancelled their drag.  Better to just ignore\par
        // it.\par
        return;\par
\par
      // It's still possible there could be an active "touch" if the user is\par
      // simultaneously using a mouse and a touch input.\par
      if (this.activeTouch_ !== undefined)\par
        return;\par
\par
      var touch = e.targetTouches[0];\par
      this.activeTouch_ = touch.identifier;\par
\par
      // We've just started touching so shouldn't swallow any upcoming click\par
      if (this.swallowNextClick_)\par
        this.swallowNextClick_ = false;\par
\par
      // Sign up for end/cancel notifications for this touch.\par
      // Note that we do this on the document so that even if the user drags\par
      // their finger off the element, we'll still know what they're doing.\par
      if (e.type == 'mousedown') \{\par
        this.events_.add(document, 'mouseup',\par
            this.mouseToTouchCallback_(this.onEnd_.bind(this)), false);\par
      \} else \{\par
        this.events_.add(document, 'touchend', this.onEnd_.bind(this), false);\par
        this.events_.add(document, 'touchcancel', this.onEnd_.bind(this),\par
            false);\par
      \}\par
\par
      // This timeout is cleared on touchEnd and onDrag\par
      // If we invoke the function then we have a real long press\par
      window.clearTimeout(this.longPressTimeout_);\par
      this.longPressTimeout_ = window.setTimeout(\par
          this.onLongPress_.bind(this),\par
          TouchHandler.TIME_FOR_LONG_PRESS_);\par
\par
      // Dispatch the TOUCH_START event\par
      if (!this.dispatchEvent_(TouchHandler.EventType.TOUCH_START, touch))\par
        // Dragging was not enabled, nothing more to do\par
        return;\par
\par
      // We want dragging notifications\par
      if (e.type == 'mousedown') \{\par
        this.events_.add(document, 'mousemove',\par
            this.mouseToTouchCallback_(this.onMove_.bind(this)), false);\par
      \} else \{\par
        this.events_.add(document, 'touchmove', this.onMove_.bind(this), false);\par
      \}\par
\par
      this.startTouchX_ = this.lastTouchX_ = touch.clientX;\par
      this.startTouchY_ = this.lastTouchY_ = touch.clientY;\par
      this.startTime_ = e.timeStamp;\par
\par
      this.recentTouchesX_ = [];\par
      this.recentTouchesY_ = [];\par
      this.recentTouchesX_.push(touch.clientX, e.timeStamp);\par
      this.recentTouchesY_.push(touch.clientY, e.timeStamp);\par
\par
      this.beginTracking_();\par
    \},\par
\par
    /**\par
     * Given a list of Touches, find the one matching our activeTouch\par
     * identifier. Note that Chrome currently always uses 0 as the identifier.\par
     * In that case we'll end up always choosing the first element in the list.\par
     * @param \{TouchList\} touches The list of Touch objects to search.\par
     * @return \{!Touch|undefined\} The touch matching our active ID if any.\par
     * @private\par
     */\par
    findActiveTouch_: function(touches) \{\par
      assert(this.activeTouch_ !== undefined, 'Expecting an active touch');\par
      // A TouchList isn't actually an array, so we shouldn't use\par
      // Array.prototype.filter/some, etc.\par
      for (var i = 0; i < touches.length; i++) \{\par
        if (touches[i].identifier == this.activeTouch_)\par
          return touches[i];\par
      \}\par
      return undefined;\par
    \},\par
\par
    /**\par
     * Touch move handler.\par
     * @param \{!TouchEvent\} e The touchmove event.\par
     * @private\par
     */\par
    onMove_: function(e) \{\par
      if (!this.tracking_)\par
        return;\par
\par
      // Our active touch should always be in the list of touches still active\par
      assert(this.findActiveTouch_(e.touches), 'Missing touchEnd');\par
\par
      var that = this;\par
      var touch = this.findActiveTouch_(e.changedTouches);\par
      if (!touch)\par
        return;\par
\par
      var clientX = touch.clientX;\par
      var clientY = touch.clientY;\par
\par
      var moveX = this.lastTouchX_ - clientX;\par
      var moveY = this.lastTouchY_ - clientY;\par
      this.totalMoveX_ += Math.abs(moveX);\par
      this.totalMoveY_ += Math.abs(moveY);\par
      this.lastTouchX_ = clientX;\par
      this.lastTouchY_ = clientY;\par
\par
      if (!this.dragging_ && (this.totalMoveY_ >\par
          TouchHandler.MIN_TRACKING_FOR_DRAG_ ||\par
          this.totalMoveX_ >\par
          TouchHandler.MIN_TRACKING_FOR_DRAG_)) \{\par
        // If we're waiting for a long press, stop\par
        window.clearTimeout(this.longPressTimeout_);\par
\par
        // Dispatch the DRAG_START event and record whether dragging should be\par
        // allowed or not.  Note that this relies on the current value of\par
        // startTouchX/Y - handlers may use the initial drag delta to determine\par
        // if dragging should be permitted.\par
        this.dragging_ = this.dispatchEvent_(\par
            TouchHandler.EventType.DRAG_START, touch);\par
\par
        if (this.dragging_) \{\par
          // Update the start position here so that drag deltas have better\par
          // values but don't touch the recent positions so that velocity\par
          // calculations can still use touchstart position in the time and\par
          // distance delta.\par
          this.startTouchX_ = clientX;\par
          this.startTouchY_ = clientY;\par
          this.startTime_ = e.timeStamp;\par
        \} else \{\par
          this.endTracking_();\par
        \}\par
      \}\par
\par
      if (this.dragging_) \{\par
        this.dispatchEvent_(TouchHandler.EventType.DRAG_MOVE, touch);\par
\par
        this.removeTouchesInWrongDirection_(this.recentTouchesX_,\par
            this.lastMoveX_, moveX);\par
        this.removeTouchesInWrongDirection_(this.recentTouchesY_,\par
            this.lastMoveY_, moveY);\par
        this.removeOldTouches_(this.recentTouchesX_, e.timeStamp);\par
        this.removeOldTouches_(this.recentTouchesY_, e.timeStamp);\par
        this.recentTouchesX_.push(clientX, e.timeStamp);\par
        this.recentTouchesY_.push(clientY, e.timeStamp);\par
      \}\par
\par
      this.lastMoveX_ = moveX;\par
      this.lastMoveY_ = moveY;\par
    \},\par
\par
    /**\par
     * Filters the provided recent touches array to remove all touches except\par
     * the last if the move direction has changed.\par
     * @param \{!Array.<number>\} recentTouches An array of tuples where the first\par
     *     item is the x or y component of the recent touch and the second item\par
     *     is the touch time stamp.\par
     * @param \{number|undefined\} lastMove The x or y component of the previous\par
     *     move.\par
     * @param \{number\} recentMove The x or y component of the most recent move.\par
     * @private\par
     */\par
    removeTouchesInWrongDirection_: function(recentTouches, lastMove,\par
        recentMove) \{\par
      if (lastMove && recentMove && recentTouches.length > 2 &&\par
          (lastMove > 0 ^ recentMove > 0)) \{\par
        recentTouches.splice(0, recentTouches.length - 2);\par
      \}\par
    \},\par
\par
    /**\par
     * Filters the provided recent touches array to remove all touches older\par
     * than the max tracking time or the 5th most recent touch.\par
     * @param \{!Array.<number>\} recentTouches An array of tuples where the first\par
     *     item is the x or y component of the recent touch and the second item\par
     *     is the touch time stamp.\par
     * @param \{number\} recentTime The time of the most recent event.\par
     * @private\par
     */\par
    removeOldTouches_: function(recentTouches, recentTime) \{\par
      while (recentTouches.length && recentTime - recentTouches[1] >\par
          TouchHandler.MAX_TRACKING_TIME_ ||\par
          recentTouches.length >\par
              TouchHandler.MAX_TRACKING_TOUCHES_ * 2) \{\par
        recentTouches.splice(0, 2);\par
      \}\par
    \},\par
\par
    /**\par
     * Touch end handler.\par
     * @param \{!TouchEvent\} e The touchend event.\par
     * @private\par
     */\par
    onEnd_: function(e) \{\par
      var that = this;\par
      assert(this.activeTouch_ !== undefined, 'Expect to already be touching');\par
\par
      // If the touch we're tracking isn't changing here, ignore this touch end.\par
      var touch = this.findActiveTouch_(e.changedTouches);\par
      if (!touch) \{\par
        // In most cases, our active touch will be in the 'touches' collection,\par
        // but we can't assert that because occasionally two touchend events can\par
        // occur at almost the same time with both having empty 'touches' lists.\par
        // I.e., 'touches' seems like it can be a bit more up-to-date than the\par
        // current event.\par
        return;\par
      \}\par
\par
      // This is touchEnd for the touch we're monitoring\par
      assert(!this.findActiveTouch_(e.touches),\par
             'Touch ended also still active');\par
\par
      // Indicate that touching has finished\par
      this.stopTouching_();\par
\par
      if (this.tracking_) \{\par
        var clientX = touch.clientX;\par
        var clientY = touch.clientY;\par
\par
        if (this.dragging_) \{\par
          this.endTime_ = e.timeStamp;\par
          this.endTouchX_ = clientX;\par
          this.endTouchY_ = clientY;\par
\par
          this.removeOldTouches_(this.recentTouchesX_, e.timeStamp);\par
          this.removeOldTouches_(this.recentTouchesY_, e.timeStamp);\par
\par
          this.dispatchEvent_(TouchHandler.EventType.DRAG_END, touch);\par
\par
          // Note that in some situations we can get a click event here as well.\par
          // For now this isn't a problem, but we may want to consider having\par
          // some logic that hides clicks that appear to be caused by a touchEnd\par
          // used for dragging.\par
        \}\par
\par
        this.endTracking_();\par
      \}\par
\par
      // Note that we dispatch the touchEnd event last so that events at\par
      // different levels of semantics nest nicely (similar to how DOM\par
      // drag-and-drop events are nested inside of the mouse events that trigger\par
      // them).\par
      this.dispatchEvent_(TouchHandler.EventType.TOUCH_END, touch);\par
    \},\par
\par
    /**\par
     * Get end velocity of the drag. This method is specific to drag behavior,\par
     * so if touch behavior and drag behavior is split then this should go with\par
     * drag behavior. End velocity is defined as deltaXY / deltaTime where\par
     * deltaXY is the difference between endPosition and the oldest recent\par
     * position, and deltaTime is the difference between endTime and the oldest\par
     * recent time stamp.\par
     * @return \{Object\} The x and y velocity.\par
     */\par
    getEndVelocity: function() \{\par
      // Note that we could move velocity to just be an end-event parameter.\par
      var velocityX = this.recentTouchesX_.length ?\par
          (this.endTouchX_ - this.recentTouchesX_[0]) /\par
          (this.endTime_ - this.recentTouchesX_[1]) : 0;\par
      var velocityY = this.recentTouchesY_.length ?\par
          (this.endTouchY_ - this.recentTouchesY_[0]) /\par
          (this.endTime_ - this.recentTouchesY_[1]) : 0;\par
\par
      velocityX = this.correctVelocity_(velocityX);\par
      velocityY = this.correctVelocity_(velocityY);\par
\par
      return \{\par
        x: velocityX,\par
        y: velocityY\par
      \};\par
    \},\par
\par
    /**\par
     * Correct erroneous velocities by capping the velocity if we think it's too\par
     * high, or setting it to a default velocity if know that the event data is\par
     * bad.\par
     * @param \{number\} velocity The x or y velocity component.\par
     * @return \{number\} The corrected velocity.\par
     * @private\par
     */\par
    correctVelocity_: function(velocity) \{\par
      var absVelocity = Math.abs(velocity);\par
\par
      // We add to recent touches for each touchstart and touchmove. If we have\par
      // fewer than 3 touches (6 entries), we assume that the thread was blocked\par
      // for the duration of the drag and we received events in quick succession\par
      // with the wrong time stamps.\par
      if (absVelocity > TouchHandler.MAXIMUM_VELOCITY_) \{\par
        absVelocity = this.recentTouchesY_.length < 3 ?\par
            TouchHandler.VELOCITY_FOR_INCORRECT_EVENTS_ :\par
                TouchHandler.MAXIMUM_VELOCITY_;\par
      \}\par
      return absVelocity * (velocity < 0 ? -1 : 1);\par
    \},\par
\par
    /**\par
     * Handler when an element has been pressed for a long time\par
     * @private\par
     */\par
    onLongPress_: function() \{\par
      // Swallow any click that occurs on this element without an intervening\par
      // touch start event.  This simple click-busting technique should be\par
      // sufficient here since a real click should have a touchstart first.\par
      this.swallowNextClick_ = true;\par
\par
      // Dispatch to the LONG_PRESS\par
      this.dispatchEventXY_(TouchHandler.EventType.LONG_PRESS, this.element_,\par
          this.startTouchX_, this.startTouchY_);\par
    \},\par
\par
    /**\par
     * Click handler - used to swallow clicks after a long-press\par
     * @param \{!Event\} e The click event.\par
     * @private\par
     */\par
    onClick_: function(e) \{\par
      if (this.swallowNextClick_) \{\par
        e.preventDefault();\par
        e.stopPropagation();\par
        this.swallowNextClick_ = false;\par
      \}\par
    \},\par
\par
    /**\par
     * Dispatch a TouchHandler event to the element\par
     * @param \{string\} eventType The event to dispatch.\par
     * @param \{Touch\} touch The touch triggering this event.\par
     * @return \{boolean|undefined\} The value of enableDrag after dispatching\par
     *         the event.\par
     * @private\par
     */\par
    dispatchEvent_: function(eventType, touch) \{\par
\par
      // Determine which element was touched.  For mouse events, this is always\par
      // the event/touch target.  But for touch events, the target is always the\par
      // target of the touchstart (and it's unlikely we can change this\par
      // since the common implementation of touch dragging relies on it). Since\par
      // touch is our primary scenario (which we want to emulate with mouse),\par
      // we'll treat both cases the same and not depend on the target.\par
      var touchedElement;\par
      if (eventType == TouchHandler.EventType.TOUCH_START) \{\par
        touchedElement = touch.target;\par
      \} else \{\par
        touchedElement = this.element_.ownerDocument.\par
            elementFromPoint(touch.clientX, touch.clientY);\par
      \}\par
\par
      return this.dispatchEventXY_(eventType, touchedElement, touch.clientX,\par
          touch.clientY);\par
    \},\par
\par
    /**\par
     * Dispatch a TouchHandler event to the element\par
     * @param \{string\} eventType The event to dispatch.\par
       @param \{number\} clientX The X location for the event.\par
       @param \{number\} clientY The Y location for the event.\par
     * @return \{boolean|undefined\} The value of enableDrag after dispatching\par
     *         the event.\par
     * @private\par
     */\par
    dispatchEventXY_: function(eventType, touchedElement, clientX, clientY) \{\par
      var isDrag = (eventType == TouchHandler.EventType.DRAG_START ||\par
          eventType == TouchHandler.EventType.DRAG_MOVE ||\par
          eventType == TouchHandler.EventType.DRAG_END);\par
\par
      // Drag events don't bubble - we're really just dragging the element,\par
      // not affecting its parent at all.\par
      var bubbles = !isDrag;\par
\par
      var event = new TouchHandler.Event(eventType, bubbles, clientX, clientY,\par
          touchedElement);\par
\par
      // Set enableDrag when it can be overridden\par
      if (eventType == TouchHandler.EventType.TOUCH_START)\par
        event.enableDrag = false;\par
      else if (eventType == TouchHandler.EventType.DRAG_START)\par
        event.enableDrag = true;\par
\par
      if (isDrag) \{\par
        event.dragDeltaX = clientX - this.startTouchX_;\par
        event.dragDeltaY = clientY - this.startTouchY_;\par
      \}\par
\par
      this.element_.dispatchEvent(event);\par
      return event.enableDrag;\par
    \}\par
  \};\par
\par
  return \{\par
    TouchHandler: TouchHandler\par
  \};\par
\});\par
</script>\par
\par
<script>// Copyright (c) 2012 The Chromium Authors. All rights reserved.\par
// Use of this source code is governed by a BSD-style license that can be\par
// found in the LICENSE file.\par
\par
cr.define('ntp4', function() \{\par
  'use strict';\par
\par
  // We can't pass the currently dragging tile via dataTransfer because of\par
  // {{\field{\*\fldinst{HYPERLINK http://crbug.com/31037 }}{\fldrslt{http://crbug.com/31037\ul0\cf0}}}}\f0\fs22\par
  var currentlyDraggingTile = null;\par
  function getCurrentlyDraggingTile() \{\par
    return currentlyDraggingTile;\par
  \}\par
  function setCurrentlyDraggingTile(tile) \{\par
    currentlyDraggingTile = tile;\par
    if (tile)\par
      ntp4.enterRearrangeMode();\par
    else\par
      ntp4.leaveRearrangeMode();\par
  \}\par
\par
  /**\par
   * Changes the current dropEffect of a drag. This modifies the native cursor\par
   * and serves as an indicator of what we should do at the end of the drag as\par
   * well as give indication to the user if a drop would succeed if they let go.\par
   * @param \{DataTransfer\} dataTransfer A dataTransfer object from a drag event.\par
   * @param \{string\} effect A drop effect to change to (i.e. copy, move, none).\par
   */\par
  function setCurrentDropEffect(dataTransfer, effect) \{\par
    dataTransfer.dropEffect = effect;\par
    if (currentlyDraggingTile)\par
      currentlyDraggingTile.lastDropEffect = dataTransfer.dropEffect;\par
  \}\par
\par
  /**\par
   * Creates a new Tile object. Tiles wrap content on a TilePage, providing\par
   * some styling and drag functionality.\par
   * @constructor\par
   * @extends \{HTMLDivElement\}\par
   */\par
  function Tile(contents) \{\par
    var tile = cr.doc.createElement('div');\par
    tile.__proto__ = Tile.prototype;\par
    tile.initialize(contents);\par
\par
    return tile;\par
  \}\par
\par
  Tile.prototype = \{\par
    __proto__: HTMLDivElement.prototype,\par
\par
    initialize: function(contents) \{\par
      // 'real' as opposed to doppleganger.\par
      this.className = 'tile real';\par
      this.appendChild(contents);\par
      contents.tile = this;\par
\par
      this.addEventListener('dragstart', this.onDragStart_);\par
      this.addEventListener('drag', this.onDragMove_);\par
      this.addEventListener('dragend', this.onDragEnd_);\par
\par
      this.firstChild.addEventListener(\par
          'webkitAnimationEnd', this.onContentsAnimationEnd_.bind(this));\par
\par
      this.eventTracker = new EventTracker();\par
    \},\par
\par
    get index() \{\par
      return Array.prototype.indexOf.call(this.parentNode.children, this);\par
    \},\par
\par
    get tilePage() \{\par
      return findAncestorByClass(this, 'tile-page');\par
    \},\par
\par
    /**\par
     * Position the tile at |x, y|, and store this as the grid location, i.e.\par
     * where the tile 'belongs' when it's not being dragged.\par
     * @param \{number\} x The x coordinate, in pixels.\par
     * @param \{number\} y The y coordinate, in pixels.\par
     */\par
    setGridPosition: function(x, y) \{\par
      this.gridX = x;\par
      this.gridY = y;\par
      this.moveTo(x, y);\par
    \},\par
\par
    /**\par
     * Position the tile at |x, y|.\par
     * @param \{number\} x The x coordinate, in pixels.\par
     * @param \{number\} y The y coordinate, in pixels.\par
     */\par
    moveTo: function(x, y) \{\par
      // left overrides right in LTR, and right takes precedence in RTL.\par
      this.style.left = x + 'px';\par
      this.style.right = x + 'px';\par
      this.style.top = y + 'px';\par
    \},\par
\par
    /**\par
     * The handler for dragstart events fired on |this|.\par
     * @param \{Event\} e The event for the drag.\par
     * @private\par
     */\par
    onDragStart_: function(e) \{\par
      // The user may start dragging again during a previous drag's finishing\par
      // animation.\par
      if (this.classList.contains('dragging'))\par
        this.finalizeDrag_();\par
\par
      setCurrentlyDraggingTile(this);\par
\par
      e.dataTransfer.effectAllowed = 'copyMove';\par
      this.firstChild.setDragData(e.dataTransfer);\par
\par
      // The drag clone is the node we use as a representation during the drag.\par
      // It's attached to the top level document element so that it floats above\par
      // image masks.\par
      this.dragClone = this.cloneNode(true);\par
      this.dragClone.style.right = '';\par
      this.dragClone.classList.add('drag-representation');\par
      $('card-slider-frame').appendChild(this.dragClone);\par
      this.eventTracker.add(this.dragClone, 'webkitTransitionEnd',\par
                            this.onDragCloneTransitionEnd_.bind(this));\par
\par
      this.classList.add('dragging');\par
      // offsetLeft is mirrored in RTL. Un-mirror it.\par
      var offsetLeft = isRTL() ?\par
          this.parentNode.clientWidth - this.offsetLeft :\par
          this.offsetLeft;\par
      this.dragOffsetX = e.x - offsetLeft - this.parentNode.offsetLeft;\par
      this.dragOffsetY = e.y - this.offsetTop -\par
          // Unlike offsetTop, this value takes scroll position into account.\par
          this.parentNode.getBoundingClientRect().top;\par
\par
      this.onDragMove_(e);\par
    \},\par
\par
    /**\par
     * The handler for drag events fired on |this|.\par
     * @param \{Event\} e The event for the drag.\par
     * @private\par
     */\par
    onDragMove_: function(e) \{\par
      if (e.view != window || (e.x == 0 && e.y == 0)) \{\par
        this.dragClone.hidden = true;\par
        return;\par
      \}\par
\par
      this.dragClone.hidden = false;\par
      this.dragClone.style.left = (e.x - this.dragOffsetX) + 'px';\par
      this.dragClone.style.top = (e.y - this.dragOffsetY) + 'px';\par
    \},\par
\par
    /**\par
     * The handler for dragend events fired on |this|.\par
     * @param \{Event\} e The event for the drag.\par
     * @private\par
     */\par
    onDragEnd_: function(e) \{\par
      this.dragClone.hidden = false;\par
      this.dragClone.classList.add('placing');\par
\par
      setCurrentlyDraggingTile(null);\par
\par
      // tilePage will be null if we've already been removed.\par
      var tilePage = this.tilePage;\par
      if (tilePage)\par
        tilePage.positionTile_(this.index);\par
\par
      // Take an appropriate action with the drag clone.\par
      if (this.landedOnTrash) \{\par
        this.dragClone.classList.add('deleting');\par
      \} else if (tilePage) \{\par
        // TODO(dbeam): Until we fix dropEffect to the correct behavior it will\par
        // differ on windows - crbug.com/39399.  That's why we use the custom\par
        // this.lastDropEffect instead of e.dataTransfer.dropEffect.\par
        if (tilePage.selected && this.lastDropEffect != 'copy') \{\par
          // The drag clone can still be hidden from the last drag move event.\par
          this.dragClone.hidden = false;\par
          // The tile's contents may have moved following the respositioning;\par
          // adjust for that.\par
          var contentDiffX = this.dragClone.firstChild.offsetLeft -\par
              this.firstChild.offsetLeft;\par
          var contentDiffY = this.dragClone.firstChild.offsetTop -\par
              this.firstChild.offsetTop;\par
          this.dragClone.style.left = (this.gridX + this.parentNode.offsetLeft -\par
              contentDiffX) + 'px';\par
          this.dragClone.style.top =\par
              (this.gridY + this.parentNode.getBoundingClientRect().top -\par
              contentDiffY) + 'px';\par
        \} else if (this.dragClone.hidden) \{\par
          this.finalizeDrag_();\par
        \} else \{\par
          // The CSS3 transitions spec intentionally leaves it up to individual\par
          // user agents to determine when styles should be applied. On some\par
          // platforms (at the moment, Windows), when you apply both classes\par
          // immediately a transition may not occur correctly. That's why we're\par
          // using a setTimeout here to queue adding the class until the\par
          // previous class (currently: .placing) sets up a transition.\par
          // {{\field{\*\fldinst{HYPERLINK http://dev.w3.org/csswg/css3-transitions/#starting }}{\fldrslt{http://dev.w3.org/csswg/css3-transitions/#starting\ul0\cf0}}}}\f0\fs22\par
          window.setTimeout(function() \{\par
            if (this.dragClone)\par
              this.dragClone.classList.add('dropped-on-other-page');\par
          \}.bind(this), 0);\par
        \}\par
      \}\par
\par
      delete this.lastDropEffect;\par
      this.landedOnTrash = false;\par
    \},\par
\par
    /**\par
     * Creates a clone of this node offset by the coordinates. Used for the\par
     * dragging effect where a tile appears to float off one side of the grid\par
     * and re-appear on the other.\par
     * @param \{number\} x x-axis offset, in pixels.\par
     * @param \{number\} y y-axis offset, in pixels.\par
     */\par
    showDoppleganger: function(x, y) \{\par
      // We always have to clear the previous doppleganger to make sure we get\par
      // style updates for the contents of this tile.\par
      this.clearDoppleganger();\par
\par
      var clone = this.cloneNode(true);\par
      clone.classList.remove('real');\par
      clone.classList.add('doppleganger');\par
      var clonelets = clone.querySelectorAll('.real');\par
      for (var i = 0; i < clonelets.length; i++) \{\par
        clonelets[i].classList.remove('real');\par
      \}\par
\par
      this.appendChild(clone);\par
      this.doppleganger_ = clone;\par
\par
      if (isRTL())\par
        x *= -1;\par
\par
      this.doppleganger_.style.WebkitTransform = 'translate(' + x + 'px, ' +\par
                                                                y + 'px)';\par
    \},\par
\par
    /**\par
     * Destroys the current doppleganger.\par
     */\par
    clearDoppleganger: function() \{\par
      if (this.doppleganger_) \{\par
        this.removeChild(this.doppleganger_);\par
        this.doppleganger_ = null;\par
      \}\par
    \},\par
\par
    /**\par
     * Returns status of doppleganger.\par
     * @return \{boolean\} True if there is a doppleganger showing for |this|.\par
     */\par
    hasDoppleganger: function() \{\par
      return !!this.doppleganger_;\par
    \},\par
\par
    /**\par
     * Cleans up after the drag is over. This is either called when the\par
     * drag representation finishes animating to the final position, or when\par
     * the next drag starts (if the user starts a 2nd drag very quickly).\par
     * @private\par
     */\par
    finalizeDrag_: function() \{\par
      assert(this.classList.contains('dragging'));\par
\par
      var clone = this.dragClone;\par
      this.dragClone = null;\par
\par
      clone.parentNode.removeChild(clone);\par
      this.eventTracker.remove(clone, 'webkitTransitionEnd');\par
      this.classList.remove('dragging');\par
      if (this.firstChild.finalizeDrag)\par
        this.firstChild.finalizeDrag();\par
    \},\par
\par
    /**\par
     * Called when the drag representation node is done migrating to its final\par
     * resting spot.\par
     * @param \{Event\} e The transition end event.\par
     */\par
    onDragCloneTransitionEnd_: function(e) \{\par
      if (this.classList.contains('dragging') &&\par
          (e.propertyName == 'left' || e.propertyName == 'top' ||\par
           e.propertyName == '-webkit-transform')) \{\par
        this.finalizeDrag_();\par
      \}\par
    \},\par
\par
    /**\par
     * Called when an app is removed from Chrome. Animates its disappearance.\par
     * @param \{boolean=\} opt_animate Whether the animation should be animated.\par
     */\par
    doRemove: function(opt_animate) \{\par
      if (opt_animate)\par
        this.firstChild.classList.add('removing-tile-contents');\par
      else\par
        this.tilePage.removeTile(this, false);\par
    \},\par
\par
    /**\par
     * Callback for the webkitAnimationEnd event on the tile's contents.\par
     * @param \{Event\} e The event object.\par
     */\par
    onContentsAnimationEnd_: function(e) \{\par
      if (this.firstChild.classList.contains('new-tile-contents'))\par
        this.firstChild.classList.remove('new-tile-contents');\par
      if (this.firstChild.classList.contains('removing-tile-contents'))\par
        this.tilePage.removeTile(this, true);\par
    \},\par
  \};\par
\par
  /**\par
   * Gives the proportion of the row width that is devoted to a single icon.\par
   * @param \{number\} rowTileCount The number of tiles in a row.\par
   * @param \{number\} tileSpacingFraction The proportion of the tile width which\par
   *     will be used as spacing between tiles.\par
   * @return \{number\} The ratio between icon width and row width.\par
   */\par
  function tileWidthFraction(rowTileCount, tileSpacingFraction) \{\par
    return rowTileCount + (rowTileCount - 1) * tileSpacingFraction;\par
  \}\par
\par
  /**\par
   * Calculates an assortment of tile-related values for a grid with the\par
   * given dimensions.\par
   * @param \{number\} width The pixel width of the grid.\par
   * @param \{number\} numRowTiles The number of tiles in a row.\par
   * @param \{number\} tileSpacingFraction The proportion of the tile width which\par
   *     will be used as spacing between tiles.\par
   * @return \{Object\} A mapping of pixel values.\par
   */\par
  function tileValuesForGrid(width, numRowTiles, tileSpacingFraction) \{\par
    var tileWidth = width / tileWidthFraction(numRowTiles, tileSpacingFraction);\par
    var offsetX = tileWidth * (1 + tileSpacingFraction);\par
    var interTileSpacing = offsetX - tileWidth;\par
\par
    return \{\par
      tileWidth: tileWidth,\par
      offsetX: offsetX,\par
      interTileSpacing: interTileSpacing,\par
    \};\par
  \}\par
\par
  // The smallest amount of horizontal blank space to display on the sides when\par
  // displaying a wide arrangement. There is an additional 26px of margin from\par
  // the tile page padding.\par
  var MIN_WIDE_MARGIN = 18;\par
\par
  /**\par
   * Creates a new TilePage object. This object contains tiles and controls\par
   * their layout.\par
   * @param \{Object\} gridValues Pixel values that define the size and layout\par
   *     of the tile grid.\par
   * @constructor\par
   * @extends \{HTMLDivElement\}\par
   */\par
  function TilePage(gridValues) \{\par
    var el = cr.doc.createElement('div');\par
    el.gridValues_ = gridValues;\par
    el.__proto__ = TilePage.prototype;\par
    el.initialize();\par
\par
    return el;\par
  \}\par
\par
  /**\par
   * Takes a collection of grid layout pixel values and updates them with\par
   * additional tiling values that are calculated from TilePage constants.\par
   * @param \{Object\} grid The grid layout pixel values to update.\par
   */\par
  TilePage.initGridValues = function(grid) \{\par
    // The amount of space we need to display a narrow grid (all narrow grids\par
    // are this size).\par
    grid.narrowWidth =\par
        grid.minTileWidth * tileWidthFraction(grid.minColCount,\par
                                              grid.tileSpacingFraction);\par
    // The minimum amount of space we need to display a wide grid.\par
    grid.minWideWidth =\par
        grid.minTileWidth * tileWidthFraction(grid.maxColCount,\par
                                              grid.tileSpacingFraction);\par
    // The largest we will ever display a wide grid.\par
    grid.maxWideWidth =\par
        grid.maxTileWidth * tileWidthFraction(grid.maxColCount,\par
                                              grid.tileSpacingFraction);\par
    // Tile-related pixel values for the narrow display.\par
    grid.narrowTileValues = tileValuesForGrid(grid.narrowWidth,\par
                                              grid.minColCount,\par
                                              grid.tileSpacingFraction);\par
    // Tile-related pixel values for the minimum narrow display.\par
    grid.wideTileValues = tileValuesForGrid(grid.minWideWidth,\par
                                            grid.maxColCount,\par
                                            grid.tileSpacingFraction);\par
  \};\par
\par
  TilePage.prototype = \{\par
    __proto__: HTMLDivElement.prototype,\par
\par
    initialize: function() \{\par
      this.className = 'tile-page';\par
\par
      // Div that acts as a custom scrollbar. The scrollbar has to live\par
      // outside the content div so it doesn't flicker when scrolling (due to\par
      // repainting after the scroll, then repainting again when moved in the\par
      // onScroll handler). |scrollbar_| is only aesthetic, and it only\par
      // represents the thumb. Actual events are still handled by the invisible\par
      // native scrollbars. This div gives us more flexibility with the visuals.\par
      this.scrollbar_ = this.ownerDocument.createElement('div');\par
      this.scrollbar_.className = 'tile-page-scrollbar';\par
      this.scrollbar_.hidden = true;\par
      this.appendChild(this.scrollbar_);\par
\par
      // This contains everything but the scrollbar.\par
      this.content_ = this.ownerDocument.createElement('div');\par
      this.content_.className = 'tile-page-content';\par
      this.appendChild(this.content_);\par
\par
      // Div that sets the vertical position of the tile grid.\par
      this.topMargin_ = this.ownerDocument.createElement('div');\par
      this.topMargin_.className = 'top-margin';\par
      this.content_.appendChild(this.topMargin_);\par
\par
      // Div that holds the tiles.\par
      this.tileGrid_ = this.ownerDocument.createElement('div');\par
      this.tileGrid_.className = 'tile-grid';\par
      this.tileGrid_.style.minWidth = this.gridValues_.narrowWidth + 'px';\par
      this.content_.appendChild(this.tileGrid_);\par
\par
      // Ordered list of our tiles.\par
      this.tileElements_ = this.tileGrid_.getElementsByClassName('tile real');\par
      // Ordered list of the elements which want to accept keyboard focus. These\par
      // elements will not be a part of the normal tab order; the tile grid\par
      // initially gets focused and then these elements can be focused via the\par
      // arrow keys.\par
      this.focusableElements_ =\par
          this.tileGrid_.getElementsByClassName('focusable');\par
\par
      // These are properties used in updateTopMargin.\par
      this.animatedTopMarginPx_ = 0;\par
      this.topMarginPx_ = 0;\par
\par
      this.eventTracker = new EventTracker();\par
      this.eventTracker.add(window, 'resize', this.onResize_.bind(this));\par
\par
      this.addEventListener('DOMNodeInsertedIntoDocument',\par
                            this.onNodeInsertedIntoDocument_);\par
\par
      this.addEventListener('mousewheel', this.onMouseWheel_);\par
      this.content_.addEventListener('scroll', this.onScroll_.bind(this));\par
\par
      this.dragWrapper_ = new cr.ui.DragWrapper(this.tileGrid_, this);\par
\par
      this.addEventListener('cardselected', this.handleCardSelection_);\par
      this.addEventListener('carddeselected', this.handleCardDeselection_);\par
      this.addEventListener('focus', this.handleFocus_);\par
      this.addEventListener('keydown', this.handleKeyDown_);\par
      this.addEventListener('mousedown', this.handleMouseDown_);\par
\par
      this.focusElementIndex_ = -1;\par
    \},\par
\par
    get tiles() \{\par
      return this.tileElements_;\par
    \},\par
\par
    get tileCount() \{\par
      return this.tileElements_.length;\par
    \},\par
\par
    get selected() \{\par
      return Array.prototype.indexOf.call(this.parentNode.children, this) ==\par
          ntp4.getCardSlider().currentCard;\par
    \},\par
\par
    /**\par
     * The size of the margin (unused space) on the sides of the tile grid, in\par
     * pixels.\par
     * @type \{number\}\par
     */\par
    get sideMargin() \{\par
      return this.layoutValues_.leftMargin;\par
    \},\par
\par
    /**\par
     * Returns the width of the scrollbar, in pixels, if it is active, or 0\par
     * otherwise.\par
     * @type \{number\}\par
     */\par
    get scrollbarWidth() \{\par
      return this.scrollbar_.hidden ? 0 : 13;\par
    \},\par
\par
    /**\par
     * Returns any extra padding to insert to the bottom of a tile page.  By\par
     * default there is none, but subclasses can override.\par
     * @type \{number\}\par
     */\par
    get extraBottomPadding() \{\par
      return 0;\par
    \},\par
\par
    /**\par
     * Removes the tilePage from the DOM and cleans up event handlers.\par
     */\par
    remove: function() \{\par
      // This checks arguments.length as most remove functions have a boolean\par
      // |opt_animate| argument, but that's not necesarilly applicable to\par
      // removing a tilePage. Selecting a different card in an animated way and\par
      // deleting the card afterward is probably a better choice.\par
      assert(typeof arguments[0] != 'boolean',\par
             'This function takes no |opt_animate| argument.');\par
      this.tearDown_();\par
      this.parentNode.removeChild(this);\par
    \},\par
\par
    /**\par
     * Cleans up resources that are no longer needed after this TilePage\par
     * instance is removed from the DOM.\par
     * @private\par
     */\par
    tearDown_: function() \{\par
      this.eventTracker.removeAll();\par
    \},\par
\par
    /**\par
     * Appends a tile to the end of the tile grid.\par
     * @param \{HTMLElement\} tileElement The contents of the tile.\par
     * @param \{?boolean\} animate If true, the append will be animated.\par
     * @protected\par
     */\par
    appendTile: function(tileElement, animate) \{\par
      this.addTileAt(tileElement, this.tileElements_.length, animate);\par
    \},\par
\par
    /**\par
     * Adds the given element to the tile grid.\par
     * @param \{Node\} tileElement The tile object/node to insert.\par
     * @param \{number\} index The location in the tile grid to insert it at.\par
     * @param \{boolean=\} opt_animate If true, the tile in question will be\par
     *     animated (other tiles, if they must reposition, do not animate).\par
     * @protected\par
     */\par
    addTileAt: function(tileElement, index, opt_animate) \{\par
      this.classList.remove('animating-tile-page');\par
      if (opt_animate)\par
        tileElement.classList.add('new-tile-contents');\par
\par
      // Make sure the index is positive and either in the the bounds of\par
      // this.tileElements_ or at the end (meaning append).\par
      assert(index >= 0 && index <= this.tileElements_.length);\par
\par
      var wrapperDiv = new Tile(tileElement);\par
      // If is out of the bounds of the tile element list, .insertBefore() will\par
      // act just like appendChild().\par
      this.tileGrid_.insertBefore(wrapperDiv, this.tileElements_[index]);\par
      this.calculateLayoutValues_();\par
      this.heightChanged_();\par
\par
      this.positionTile_(index);\par
      this.fireAddedEvent(wrapperDiv, index, !!opt_animate);\par
    \},\par
\par
    /**\par
     * Notify interested subscribers that a tile has been removed from this\par
     * page.\par
     * @param \{Tile\} tile The newly added tile.\par
     * @param \{number\} index The index of the tile that was added.\par
     * @param \{boolean\} wasAnimated Whether the removal was animated.\par
     */\par
    fireAddedEvent: function(tile, index, wasAnimated) \{\par
      var e = document.createEvent('Event');\par
      e.initEvent('tilePage:tile_added', true, true);\par
      e.addedIndex = index;\par
      e.addedTile = tile;\par
      e.wasAnimated = wasAnimated;\par
      this.dispatchEvent(e);\par
    \},\par
\par
    /**\par
     * Removes the given tile and animates the repositioning of the other tiles.\par
     * @param \{boolean=\} opt_animate Whether the removal should be animated.\par
     * @param \{boolean=\} opt_dontNotify Whether a page should be removed if the\par
     *     last tile is removed from it.\par
     */\par
    removeTile: function(tile, opt_animate, opt_dontNotify) \{\par
      if (opt_animate)\par
        this.classList.add('animating-tile-page');\par
      var index = tile.index;\par
      tile.parentNode.removeChild(tile);\par
      this.calculateLayoutValues_();\par
      this.cleanupDrag();\par
\par
      if (!opt_dontNotify)\par
        this.fireRemovedEvent(tile, index, !!opt_animate);\par
    \},\par
\par
    /**\par
     * Notify interested subscribers that a tile has been removed from this\par
     * page.\par
     * @param \{Tile\} tile The tile that was removed.\par
     * @param \{number\} oldIndex Where the tile was positioned before removal.\par
     * @param \{boolean\} wasAnimated Whether the removal was animated.\par
     */\par
    fireRemovedEvent: function(tile, oldIndex, wasAnimated) \{\par
      var e = document.createEvent('Event');\par
      e.initEvent('tilePage:tile_removed', true, true);\par
      e.removedIndex = oldIndex;\par
      e.removedTile = tile;\par
      e.wasAnimated = wasAnimated;\par
      this.dispatchEvent(e);\par
    \},\par
\par
    /**\par
     * Removes all tiles from the page.\par
     */\par
    removeAllTiles: function() \{\par
      this.tileGrid_.innerHTML = '';\par
    \},\par
\par
    /**\par
     * Called when the page is selected (in the card selector).\par
     * @param \{Event\} e A custom cardselected event.\par
     * @private\par
     */\par
    handleCardSelection_: function(e) \{\par
      this.tabIndex = 1;\par
\par
      // When we are selected, we re-calculate the layout values. (See comment\par
      // in doDrop.)\par
      this.calculateLayoutValues_();\par
    \},\par
\par
    /**\par
     * Called when the page loses selection (in the card selector).\par
     * @param \{Event\} e A custom carddeselected event.\par
     * @private\par
     */\par
    handleCardDeselection_: function(e) \{\par
      this.tabIndex = -1;\par
      if (this.currentFocusElement_)\par
        this.currentFocusElement_.tabIndex = -1;\par
    \},\par
\par
    /**\par
     * When we get focus, pass it on to the focus element.\par
     * @param \{Event\} e The focus event.\par
     * @private\par
     */\par
    handleFocus_: function(e) \{\par
      if (this.focusableElements_.length == 0)\par
        return;\par
\par
      this.updateFocusElement_();\par
    \},\par
\par
    /**\par
     * Since we are doing custom focus handling, we have to manually\par
     * set focusability on click (as well as keyboard nav above).\par
     * @param \{Event\} e The focus event.\par
     * @private\par
     */\par
    handleMouseDown_: function(e) \{\par
      var focusable = findAncestorByClass(e.target, 'focusable');\par
      if (focusable) \{\par
        this.focusElementIndex_ =\par
            Array.prototype.indexOf.call(this.focusableElements_,\par
                                         focusable);\par
        this.updateFocusElement_();\par
      \} else \{\par
        // This prevents the tile page from getting focus when the user clicks\par
        // inside the grid but outside of any tile.\par
        e.preventDefault();\par
      \}\par
    \},\par
\par
    /**\par
     * Handle arrow key focus nav.\par
     * @param \{Event\} e The focus event.\par
     * @private\par
     */\par
    handleKeyDown_: function(e) \{\par
      // We only handle up, down, left, right without control keys.\par
      if (e.metaKey || e.shiftKey || e.altKey || e.ctrlKey)\par
        return;\par
\par
      // Wrap the given index to |this.focusableElements_|.\par
      var wrap = function(idx) \{\par
        return (idx + this.focusableElements_.length) %\par
            this.focusableElements_.length;\par
      \}.bind(this);\par
\par
      switch (e.keyIdentifier) \{\par
        case 'Right':\par
        case 'Left':\par
          var direction = e.keyIdentifier == 'Right' ? 1 : -1;\par
          this.focusElementIndex_ = wrap(this.focusElementIndex_ + direction);\par
          break;\par
        case 'Up':\par
        case 'Down':\par
          // Look through all focusable elements. Find the first one that is\par
          // in the same column.\par
          var direction = e.keyIdentifier == 'Up' ? -1 : 1;\par
          var currentIndex =\par
              Array.prototype.indexOf.call(this.focusableElements_,\par
                                           this.currentFocusElement_);\par
          var newFocusIdx = wrap(currentIndex + direction)\par
          var tile = this.currentFocusElement_.parentNode;\par
          for (;; newFocusIdx = wrap(newFocusIdx + direction)) \{\par
            var newTile = this.focusableElements_[newFocusIdx].parentNode;\par
            var rowTiles = this.layoutValues_.numRowTiles;\par
            if ((newTile.index - tile.index) % rowTiles == 0)\par
              break;\par
          \}\par
\par
          this.focusElementIndex_ = newFocusIdx;\par
          break;\par
\par
        default:\par
          return;\par
      \}\par
\par
      this.updateFocusElement_();\par
\par
      e.preventDefault();\par
      e.stopPropagation();\par
    \},\par
\par
    /**\par
     * Focuses the element for |this.focusElementIndex_|. Makes the current\par
     * focus element, if any, no longer eligible for focus.\par
     * @private\par
     */\par
    updateFocusElement_: function() \{\par
      this.focusElementIndex_ = Math.min(this.focusableElements_.length - 1,\par
                                         this.focusElementIndex_);\par
      this.focusElementIndex_ = Math.max(0, this.focusElementIndex_);\par
\par
      var newFocusElement = this.focusableElements_[this.focusElementIndex_];\par
      var lastFocusElement = this.currentFocusElement_;\par
      if (lastFocusElement && lastFocusElement != newFocusElement)\par
        lastFocusElement.tabIndex = -1;\par
\par
      newFocusElement.tabIndex = 1;\par
      newFocusElement.focus();\par
      this.tabIndex = -1;\par
    \},\par
\par
    /**\par
     * The current focus element is that element which is eligible for focus.\par
     * @type \{HTMLElement\} The node.\par
     * @private\par
     */\par
    get currentFocusElement_() \{\par
      return this.querySelector('.focusable[tabindex="1"]');\par
    \},\par
\par
    /**\par
     * Makes some calculations for tile layout. These change depending on\par
     * height, width, and the number of tiles.\par
     * TODO(estade): optimize calls to this function. Do nothing if the page is\par
     * hidden, but call before being shown.\par
     * @private\par
     */\par
    calculateLayoutValues_: function() \{\par
      var grid = this.gridValues_;\par
      var availableSpace = this.tileGrid_.clientWidth - 2 * MIN_WIDE_MARGIN;\par
      var wide = availableSpace >= grid.minWideWidth;\par
      var numRowTiles = wide ? grid.maxColCount : grid.minColCount;\par
\par
      var effectiveGridWidth = wide ?\par
          Math.min(Math.max(availableSpace, grid.minWideWidth),\par
                   grid.maxWideWidth) :\par
          grid.narrowWidth;\par
      var realTileValues = tileValuesForGrid(effectiveGridWidth, numRowTiles,\par
                                             grid.tileSpacingFraction);\par
\par
      // leftMargin centers the grid within the avaiable space.\par
      var minMargin = wide ? MIN_WIDE_MARGIN : 0;\par
      var leftMargin =\par
          Math.max(minMargin,\par
                   (this.tileGrid_.clientWidth - effectiveGridWidth) / 2);\par
\par
      var rowHeight = this.heightForWidth(realTileValues.tileWidth) +\par
          realTileValues.interTileSpacing;\par
\par
      this.layoutValues_ = \{\par
        numRowTiles: numRowTiles,\par
        leftMargin: leftMargin,\par
        colWidth: realTileValues.offsetX,\par
        rowHeight: rowHeight,\par
        tileWidth: realTileValues.tileWidth,\par
        wide: wide,\par
      \};\par
\par
      // We need to update the top margin as well.\par
      this.updateTopMargin_();\par
\par
      this.firePageLayoutEvent_();\par
    \},\par
\par
    /**\par
     * Dispatches the custom pagelayout event.\par
     * @private\par
     */\par
    firePageLayoutEvent_: function() \{\par
      cr.dispatchSimpleEvent(this, 'pagelayout', true, true);\par
    \},\par
\par
    /**\par
     * Calculates the x/y coordinates for an element and moves it there.\par
     * @param \{number\} index The index of the element to be positioned.\par
     * @param \{number\} indexOffset If provided, this is added to |index| when\par
     *     positioning the tile. The effect is that the tile will be positioned\par
     *     in a non-default location.\par
     * @private\par
     */\par
    positionTile_: function(index, indexOffset) \{\par
      var grid = this.gridValues_;\par
      var layout = this.layoutValues_;\par
\par
      indexOffset = typeof indexOffset != 'undefined' ? indexOffset : 0;\par
      // Add the offset _after_ the modulus division. We might want to show the\par
      // tile off the side of the grid.\par
      var col = index % layout.numRowTiles + indexOffset;\par
      var row = Math.floor(index / layout.numRowTiles);\par
      // Calculate the final on-screen position for the tile.\par
      var realX = col * layout.colWidth + layout.leftMargin;\par
      var realY = row * layout.rowHeight;\par
\par
      // Calculate the portion of the tile's position that should be animated.\par
      var animatedTileValues = layout.wide ?\par
          grid.wideTileValues : grid.narrowTileValues;\par
      // Animate the difference between three-wide and six-wide.\par
      var animatedLeftMargin = layout.wide ?\par
          0 : (grid.minWideWidth - MIN_WIDE_MARGIN - grid.narrowWidth) / 2;\par
      var animatedX = col * animatedTileValues.offsetX + animatedLeftMargin;\par
      var animatedY = row * (this.heightForWidth(animatedTileValues.tileWidth) +\par
                             animatedTileValues.interTileSpacing);\par
\par
      var tile = this.tileElements_[index];\par
      tile.setGridPosition(animatedX, animatedY);\par
      tile.firstChild.setBounds(layout.tileWidth,\par
                                realX - animatedX,\par
                                realY - animatedY);\par
\par
      // This code calculates whether the tile needs to show a clone of itself\par
      // wrapped around the other side of the tile grid.\par
      var offTheRight = col == layout.numRowTiles ||\par
          (col == layout.numRowTiles - 1 && tile.hasDoppleganger());\par
      var offTheLeft = col == -1 || (col == 0 && tile.hasDoppleganger());\par
      if (this.isCurrentDragTarget && (offTheRight || offTheLeft)) \{\par
        var sign = offTheRight ? 1 : -1;\par
        tile.showDoppleganger(-layout.numRowTiles * layout.colWidth * sign,\par
                              layout.rowHeight * sign);\par
      \} else \{\par
        tile.clearDoppleganger();\par
      \}\par
\par
      if (index == this.tileElements_.length - 1) \{\par
        this.tileGrid_.style.height = (realY + layout.rowHeight) + 'px';\par
        this.queueUpdateScrollbars_();\par
      \}\par
    \},\par
\par
    /**\par
     * Gets the index of the tile that should occupy coordinate (x, y). Note\par
     * that this function doesn't care where the tiles actually are, and will\par
     * return an index even for the space between two tiles. This function is\par
     * effectively the inverse of |positionTile_|.\par
     * @param \{number\} x The x coordinate, in pixels, relative to the left of\par
     *     |this|.\par
     * @param \{number\} y The y coordinate, in pixels, relative to the top of\par
     *     |this|.\par
     * @private\par
     */\par
    getWouldBeIndexForPoint_: function(x, y) \{\par
      var grid = this.gridValues_;\par
      var layout = this.layoutValues_;\par
\par
      var gridClientRect = this.tileGrid_.getBoundingClientRect();\par
      var col = Math.floor((x - gridClientRect.left - layout.leftMargin) /\par
                           layout.colWidth);\par
      if (col < 0 || col >= layout.numRowTiles)\par
        return -1;\par
\par
      if (isRTL())\par
        col = layout.numRowTiles - 1 - col;\par
\par
      var row = Math.floor((y - gridClientRect.top) / layout.rowHeight);\par
      return row * layout.numRowTiles + col;\par
    \},\par
\par
    /**\par
     * Window resize event handler. Window resizes may trigger re-layouts.\par
     * @param \{Object\} e The resize event.\par
     */\par
    onResize_: function(e) \{\par
      if (this.lastWidth_ == this.clientWidth &&\par
          this.lastHeight_ == this.clientHeight) \{\par
        return;\par
      \}\par
\par
      this.calculateLayoutValues_();\par
\par
      this.lastWidth_ = this.clientWidth;\par
      this.lastHeight_ = this.clientHeight;\par
      this.classList.add('animating-tile-page');\par
      this.heightChanged_();\par
\par
      this.repositionTiles_();\par
    \},\par
\par
    /**\par
     * The tile grid has an image mask which fades at the edges. We only show\par
     * the mask when there is an active drag; it obscures doppleganger tiles\par
     * as they enter or exit the grid.\par
     * @private\par
     */\par
    updateMask_: function() \{\par
      if (!this.isCurrentDragTarget) \{\par
        this.tileGrid_.style.WebkitMaskBoxImage = '';\par
        return;\par
      \}\par
\par
      var leftMargin = this.layoutValues_.leftMargin;\par
      // The fade distance is the space between tiles.\par
      var fadeDistance = (this.gridValues_.tileSpacingFraction *\par
          this.layoutValues_.tileWidth);\par
      fadeDistance = Math.min(leftMargin, fadeDistance);\par
      // On Skia we don't use any fade because it works very poorly. See\par
      // {{\field{\*\fldinst{HYPERLINK http://crbug.com/99373 }}{\fldrslt{http://crbug.com/99373\ul0\cf0}}}}\f0\fs22\par
      if (!cr.isMac)\par
        fadeDistance = 1;\par
      var gradient =\par
          '-webkit-linear-gradient(left,' +\par
              'transparent, ' +\par
              'transparent ' + (leftMargin - fadeDistance) + 'px, ' +\par
              'black ' + leftMargin + 'px, ' +\par
              'black ' + (this.tileGrid_.clientWidth - leftMargin) + 'px, ' +\par
              'transparent ' + (this.tileGrid_.clientWidth - leftMargin +\par
                                fadeDistance) + 'px, ' +\par
              'transparent)';\par
      this.tileGrid_.style.WebkitMaskBoxImage = gradient;\par
    \},\par
\par
    updateTopMargin_: function() \{\par
      var layout = this.layoutValues_;\par
\par
      // The top margin is set so that the vertical midpoint of the grid will\par
      // be 1/3 down the page.\par
      var numTiles = this.tileCount +\par
          (this.isCurrentDragTarget && !this.withinPageDrag_ ? 1 : 0);\par
      var numRows = Math.ceil(numTiles / layout.numRowTiles);\par
      var usedHeight = layout.rowHeight * numRows;\par
      // 60 matches the top padding of tile-page (which acts as the minimum).\par
      var newMargin = document.documentElement.clientHeight / 3 -\par
          usedHeight / 3 - 60;\par
      newMargin = Math.max(newMargin, 0);\par
\par
      // |newMargin| is the final margin we actually want to show. However,\par
      // part of that should be animated and part should not (for the same\par
      // reason as with leftMargin). The approach is to consider differences\par
      // when the layout changes from wide to narrow or vice versa as\par
      // 'animatable'. These differences accumulate in animatedTopMarginPx_,\par
      // while topMarginPx_ caches the real (total) margin. Either of these\par
      // calculations may come out to be negative, so we use margins as the\par
      // css property.\par
\par
      if (typeof this.topMarginIsForWide_ == 'undefined')\par
        this.topMarginIsForWide_ = layout.wide;\par
      if (this.topMarginIsForWide_ != layout.wide) \{\par
        this.animatedTopMarginPx_ += newMargin - this.topMarginPx_;\par
        this.topMargin_.style.marginBottom =\par
            this.animatedTopMarginPx_ + 'px';\par
      \}\par
\par
      this.topMarginIsForWide_ = layout.wide;\par
      this.topMarginPx_ = newMargin;\par
      this.topMargin_.style.marginTop =\par
          (this.topMarginPx_ - this.animatedTopMarginPx_) + 'px';\par
    \},\par
\par
    /**\par
     * Handles final setup that can only happen after |this| is inserted into\par
     * the page.\par
     * @private\par
     */\par
    onNodeInsertedIntoDocument_: function(e) \{\par
      this.calculateLayoutValues_();\par
      this.heightChanged_();\par
    \},\par
\par
    /**\par
     * Called when the height of |this| has changed: update the size of\par
     * tileGrid.\par
     * @private\par
     */\par
    heightChanged_: function() \{\par
      // The tile grid will expand to the bottom footer, or enough to hold all\par
      // the tiles, whichever is greater. It would be nicer if tilePage were\par
      // a flex box, and the tile grid could be box-flex: 1, but this exposes a\par
      // bug where repositioning tiles will cause the scroll position to reset.\par
      this.tileGrid_.style.minHeight = (this.clientHeight -\par
          this.tileGrid_.offsetTop - this.content_.offsetTop -\par
          this.extraBottomPadding) + 'px';\par
    \},\par
\par
    /**\par
     * Scrolls the page in response to a mousewheel event.\par
     * @param \{Event\} e The mousewheel event.\par
     */\par
    handleMouseWheel: function(e) \{\par
      this.content_.scrollTop -= e.wheelDeltaY / 3;\par
    \},\par
\par
    /**\par
     * Handles mouse wheels on |this|. We handle this explicitly because we want\par
     * a consistent experience whether the user scrolls on the page or on the\par
     * page switcher (handleMouseWheel provides a common conversion factor\par
     * between wheel delta and scroll delta).\par
     * @param \{Event\} e The mousewheel event.\par
     * @private\par
     */\par
    onMouseWheel_: function(e) \{\par
      if (e.wheelDeltaY == 0)\par
        return;\par
\par
      this.handleMouseWheel(e);\par
      e.preventDefault();\par
      e.stopPropagation();\par
    \},\par
\par
    /**\par
     * Handler for the 'scroll' event on |content_|.\par
     * @param \{Event\} e The scroll event.\par
     * @private\par
     */\par
    onScroll_: function(e) \{\par
      this.queueUpdateScrollbars_();\par
    \},\par
\par
    /**\par
     * ID of scrollbar update timer. If 0, there's no scrollbar re-calc queued.\par
     * @private\par
     */\par
    scrollbarUpdate_: 0,\par
\par
    /**\par
     * Queues an update on the custom scrollbar. Used for two reasons: first,\par
     * coalescing of multiple updates, and second, because action like\par
     * repositioning a tile can require a delay before they affect values\par
     * like clientHeight.\par
     * @private\par
     */\par
    queueUpdateScrollbars_: function() \{\par
      if (this.scrollbarUpdate_)\par
        return;\par
\par
      this.scrollbarUpdate_ = window.setTimeout(\par
          this.doUpdateScrollbars_.bind(this), 0);\par
    \},\par
\par
    /**\par
     * Does the work of calculating the visibility, height and position of the\par
     * scrollbar thumb (there is no track or buttons).\par
     * @private\par
     */\par
    doUpdateScrollbars_: function() \{\par
      this.scrollbarUpdate_ = 0;\par
\par
      var content = this.content_;\par
\par
      // Adjust scroll-height to account for possible header-bar.\par
      var adjustedScrollHeight = content.scrollHeight - content.offsetTop;\par
\par
      if (adjustedScrollHeight <= content.clientHeight) \{\par
        this.scrollbar_.hidden = true;\par
        return;\par
      \} else \{\par
        this.scrollbar_.hidden = false;\par
      \}\par
\par
      var thumbTop = content.offsetTop +\par
          content.scrollTop / adjustedScrollHeight * content.clientHeight;\par
      var thumbHeight = content.clientHeight / adjustedScrollHeight *\par
          this.clientHeight;\par
\par
      this.scrollbar_.style.top = thumbTop + 'px';\par
      this.scrollbar_.style.height = thumbHeight + 'px';\par
      this.firePageLayoutEvent_();\par
    \},\par
\par
    /**\par
     * Get the height for a tile of a certain width. Override this function to\par
     * get non-square tiles.\par
     * @param \{number\} width The pixel width of a tile.\par
     * @return \{number\} The height for |width|.\par
     */\par
    heightForWidth: function(width) \{\par
      return width;\par
    \},\par
\par
    /** Dragging **/\par
\par
    get isCurrentDragTarget() \{\par
      return this.dragWrapper_.isCurrentDragTarget;\par
    \},\par
\par
    /**\par
     * Thunk for dragleave events fired on |tileGrid_|.\par
     * @param \{Event\} e A MouseEvent for the drag.\par
     */\par
    doDragLeave: function(e) \{\par
      this.cleanupDrag();\par
    \},\par
\par
    /**\par
     * Performs all actions necessary when a drag enters the tile page.\par
     * @param \{Event\} e A mouseover event for the drag enter.\par
     */\par
    doDragEnter: function(e) \{\par
\par
      // Applies the mask so doppleganger tiles disappear into the fog.\par
      this.updateMask_();\par
\par
      this.classList.add('animating-tile-page');\par
      this.withinPageDrag_ = this.contains(currentlyDraggingTile);\par
      this.dragItemIndex_ = this.withinPageDrag_ ?\par
          currentlyDraggingTile.index : this.tileElements_.length;\par
      this.currentDropIndex_ = this.dragItemIndex_;\par
\par
      // The new tile may change the number of rows, hence the top margin\par
      // will change.\par
      if (!this.withinPageDrag_)\par
        this.updateTopMargin_();\par
\par
      this.doDragOver(e);\par
    \},\par
\par
    /**\par
     * Performs all actions necessary when the user moves the cursor during\par
     * a drag over the tile page.\par
     * @param \{Event\} e A mouseover event for the drag over.\par
     */\par
    doDragOver: function(e) \{\par
      e.preventDefault();\par
\par
      this.setDropEffect(e.dataTransfer);\par
      var newDragIndex = this.getWouldBeIndexForPoint_(e.pageX, e.pageY);\par
      if (newDragIndex < 0 || newDragIndex >= this.tileElements_.length)\par
        newDragIndex = this.dragItemIndex_;\par
      this.updateDropIndicator_(newDragIndex);\par
    \},\par
\par
    /**\par
     * Performs all actions necessary when the user completes a drop.\par
     * @param \{Event\} e A mouseover event for the drag drop.\par
     */\par
    doDrop: function(e) \{\par
      e.stopPropagation();\par
\par
      var index = this.currentDropIndex_;\par
      // Only change data if this was not a 'null drag'.\par
      if (!((index == this.dragItemIndex_) && this.withinPageDrag_)) \{\par
        var adjustedIndex = this.currentDropIndex_ +\par
            (index > this.dragItemIndex_ ? 1 : 0);\par
        if (this.withinPageDrag_) \{\par
          this.tileGrid_.insertBefore(\par
              currentlyDraggingTile,\par
              this.tileElements_[adjustedIndex]);\par
          this.tileMoved(currentlyDraggingTile, this.dragItemIndex_);\par
        \} else \{\par
          var originalPage = currentlyDraggingTile ?\par
              currentlyDraggingTile.tilePage : null;\par
          this.addDragData(e.dataTransfer, adjustedIndex);\par
          if (originalPage)\par
            originalPage.cleanupDrag();\par
        \}\par
\par
        // Dropping the icon may cause topMargin to change, but changing it\par
        // now would cause everything to move (annoying), so we leave it\par
        // alone. The top margin will be re-calculated next time the window is\par
        // resized or the page is selected.\par
      \}\par
\par
      this.classList.remove('animating-tile-page');\par
      this.cleanupDrag();\par
    \},\par
\par
    /**\par
     * Appends the currently dragged tile to the end of the page. Called\par
     * from outside the page, e.g. when dropping on a nav dot.\par
     */\par
    appendDraggingTile: function() \{\par
      var originalPage = currentlyDraggingTile.tilePage;\par
      if (originalPage == this)\par
        return;\par
\par
      this.addDragData(null, this.tileElements_.length);\par
      if (originalPage)\par
        originalPage.cleanupDrag();\par
    \},\par
\par
    /**\par
     * Makes sure all the tiles are in the right place after a drag is over.\par
     */\par
    cleanupDrag: function() \{\par
      this.repositionTiles_(currentlyDraggingTile);\par
      // Remove the drag mask.\par
      this.updateMask_();\par
    \},\par
\par
    /**\par
     * Reposition all the tiles (possibly ignoring one).\par
     * @param \{?Node\} ignoreNode An optional node to ignore.\par
     * @private\par
     */\par
    repositionTiles_: function(ignoreNode) \{\par
      for (var i = 0; i < this.tileElements_.length; i++) \{\par
        if (!ignoreNode || ignoreNode !== this.tileElements_[i])\par
          this.positionTile_(i);\par
      \}\par
    \},\par
\par
    /**\par
     * Updates the visual indicator for the drop location for the active drag.\par
     * @param \{Event\} e A MouseEvent for the drag.\par
     * @private\par
     */\par
    updateDropIndicator_: function(newDragIndex) \{\par
      var oldDragIndex = this.currentDropIndex_;\par
      if (newDragIndex == oldDragIndex)\par
        return;\par
\par
      var repositionStart = Math.min(newDragIndex, oldDragIndex);\par
      var repositionEnd = Math.max(newDragIndex, oldDragIndex);\par
\par
      for (var i = repositionStart; i <= repositionEnd; i++) \{\par
        if (i == this.dragItemIndex_)\par
          continue;\par
        else if (i > this.dragItemIndex_)\par
          var adjustment = i <= newDragIndex ? -1 : 0;\par
        else\par
          var adjustment = i >= newDragIndex ? 1 : 0;\par
\par
        this.positionTile_(i, adjustment);\par
      \}\par
      this.currentDropIndex_ = newDragIndex;\par
    \},\par
\par
    /**\par
     * Checks if a page can accept a drag with the given data.\par
     * @param \{Event\} e The drag event if the drag object. Implementations will\par
     *     likely want to check |e.dataTransfer|.\par
     * @return \{boolean\} True if this page can handle the drag.\par
     */\par
    shouldAcceptDrag: function(e) \{\par
      return false;\par
    \},\par
\par
    /**\par
     * Called to accept a drag drop. Will not be called for in-page drops.\par
     * @param \{Object\} dataTransfer The data transfer object that holds the drop\par
     *     data. This should only be used if currentlyDraggingTile is null.\par
     * @param \{number\} index The tile index at which the drop occurred.\par
     */\par
    addDragData: function(dataTransfer, index) \{\par
      assert(false);\par
    \},\par
\par
    /**\par
     * Called when a tile has been moved (via dragging). Override this to make\par
     * backend updates.\par
     * @param \{Node\} draggedTile The tile that was dropped.\par
     * @param \{number\} prevIndex The previous index of the tile.\par
     */\par
    tileMoved: function(draggedTile, prevIndex) \{\par
    \},\par
\par
    /**\par
     * Sets the drop effect on |dataTransfer| to the desired value (e.g.\par
     * 'copy').\par
     * @param \{Object\} dataTransfer The drag event dataTransfer object.\par
     */\par
    setDropEffect: function(dataTransfer) \{\par
      assert(false);\par
    \},\par
  \};\par
\par
  return \{\par
    getCurrentlyDraggingTile: getCurrentlyDraggingTile,\par
    setCurrentDropEffect: setCurrentDropEffect,\par
    TilePage: TilePage,\par
  \};\par
\});\par
</script>\par
<script>// Copyright (c) 2012 The Chromium Authors. All rights reserved.\par
// Use of this source code is governed by a BSD-style license that can be\par
// found in the LICENSE file.\par
\par
cr.define('ntp4', function() \{\par
  'use strict';\par
\par
  var localStrings = new LocalStrings;\par
\par
  var APP_LAUNCH = \{\par
    // The histogram buckets (keep in sync with extension_constants.h).\par
    NTP_APPS_MAXIMIZED: 0,\par
    NTP_APPS_COLLAPSED: 1,\par
    NTP_APPS_MENU: 2,\par
    NTP_MOST_VISITED: 3,\par
    NTP_RECENTLY_CLOSED: 4,\par
    NTP_APP_RE_ENABLE: 16,\par
    NTP_WEBSTORE_FOOTER: 18,\par
  \};\par
\par
  // Histogram buckets for UMA tracking of where a DnD drop came from.\par
  var DRAG_SOURCE = \{\par
    SAME_APPS_PANE: 0,\par
    OTHER_APPS_PANE: 1,\par
    MOST_VISITED_PANE: 2,\par
    BOOKMARKS_PANE: 3,\par
    OUTSIDE_NTP: 4\par
  \};\par
  var DRAG_SOURCE_LIMIT = DRAG_SOURCE.OUTSIDE_NTP + 1;\par
\par
  /**\par
   * App context menu. The class is designed to be used as a singleton with\par
   * the app that is currently showing a context menu stored in this.app_.\par
   * @constructor\par
   */\par
  function AppContextMenu() \{\par
    this.__proto__ = AppContextMenu.prototype;\par
    this.initialize();\par
  \}\par
  cr.addSingletonGetter(AppContextMenu);\par
\par
  AppContextMenu.prototype = \{\par
    initialize: function() \{\par
      var menu = new cr.ui.Menu;\par
      cr.ui.decorate(menu, cr.ui.Menu);\par
      menu.classList.add('app-context-menu');\par
      this.menu = menu;\par
\par
      this.launch_ = this.appendMenuItem_();\par
      this.launch_.addEventListener('activate', this.onLaunch_.bind(this));\par
\par
      menu.appendChild(cr.ui.MenuItem.createSeparator());\par
      this.launchRegularTab_ = this.appendMenuItem_('applaunchtyperegular');\par
      this.launchPinnedTab_ = this.appendMenuItem_('applaunchtypepinned');\par
      if (!cr.isMac)\par
        this.launchNewWindow_ = this.appendMenuItem_('applaunchtypewindow');\par
      this.launchFullscreen_ = this.appendMenuItem_('applaunchtypefullscreen');\par
\par
      var self = this;\par
      this.forAllLaunchTypes_(function(launchTypeButton, id) \{\par
        launchTypeButton.addEventListener('activate',\par
            self.onLaunchTypeChanged_.bind(self));\par
      \});\par
\par
      menu.appendChild(cr.ui.MenuItem.createSeparator());\par
      this.options_ = this.appendMenuItem_('appoptions');\par
      this.disableNotifications_ =\par
          this.appendMenuItem_('appdisablenotifications');\par
      this.uninstall_ = this.appendMenuItem_('appuninstall');\par
      this.options_.addEventListener('activate',\par
                                     this.onShowOptions_.bind(this));\par
      this.disableNotifications_.addEventListener(\par
          'activate', this.onDisableNotifications_.bind(this));\par
      this.uninstall_.addEventListener('activate',\par
                                       this.onUninstall_.bind(this));\par
\par
      if (!cr.isMac && !cr.isChromeOS) \{\par
        menu.appendChild(cr.ui.MenuItem.createSeparator());\par
        this.createShortcut_ = this.appendMenuItem_('appcreateshortcut');\par
        this.createShortcut_.addEventListener(\par
            'activate', this.onCreateShortcut_.bind(this));\par
      \}\par
\par
      document.body.appendChild(menu);\par
    \},\par
\par
    /**\par
     * Appends a menu item to |this.menu|.\par
     * @param \{?String\} textId If non-null, the ID for the localized string\par
     *     that acts as the item's label.\par
     */\par
    appendMenuItem_: function(textId) \{\par
      var button = cr.doc.createElement('button');\par
      this.menu.appendChild(button);\par
      cr.ui.decorate(button, cr.ui.MenuItem);\par
      if (textId)\par
        button.textContent = localStrings.getString(textId);\par
      return button;\par
    \},\par
\par
    /**\par
     * Iterates over all the launch type menu items.\par
     * @param \{function(cr.ui.MenuItem, number)\} f The function to call for each\par
     *     menu item. The parameters to the function include the menu item and\par
     *     the associated launch ID.\par
     */\par
    forAllLaunchTypes_: function(f) \{\par
      // Order matters: index matches launchType id.\par
      var launchTypes = [ this.launchPinnedTab_,\par
                          this.launchRegularTab_,\par
                          this.launchFullscreen_,\par
                          this.launchNewWindow_ ];\par
\par
      for (var i = 0; i < launchTypes.length; ++i) \{\par
        if (!launchTypes[i])\par
          continue;\par
\par
        f(launchTypes[i], i);\par
      \}\par
    \},\par
\par
    /**\par
     * Does all the necessary setup to show the menu for the given app.\par
     * @param \{App\} app The App object that will be showing a context menu.\par
     */\par
    setupForApp: function(app) \{\par
      this.app_ = app;\par
\par
      this.launch_.textContent = app.appData.title;\par
\par
      this.forAllLaunchTypes_(function(launchTypeButton, id) \{\par
        launchTypeButton.disabled = false;\par
        launchTypeButton.checked = app.appData.launch_type == id;\par
      \});\par
\par
      this.options_.disabled = !app.appData.options_url || !app.appData.enabled;\par
      this.uninstall_.disabled = !app.appData.can_uninstall;\par
\par
      this.disableNotifications_.hidden = true;\par
      var notificationsDisabled = app.appData.notifications_disabled;\par
      if (typeof notificationsDisabled != 'undefined') \{\par
        this.disableNotifications_.hidden = false;\par
        this.disableNotifications_.checked = notificationsDisabled;\par
      \}\par
    \},\par
\par
    /**\par
     * Handlers for menu item activation.\par
     * @param \{Event\} e The activation event.\par
     * @private\par
     */\par
    onLaunch_: function(e) \{\par
      chrome.send('launchApp', [this.app_.appId, APP_LAUNCH.NTP_APPS_MENU]);\par
    \},\par
    onLaunchTypeChanged_: function(e) \{\par
      var pressed = e.currentTarget;\par
      var app = this.app_;\par
      this.forAllLaunchTypes_(function(launchTypeButton, id) \{\par
        if (launchTypeButton == pressed) \{\par
          chrome.send('setLaunchType', [app.appId, id]);\par
          // Manually update the launch type. We will only get\par
          // appsPrefChangeCallback calls after changes to other NTP instances.\par
          app.appData.launch_type = id;\par
        \}\par
      \});\par
    \},\par
    onShowOptions_: function(e) \{\par
      window.location = this.app_.appData.options_url;\par
    \},\par
    onDisableNotifications_: function(e) \{\par
      var app = this.app_;\par
      app.removeBubble();\par
      // Toggle the current disable setting.\par
      var newSetting = !this.disableNotifications_.checked;\par
      app.appData.notifications_disabled = newSetting;\par
      chrome.send('setNotificationsDisabled', [app.appData.id, newSetting]);\par
    \},\par
    onUninstall_: function(e) \{\par
      chrome.send('uninstallApp', [this.app_.appData.id]);\par
    \},\par
    onCreateShortcut_: function(e) \{\par
      chrome.send('createAppShortcut', [this.app_.appData.id]);\par
    \},\par
  \};\par
\par
  /**\par
   * Creates a new App object.\par
   * @param \{Object\} appData The data object that describes the app.\par
   * @constructor\par
   * @extends \{HTMLDivElement\}\par
   */\par
  function App(appData) \{\par
    var el = cr.doc.createElement('div');\par
    el.__proto__ = App.prototype;\par
    el.initialize(appData);\par
\par
    return el;\par
  \}\par
\par
  App.prototype = \{\par
    __proto__: HTMLDivElement.prototype,\par
\par
    /**\par
     * Initialize the app object.\par
     * @param \{Object\} appData The data object that describes the app.\par
     */\par
    initialize: function(appData) \{\par
      this.appData = appData;\par
      assert(this.appData_.id, 'Got an app without an ID');\par
      this.id = this.appData_.id;\par
\par
      this.className = 'app focusable';\par
\par
      if (!this.appData_.icon_big_exists && this.appData_.icon_small_exists)\par
        this.useSmallIcon_ = true;\par
\par
      this.appContents_ = this.useSmallIcon_ ?\par
          $('app-small-icon-template').cloneNode(true) :\par
          $('app-large-icon-template').cloneNode(true);\par
      this.appContents_.id = '';\par
      this.appendChild(this.appContents_);\par
\par
      this.appImgContainer_ = this.querySelector('.app-img-container');\par
      this.appImg_ = this.appImgContainer_.querySelector('img');\par
      this.setIcon();\par
\par
      if (this.useSmallIcon_) \{\par
        this.imgDiv_ = this.querySelector('.app-icon-div');\par
        this.addLaunchClickTarget_(this.imgDiv_);\par
        this.imgDiv_.title = this.appData_.title;\par
        chrome.send('getAppIconDominantColor', [this.id]);\par
      \} else \{\par
        this.addLaunchClickTarget_(this.appImgContainer_);\par
        this.appImgContainer_.title = this.appData_.title;\par
      \}\par
\par
      var appSpan = this.appContents_.querySelector('.title');\par
      appSpan.textContent = appSpan.title = this.appData_.title;\par
      this.addLaunchClickTarget_(appSpan);\par
\par
      var notification = this.appData_.notification;\par
      var hasNotification = typeof notification != 'undefined' &&\par
                            typeof notification['title'] != 'undefined' &&\par
                            typeof notification['body'] != 'undefined' &&\par
                            !this.appData_.notifications_disabled;\par
      if (hasNotification)\par
        this.setupNotification_(notification);\par
\par
      this.addEventListener('keydown', cr.ui.contextMenuHandler);\par
      this.addEventListener('keyup', cr.ui.contextMenuHandler);\par
\par
      // This hack is here so that appContents.contextMenu will be the same as\par
      // this.contextMenu.\par
      var self = this;\par
      this.appContents_.__defineGetter__('contextMenu', function() \{\par
        return self.contextMenu;\par
      \});\par
      this.appContents_.addEventListener('contextmenu',\par
                                         cr.ui.contextMenuHandler);\par
\par
      if (this.appData_.is_webstore)\par
        this.createAppsPromoExtras_();\par
\par
      this.addEventListener('mousedown', this.onMousedown_, true);\par
      this.addEventListener('keydown', this.onKeydown_);\par
      this.addEventListener('blur', this.onBlur_, true);\par
    \},\par
\par
    /**\par
     * Sets the color of the favicon dominant color bar.\par
     * @param \{string\} color The css-parsable value for the color.\par
     */\par
    set stripeColor(color) \{\par
      this.querySelector('.color-stripe').style.backgroundColor = color;\par
    \},\par
\par
    /**\par
     * Removes the app tile from the page. Should be called after the app has\par
     * been uninstalled.\par
     */\par
    remove: function(opt_animate) \{\par
      // Unset the ID immediately, because the app is already gone. But leave\par
      // the tile on the page as it animates out.\par
      this.id = '';\par
      this.tile.doRemove(opt_animate);\par
    \},\par
\par
    /**\par
     * Set the URL of the icon from |appData_|. This won't actually show the\par
     * icon until loadIcon() is called (for performance reasons; we don't want\par
     * to load icons until we have to).\par
     */\par
    setIcon: function() \{\par
      var src = this.useSmallIcon_ ? this.appData_.icon_small :\par
                                     this.appData_.icon_big;\par
      if (!this.appData_.enabled ||\par
          (!this.appData_.offline_enabled && !navigator.onLine)) \{\par
        src += '?grayscale=true';\par
      \}\par
\par
      this.appImgSrc_ = src;\par
      this.classList.add('icon-loading');\par
    \},\par
\par
    /**\par
     * Shows the icon for the app. That is, it causes chrome to load the app\par
     * icon resource.\par
     */\par
    loadIcon: function() \{\par
      if (this.appImgSrc_) \{\par
        this.appImg_.src = this.appImgSrc_;\par
        this.appImg_.classList.remove('invisible');\par
        this.appImgSrc_ = null;\par
      \}\par
      this.classList.remove('icon-loading');\par
    \},\par
\par
    /**\par
     * Creates a bubble node.\par
     * @param \{Object\} notification The notification to show in the bubble.\par
     * @param \{boolean\} full Whether we want the headline or just the content.\par
     * @private\par
     */\par
    createBubbleNode_: function(notification, full) \{\par
      if (!full) \{\par
        var titleItem = this.ownerDocument.createElement('span');\par
        titleItem.textContent = notification['title'];\par
        return titleItem;\par
      \} else \{\par
        var container = this.ownerDocument.createElement('div');\par
\par
        var messageItem = this.ownerDocument.createElement('div');\par
        messageItem.textContent = notification['body'];\par
        container.appendChild(messageItem);\par
\par
        if (notification['linkUrl'] && notification['linkText']) \{\par
          var anchor = this.ownerDocument.createElement('a');\par
          anchor.href = notification['linkUrl'];\par
          anchor.textContent = notification['linkText'];\par
          container.appendChild(anchor);\par
        \}\par
\par
        return container;\par
      \}\par
    \},\par
\par
    /**\par
     * Sets up a notification for the app icon.\par
     * @param \{Object\} notification The notification to show in the bubble.\par
     * @private\par
     */\par
    setupNotification_: function(notification) \{\par
      if (notification) \{\par
        var infoBubble;\par
        if (!this.currentBubbleShowing_) \{\par
          // Create a new bubble.\par
          infoBubble = new cr.ui.ExpandableBubble;\par
          infoBubble.anchorNode = this;\par
          infoBubble.appId = this.appData_.id;\par
          infoBubble.handleCloseEvent = function() \{\par
            chrome.send('closeNotification', [this.appId]);\par
            infoBubble.hide();\par
          \};\par
        \} else \{\par
          // Reuse the old bubble instead of popping up a new bubble over\par
          // the old one.\par
          infoBubble = this.currentBubbleShowing_;\par
          infoBubble.collapseBubble_();\par
        \}\par
        infoBubble.contentTitle = this.createBubbleNode_(notification, false);\par
        infoBubble.content = this.createBubbleNode_(notification, true);\par
        infoBubble.show();\par
        infoBubble.resizeAndReposition();\par
\par
        this.currentBubbleShowing_ = infoBubble;\par
      \}\par
    \},\par
\par
    /**\par
     *  Removes the info bubble if there is one.\par
     */\par
    removeBubble: function() \{\par
      if (this.currentBubbleShowing_) \{\par
        this.currentBubbleShowing_.hide();\par
        this.currentBubbleShowing_ = null;\par
      \}\par
    \},\par
\par
    /**\par
     * Creates the apps-promo section of the app (should only be called for the\par
     * webstore app).\par
     * @private\par
     */\par
    createAppsPromoExtras_: function() \{\par
      this.classList.add('webstore');\par
\par
      this.appsPromoExtras_ = $('apps-promo-extras-template').cloneNode(true);\par
      this.appsPromoExtras_.id = '';\par
      this.appsPromoHeading_ =\par
          this.appsPromoExtras_.querySelector('.apps-promo-heading');\par
      this.appsPromoLink_ =\par
          this.appsPromoExtras_.querySelector('.apps-promo-link');\par
      this.appsPromoLink_.addEventListener('click', this.onClick_.bind(this));\par
\par
      this.appsPromoLogo_ = this.ownerDocument.createElement('img');\par
      this.appsPromoLogo_.className = 'apps-promo-logo';\par
      this.appImgContainer_.appendChild(this.appsPromoLogo_);\par
\par
      this.appendChild(this.appsPromoExtras_);\par
    \},\par
\par
    /**\par
     * Sets the apps promo appearance. If |data| is null, there is no promo. If\par
     * |data| is non-null, it contains strings to be shown for the promo. The\par
     * promo is only shown when the webstore app icon is alone on a page.\par
     * @param \{Object\} data A dictionary that contains apps promo strings.\par
     */\par
    setAppsPromoData: function(data) \{\par
      if (data) \{\par
        this.classList.add('has-promo');\par
      \} else \{\par
        this.classList.remove('has-promo');\par
        return;\par
      \}\par
\par
      this.appsPromoHeading_.textContent = data.promoHeader;\par
      this.appsPromoLink_.href = data.promoLink;\par
      this.appsPromoLink_.textContent = data.promoButton;\par
      this.appsPromoLogo_.src = data.promoLogo;\par
    \},\par
\par
    /**\par
     * Set the size and position of the app tile.\par
     * @param \{number\} size The total size of |this|.\par
     * @param \{number\} x The x-position.\par
     * @param \{number\} y The y-position.\par
     *     animate.\par
     */\par
    setBounds: function(size, x, y) \{\par
      var imgSize = size * APP_IMG_SIZE_FRACTION;\par
      this.appImgContainer_.style.width = this.appImgContainer_.style.height =\par
          this.useSmallIcon_ ? '16px' : imgSize + 'px';\par
      if (this.useSmallIcon_) \{\par
        // 3/4 is the ratio of 96px to 128px (the used height and full height\par
        // of icons in apps).\par
        var iconSize = imgSize * 3/4;\par
        // The -2 is for the div border to improve the visual alignment for the\par
        // icon div.\par
        this.imgDiv_.style.width = this.imgDiv_.style.height =\par
            (iconSize - 2) + 'px';\par
        // Margins set to get the icon placement right and the text to line up.\par
        this.imgDiv_.style.marginTop = this.imgDiv_.style.marginBottom =\par
            ((imgSize - iconSize) / 2) + 'px';\par
      \}\par
\par
      this.style.width = this.style.height = size + 'px';\par
      this.style.left = x + 'px';\par
      this.style.right = x + 'px';\par
      this.style.top = y + 'px';\par
\par
      if (this.currentBubbleShowing_)\par
        this.currentBubbleShowing_.resizeAndReposition();\par
    \},\par
\par
    /**\par
     * Invoked when an app is clicked.\par
     * @param \{Event\} e The click event.\par
     * @private\par
     */\par
    onClick_: function(e) \{\par
      var is_promo = this.appsPromoExtras_ &&\par
          window.getComputedStyle(this.appsPromoExtras_).display != 'none';\par
      var url = !this.appData_.is_webstore ? '' :\par
          is_promo ? this.appsPromoLink_.href :\par
                     appendParam(this.appData_.url,\par
                                 'utm_source',\par
                                 'chrome-ntp-icon');\par
\par
      chrome.send('launchApp',\par
                  [this.appId, APP_LAUNCH.NTP_APPS_MAXIMIZED, url,\par
                   e.button, e.altKey, e.ctrlKey, e.metaKey, e.shiftKey]);\par
\par
      // Don't allow the click to trigger a link or anything\par
      e.preventDefault();\par
    \},\par
\par
    /**\par
     * Invoked when the user presses a key while the app is focused.\par
     * @param \{Event\} e The key event.\par
     * @private\par
     */\par
    onKeydown_: function(e) \{\par
      if (e.keyIdentifier == 'Enter') \{\par
        chrome.send('launchApp',\par
                    [this.appId, APP_LAUNCH.NTP_APPS_MAXIMIZED, '',\par
                     0, e.altKey, e.ctrlKey, e.metaKey, e.shiftKey]);\par
        e.preventDefault();\par
        e.stopPropagation();\par
      \}\par
    \},\par
\par
    /**\par
     * Adds a node to the list of targets that will launch the app. This list\par
     * is also used in onMousedown to determine whether the app contents should\par
     * be shown as active (if we don't do this, then clicking anywhere in\par
     * appContents, even a part that is outside the ideally clickable region,\par
     * will cause the app icon to look active).\par
     * @param \{HTMLElement\} node The node that should be clickable.\par
     */\par
    addLaunchClickTarget_: function(node) \{\par
      node.classList.add('launch-click-target');\par
      node.addEventListener('click', this.onClick_.bind(this));\par
    \},\par
\par
    /**\par
     * Handler for mousedown on the App. Adds a class that allows us to\par
     * not display as :active for right clicks and clicks on app notifications\par
     * (specifically, don't pulse on these occasions). Also, we don't pulse\par
     * for clicks that aren't within the clickable regions.\par
     * @param \{Event\} e The mousedown event.\par
     */\par
    onMousedown_: function(e) \{\par
      if (e.button == 2 ||\par
          !findAncestorByClass(e.target, 'launch-click-target')) \{\par
        this.appContents_.classList.add('suppress-active');\par
      \} else \{\par
        this.appContents_.classList.remove('suppress-active');\par
      \}\par
\par
      // This class is here so we don't show the focus state for apps that\par
      // gain keyboard focus via mouse clicking.\par
      this.classList.add('click-focus');\par
    \},\par
\par
    /**\par
     * This app is losing keyboard focus.\par
     * @param \{Event\} e The event.\par
     */\par
    onBlur_: function(e) \{\par
      this.classList.remove('click-focus');\par
    \},\par
\par
    /**\par
     * Change the appData and update the appearance of the app.\par
     * @param \{Object\} appData The new data object that describes the app.\par
     */\par
    replaceAppData: function(appData) \{\par
      this.appData_ = appData;\par
      this.setIcon();\par
      this.loadIcon();\par
    \},\par
\par
    /**\par
     * The data and preferences for this app.\par
     * @type \{Object\}\par
     */\par
    set appData(data) \{\par
      this.appData_ = data;\par
    \},\par
    get appData() \{\par
      return this.appData_;\par
    \},\par
\par
    get appId() \{\par
      return this.appData_.id;\par
    \},\par
\par
    /**\par
     * Returns a pointer to the context menu for this app. All apps share the\par
     * singleton AppContextMenu. This function is called by the\par
     * ContextMenuHandler in response to the 'contextmenu' event.\par
     * @type \{cr.ui.Menu\}\par
     */\par
    get contextMenu() \{\par
      var menu = AppContextMenu.getInstance();\par
      menu.setupForApp(this);\par
      return menu.menu;\par
    \},\par
\par
    /**\par
     * Returns whether this element can be 'removed' from chrome (i.e. whether\par
     * the user can drag it onto the trash and expect something to happen).\par
     * @return \{boolean\} True if the app can be uninstalled.\par
     */\par
    canBeRemoved: function() \{\par
      return this.appData_.can_uninstall;\par
    \},\par
\par
    /**\par
     * Uninstalls the app after it's been dropped on the trash.\par
     */\par
    removeFromChrome: function() \{\par
      chrome.send('uninstallApp', [this.appData_.id, true]);\par
      this.tile.tilePage.removeTile(this.tile, true);\par
      if (this.currentBubbleShowing_)\par
        currentBubbleShowing_.hide();\par
    \},\par
\par
    /**\par
     * Called when a drag is starting on the tile. Updates dataTransfer with\par
     * data for this tile.\par
     */\par
    setDragData: function(dataTransfer) \{\par
      dataTransfer.setData('Text', this.appData_.title);\par
      dataTransfer.setData('URL', this.appData_.url);\par
    \},\par
  \};\par
\par
  var TilePage = ntp4.TilePage;\par
\par
  // The fraction of the app tile size that the icon uses.\par
  var APP_IMG_SIZE_FRACTION = 4 / 5;\par
\par
  var appsPageGridValues = \{\par
    // The fewest tiles we will show in a row.\par
    minColCount: 3,\par
    // The most tiles we will show in a row.\par
    maxColCount: 6,\par
\par
    // The smallest a tile can be.\par
    minTileWidth: 64 / APP_IMG_SIZE_FRACTION,\par
    // The biggest a tile can be.\par
    maxTileWidth: 128 / APP_IMG_SIZE_FRACTION,\par
\par
    // The padding between tiles, as a fraction of the tile width.\par
    tileSpacingFraction: 1 / 8,\par
  \};\par
  TilePage.initGridValues(appsPageGridValues);\par
\par
  /**\par
   * Creates a new AppsPage object.\par
   * @constructor\par
   * @extends \{TilePage\}\par
   */\par
  function AppsPage() \{\par
    var el = new TilePage(appsPageGridValues);\par
    el.__proto__ = AppsPage.prototype;\par
    el.initialize();\par
\par
    return el;\par
  \}\par
\par
  AppsPage.prototype = \{\par
    __proto__: TilePage.prototype,\par
\par
    initialize: function() \{\par
      this.classList.add('apps-page');\par
\par
      this.addEventListener('cardselected', this.onCardSelected_);\par
      // Add event listeners for two events, so we can temporarily suppress\par
      // the app notification bubbles when the app card slides in and out of\par
      // view.\par
      this.addEventListener('carddeselected', this.onCardDeselected_);\par
      this.addEventListener('cardSlider:card_change_ended',\par
                            this.onCardChangeEnded_);\par
\par
      this.addEventListener('tilePage:tile_added', this.onTileAdded_);\par
\par
      this.content_.addEventListener('scroll', this.onScroll_.bind(this));\par
    \},\par
\par
    /**\par
     * Creates an app DOM element and places it at the last position on the\par
     * page.\par
     * @param \{Object\} appData The data object that describes the app.\par
     * @param \{boolean=\} animate If true, the app tile plays an animation.\par
     */\par
    appendApp: function(appData, animate) \{\par
      if (animate) \{\par
        // Select the page and scroll all the way down so the animation is\par
        // visible.\par
        ntp4.getCardSlider().selectCardByValue(this);\par
        this.content_.scrollTop = this.content_.scrollHeight;\par
      \}\par
      this.appendTile(new App(appData), animate);\par
    \},\par
\par
    /**\par
     * Handler for 'cardselected' event, fired when |this| is selected. The\par
     * first time this is called, we load all the app icons.\par
     * @private\par
     */\par
    onCardSelected_: function(e) \{\par
      var apps = this.querySelectorAll('.app.icon-loading');\par
      for (var i = 0; i < apps.length; i++) \{\par
        apps[i].loadIcon();\par
        if (apps[i].currentBubbleShowing_)\par
          apps[i].currentBubbleShowing_.suppressed = false;\par
      \}\par
    \},\par
\par
    /**\par
     * Handler for tile additions to this page.\par
     * @param \{Event\} e The tilePage:tile_added event.\par
     */\par
    onTileAdded_: function(e) \{\par
      assert(e.currentTarget == this);\par
      assert(e.addedTile.firstChild instanceof App);\par
      if (this.classList.contains('selected-card'))\par
        e.addedTile.firstChild.loadIcon();\par
    \},\par
\par
    /**\par
     * Handler for the when this.cardSlider ends change its card. If animated,\par
     * this happens when the -webkit-transition is done, otherwise happens\par
     * immediately (but after cardSlider:card_changed).\par
     * @private\par
     */\par
    onCardChangeEnded_: function(e) \{\par
      for (var i = 0; i < this.tileElements_.length; i++) \{\par
        var app = this.tileElements_[i].firstChild;\par
        assert(app instanceof App);\par
        if (app.currentBubbleShowing_)\par
          app.currentBubbleShowing_.suppressed = false;\par
      \}\par
    \},\par
\par
    /**\par
     * Handler for the 'carddeselected' event, fired when the user switches\par
     * to another 'card' than the App 'card' on the NTP (|this| gets\par
     * deselected).\par
     * @private\par
     */\par
    onCardDeselected_: function(e) \{\par
      for (var i = 0; i < this.tileElements_.length; i++) \{\par
        var app = this.tileElements_[i].firstChild;\par
        assert(app instanceof App);\par
        if (app.currentBubbleShowing_)\par
          app.currentBubbleShowing_.suppressed = true;\par
      \}\par
    \},\par
\par
    /**\par
     * A handler for when the apps page is scrolled (then we need to reposition\par
     * the bubbles.\par
     * @private\par
     */\par
    onScroll_: function(e) \{\par
      if (!this.selected)\par
        return;\par
      for (var i = 0; i < this.tileElements_.length; i++) \{\par
        var app = this.tileElements_[i].firstChild;\par
        assert(app instanceof App);\par
        if (app.currentBubbleShowing_)\par
          app.currentBubbleShowing_.resizeAndReposition();\par
        \}\par
    \},\par
\par
    /** @inheritdoc */\par
    doDragOver: function(e) \{\par
      var tile = ntp4.getCurrentlyDraggingTile();\par
      if (tile && !tile.querySelector('.app')) \{\par
        e.preventDefault();\par
        this.setDropEffect(e.dataTransfer);\par
      \} else \{\par
        TilePage.prototype.doDragOver.call(this, e);\par
      \}\par
    \},\par
\par
    /** @inheritDoc */\par
    shouldAcceptDrag: function(e) \{\par
      return !!ntp4.getCurrentlyDraggingTile() ||\par
          (e.dataTransfer && e.dataTransfer.types.indexOf('url') != -1);\par
    \},\par
\par
    /** @inheritDoc */\par
    addDragData: function(dataTransfer, index) \{\par
      var sourceId = -1;\par
      var currentlyDraggingTile = ntp4.getCurrentlyDraggingTile();\par
      if (currentlyDraggingTile) \{\par
        var tileContents = currentlyDraggingTile.firstChild;\par
        if (tileContents.classList.contains('app')) \{\par
          var originalPage = currentlyDraggingTile.tilePage;\par
          var samePageDrag = originalPage == this;\par
          sourceId = samePageDrag ? DRAG_SOURCE.SAME_APPS_PANE :\par
                                    DRAG_SOURCE.OTHER_APPS_PANE;\par
          this.tileGrid_.insertBefore(currentlyDraggingTile,\par
                                      this.tileElements_[index]);\par
          this.tileMoved(currentlyDraggingTile);\par
          if (!samePageDrag) \{\par
            originalPage.fireRemovedEvent(currentlyDraggingTile, index, true);\par
            this.fireAddedEvent(currentlyDraggingTile, index, true);\par
          \}\par
        \} else if (currentlyDraggingTile.querySelector('.most-visited')) \{\par
          this.generateAppForLink(tileContents.data);\par
          sourceId = DRAG_SOURCE.MOST_VISITED_PANE;\par
        \}\par
      \} else \{\par
        this.addOutsideData_(dataTransfer);\par
        sourceId = DRAG_SOURCE.OUTSIDE_NTP;\par
      \}\par
\par
      assert(sourceId != -1);\par
      chrome.send('metricsHandler:recordInHistogram',\par
          ['NewTabPage.AppsPageDragSource', sourceId, DRAG_SOURCE_LIMIT]);\par
    \},\par
\par
    /**\par
     * Adds drag data that has been dropped from a source that is not a tile.\par
     * @param \{Object\} dataTransfer The data transfer object that holds drop\par
     *     data.\par
     * @private\par
     */\par
    addOutsideData_: function(dataTransfer) \{\par
      var url = dataTransfer.getData('url');\par
      assert(url);\par
\par
      // If the dataTransfer has html data, use that html's text contents as the\par
      // title of the new link.\par
      var html = dataTransfer.getData('text/html');\par
      var title;\par
      if (html) \{\par
        // It's important that we don't attach this node to the document\par
        // because it might contain scripts.\par
        var node = this.ownerDocument.createElement('div');\par
        node.innerHTML = html;\par
        title = node.textContent;\par
      \}\par
\par
      // Make sure title is >=1 and <=45 characters for Chrome app limits.\par
      if (!title)\par
        title = url;\par
      if (title.length > 45)\par
        title = title.substring(0, 45);\par
      var data = \{url: url, title: title\};\par
\par
      // Synthesize an app.\par
      this.generateAppForLink(data);\par
    \},\par
\par
    /**\par
     * Creates a new crx-less app manifest and installs it.\par
     * @param \{Object\} data The data object describing the link. Must have |url|\par
     *     and |title| members.\par
     */\par
    generateAppForLink: function(data) \{\par
      assert(data.url != undefined);\par
      assert(data.title != undefined);\par
      var pageIndex = ntp4.getAppsPageIndex(this);\par
      chrome.send('generateAppForLink', [data.url, data.title, pageIndex]);\par
    \},\par
\par
    /** @inheritDoc */\par
    tileMoved: function(draggedTile) \{\par
      if (!(draggedTile.firstChild instanceof App))\par
        return;\par
\par
      var pageIndex = ntp4.getAppsPageIndex(this);\par
      chrome.send('setPageIndex', [draggedTile.firstChild.appId, pageIndex]);\par
\par
      var appIds = [];\par
      for (var i = 0; i < this.tileElements_.length; i++) \{\par
        var tileContents = this.tileElements_[i].firstChild;\par
        if (tileContents instanceof App)\par
          appIds.push(tileContents.appId);\par
      \}\par
\par
      chrome.send('reorderApps', [draggedTile.firstChild.appId, appIds]);\par
    \},\par
\par
    /** @inheritDoc */\par
    setDropEffect: function(dataTransfer) \{\par
      var tile = ntp4.getCurrentlyDraggingTile();\par
      if (tile && tile.querySelector('.app'))\par
        ntp4.setCurrentDropEffect(dataTransfer, 'move');\par
      else\par
        ntp4.setCurrentDropEffect(dataTransfer, 'copy');\par
    \},\par
  \};\par
\par
  AppsPage.setPromo = function(data) \{\par
    var store = document.querySelector('.webstore');\par
    if (store)\par
      store.setAppsPromoData(data);\par
  \};\par
\par
  /**\par
   * Launches the specified app using the APP_LAUNCH_NTP_APP_RE_ENABLE\par
   * histogram. This should only be invoked from the AppLauncherHandler.\par
   * @param \{String\} appID The ID of the app.\par
   */\par
  function launchAppAfterEnable(appId) \{\par
    chrome.send('launchApp', [appId, APP_LAUNCH.NTP_APP_RE_ENABLE]);\par
  \}\par
\par
  function appNotificationChanged(id, notification) \{\par
    var app = $(id);\par
    // The app might have been uninstalled, or notifications might be disabled.\par
    if (app && !app.appData.notifications_disabled)\par
      app.setupNotification_(notification);\par
  \}\par
\par
  return \{\par
    APP_LAUNCH: APP_LAUNCH,\par
    appNotificationChanged: appNotificationChanged,\par
    AppsPage: AppsPage,\par
    launchAppAfterEnable: launchAppAfterEnable,\par
  \};\par
\});\par
\par
// TODO(estade): update the content handlers to use ntp namespace instead of\par
// making these global.\par
var appNotificationChanged = ntp4.appNotificationChanged;\par
var launchAppAfterEnable = ntp4.launchAppAfterEnable;\par
</script>\par
<script>// Copyright (c) 2011 The Chromium Authors. All rights reserved.\par
// Use of this source code is governed by a BSD-style license that can be\par
// found in the LICENSE file.\par
\par
/**\par
 * @fileoverview DotList implementation\par
 */\par
\par
cr.define('ntp4', function() \{\par
  'use strict';\par
\par
  /**\par
   * Live list of the navigation dots.\par
   * @type \{!NodeList|undefined\}\par
   */\par
  var navDots;\par
\par
  /**\par
   * Creates a new DotList object.\par
   * @constructor\par
   * @extends \{HTMLUListElement\}\par
   */\par
  var DotList = cr.ui.define('ul');\par
\par
  DotList.prototype = \{\par
    __proto__: HTMLUListElement.prototype,\par
\par
    /** @inheritDoc */\par
    decorate: function() \{\par
      this.addEventListener('keydown', this.onKeyDown_.bind(this));\par
      navDots = this.getElementsByClassName('dot');\par
    \},\par
\par
    /**\par
     * Live list of the navigation dots.\par
     * @type \{!NodeList|undefined\}\par
     */\par
    get dots() \{\par
      return navDots;\par
    \},\par
\par
    /**\par
     * Handler for key events on the dot list. These keys will change the focus\par
     * element.\par
     * @param \{Event\} e The KeyboardEvent.\par
     */\par
    onKeyDown_: function(e) \{\par
      if (e.metaKey || e.shiftKey || e.altKey || e.ctrlKey)\par
        return;\par
\par
      var direction = 0;\par
      if (e.keyIdentifier == 'Left')\par
        direction = -1;\par
      else if (e.keyIdentifier == 'Right')\par
        direction = 1;\par
      else\par
        return;\par
\par
      var focusDot = this.querySelector('.dot:focus');\par
      if (!focusDot)\par
        return;\par
      var focusIndex = Array.prototype.indexOf.call(navDots, focusDot);\par
      var newFocusIndex = focusIndex + direction;\par
      if (focusIndex == newFocusIndex)\par
        return;\par
\par
      newFocusIndex = (newFocusIndex + navDots.length) % navDots.length;\par
      navDots[newFocusIndex].tabIndex = 3;\par
      navDots[newFocusIndex].focus();\par
      focusDot.tabIndex = -1;\par
\par
      e.stopPropagation();\par
      e.preventDefault();\par
    \}\par
  \};\par
\par
  return \{\par
    DotList: DotList\par
  \};\par
\});\par
</script>\par
<script>// Copyright (c) 2012 The Chromium Authors. All rights reserved.\par
// Use of this source code is governed by a BSD-style license that can be\par
// found in the LICENSE file.\par
\par
cr.define('ntp4', function() \{\par
  'use strict';\par
\par
  var TilePage = ntp4.TilePage;\par
\par
  /**\par
   * A counter for generating unique tile IDs.\par
   */\par
  var tileID = 0;\par
\par
  /**\par
   * Creates a new Most Visited object for tiling.\par
   * @constructor\par
   * @extends \{HTMLAnchorElement\}\par
   */\par
  function MostVisited() \{\par
    var el = cr.doc.createElement('a');\par
    el.__proto__ = MostVisited.prototype;\par
    el.initialize();\par
\par
    return el;\par
  \}\par
\par
  MostVisited.prototype = \{\par
    __proto__: HTMLAnchorElement.prototype,\par
\par
    initialize: function() \{\par
      this.reset();\par
\par
      this.addEventListener('click', this.handleClick_);\par
      this.addEventListener('keydown', this.handleKeyDown_);\par
    \},\par
\par
    get index() \{\par
      assert(this.tile);\par
      return this.tile.index;\par
    \},\par
\par
    get data() \{\par
      return this.data_;\par
    \},\par
\par
    /**\par
     * Clears the DOM hierarchy for this node, setting it back to the default\par
     * for a blank thumbnail.\par
     */\par
    reset: function() \{\par
      this.className = 'most-visited filler real';\par
      this.innerHTML =\par
          '<span class="thumbnail-wrapper fills-parent">' +\par
            '<div class="close-button"></div>' +\par
            '<span class="thumbnail fills-parent">' +\par
              // thumbnail-shield provides a gradient fade effect.\par
              '<div class="thumbnail-shield fills-parent"></div>' +\par
            '</span>' +\par
            '<span class="favicon"></span>' +\par
          '</span>' +\par
          '<div class="color-stripe"></div>' +\par
          '<span class="title"></span>';\par
\par
      this.querySelector('.close-button').title =\par
          templateData.removethumbnailtooltip;\par
\par
      this.tabIndex = -1;\par
      this.data_ = null;\par
      this.removeAttribute('id');\par
      this.title = '';\par
    \},\par
\par
    /**\par
     * Update the appearance of this tile according to |data|.\par
     * @param \{Object\} data A dictionary of relevant data for the page.\par
     */\par
    updateForData: function(data) \{\par
      if (this.classList.contains('blacklisted') && data) \{\par
        // Animate appearance of new tile.\par
        this.classList.add('new-tile-contents');\par
      \}\par
      this.classList.remove('blacklisted');\par
\par
      if (!data || data.filler) \{\par
        if (this.data_)\par
          this.reset();\par
        return;\par
      \}\par
\par
      var id = tileID++;\par
      this.id = 'most-visited-tile-' + id;\par
      this.data_ = data;\par
      this.classList.add('focusable');\par
\par
      var faviconDiv = this.querySelector('.favicon');\par
      var faviconUrl = 'chrome://favicon/size/16/' + data.url;\par
      faviconDiv.style.backgroundImage = url(faviconUrl);\par
      chrome.send('getFaviconDominantColor', [faviconUrl, this.id]);\par
\par
      var title = this.querySelector('.title');\par
      title.textContent = data.title;\par
      title.dir = data.direction;\par
\par
      // Sets the tooltip.\par
      this.title = data.title;\par
\par
      var thumbnailUrl = 'chrome://thumb/' + data.url;\par
      this.querySelector('.thumbnail').style.backgroundImage =\par
          url(thumbnailUrl);\par
\par
      this.href = data.url;\par
\par
      this.classList.remove('filler');\par
    \},\par
\par
    /**\par
     * Sets the color of the favicon dominant color bar.\par
     * @param \{string\} color The css-parsable value for the color.\par
     */\par
    set stripeColor(color) \{\par
      this.querySelector('.color-stripe').style.backgroundColor = color;\par
    \},\par
\par
    /**\par
     * Handles a click on the tile.\par
     * @param \{Event\} e The click event.\par
     */\par
    handleClick_: function(e) \{\par
      if (e.target.classList.contains('close-button')) \{\par
        this.blacklist_();\par
        e.preventDefault();\par
      \} else \{\par
        // Records an app launch from the most visited page (Chrome will decide\par
        // whether the url is an app). TODO(estade): this only works for clicks;\par
        // other actions like "open in new tab" from the context menu won't be\par
        // recorded. Can this be fixed?\par
        chrome.send('recordAppLaunchByURL',\par
                    [encodeURIComponent(this.href),\par
                     ntp4.APP_LAUNCH.NTP_MOST_VISITED]);\par
        // Records the index of this tile.\par
        chrome.send('metricsHandler:recordInHistogram',\par
                    ['NTP_MostVisited', this.index, 8]);\par
      \}\par
    \},\par
\par
    /**\par
     * Allow blacklisting most visited site using the keyboard.\par
     */\par
    handleKeyDown_: function(e) \{\par
      if (!cr.isMac && e.keyCode == 46 || // Del\par
          cr.isMac && e.metaKey && e.keyCode == 8) \{ // Cmd + Backspace\par
        this.blacklist_();\par
      \}\par
    \},\par
\par
    /**\par
     * Permanently removes a page from Most Visited.\par
     */\par
    blacklist_: function() \{\par
      this.showUndoNotification_();\par
      chrome.send('blacklistURLFromMostVisited', [this.data_.url]);\par
      this.reset();\par
      chrome.send('getMostVisited');\par
      this.classList.add('blacklisted');\par
    \},\par
\par
    showUndoNotification_: function() \{\par
      var data = this.data_;\par
      var self = this;\par
      var doUndo = function () \{\par
        chrome.send('removeURLsFromMostVisitedBlacklist', [data.url]);\par
        self.updateForData(data);\par
      \}\par
\par
      var undo = \{\par
        action: doUndo,\par
        text: templateData.undothumbnailremove,\par
      \}\par
\par
      var undoAll = \{\par
        action: function() \{\par
          chrome.send('clearMostVisitedURLsBlacklist', []);\par
        \},\par
        text: templateData.restoreThumbnailsShort,\par
      \}\par
\par
      ntp4.showNotification(templateData.thumbnailremovednotification,\par
                            [undo, undoAll]);\par
    \},\par
\par
    /**\par
     * Set the size and position of the most visited tile.\par
     * @param \{number\} size The total size of |this|.\par
     * @param \{number\} x The x-position.\par
     * @param \{number\} y The y-position.\par
     *     animate.\par
     */\par
    setBounds: function(size, x, y) \{\par
      this.style.width = size + 'px';\par
      this.style.height = heightForWidth(size) + 'px';\par
\par
      this.style.left = x + 'px';\par
      this.style.right = x + 'px';\par
      this.style.top = y + 'px';\par
    \},\par
\par
    /**\par
     * Returns whether this element can be 'removed' from chrome (i.e. whether\par
     * the user can drag it onto the trash and expect something to happen).\par
     * @return \{boolean\} True, since most visited pages can always be\par
     *     blacklisted.\par
     */\par
    canBeRemoved: function() \{\par
      return true;\par
    \},\par
\par
    /**\par
     * Removes this element from chrome, i.e. blacklists it.\par
     */\par
    removeFromChrome: function() \{\par
      this.blacklist_();\par
      this.parentNode.classList.add('finishing-drag');\par
    \},\par
\par
    /**\par
     * Called when a drag of this tile has ended (after all animations have\par
     * finished).\par
     */\par
    finalizeDrag: function() \{\par
      this.parentNode.classList.remove('finishing-drag');\par
    \},\par
\par
    /**\par
     * Called when a drag is starting on the tile. Updates dataTransfer with\par
     * data for this tile (for dragging outside of the NTP).\par
     */\par
    setDragData: function(dataTransfer) \{\par
      dataTransfer.setData('Text', this.data_.title);\par
      dataTransfer.setData('URL', this.data_.url);\par
    \},\par
  \};\par
\par
  var mostVisitedPageGridValues = \{\par
    // The fewest tiles we will show in a row.\par
    minColCount: 2,\par
    // The most tiles we will show in a row.\par
    maxColCount: 4,\par
\par
    // The smallest a tile can be.\par
    minTileWidth: 122,\par
    // The biggest a tile can be. 212 (max thumbnail width) + 2.\par
    maxTileWidth: 214,\par
\par
    // The padding between tiles, as a fraction of the tile width.\par
    tileSpacingFraction: 1 / 8,\par
  \};\par
  TilePage.initGridValues(mostVisitedPageGridValues);\par
\par
  /**\par
   * Calculates the height for a Most Visited tile for a given width. The size\par
   * is based on the thumbnail, which should have a 212:132 ratio.\par
   * @return \{number\} The height.\par
   */\par
  function heightForWidth(width) \{\par
    // The 2s are for borders, the 31 is for the title.\par
    return (width - 2) * 132 / 212 + 2 + 31;\par
  \}\par
\par
  var THUMBNAIL_COUNT = 8;\par
\par
  /**\par
   * Creates a new MostVisitedPage object.\par
   * @constructor\par
   * @extends \{TilePage\}\par
   */\par
  function MostVisitedPage() \{\par
    var el = new TilePage(mostVisitedPageGridValues);\par
    el.__proto__ = MostVisitedPage.prototype;\par
    el.initialize();\par
\par
    return el;\par
  \}\par
\par
  MostVisitedPage.prototype = \{\par
    __proto__: TilePage.prototype,\par
\par
    initialize: function() \{\par
      this.classList.add('most-visited-page');\par
      this.data_ = null;\par
      this.mostVisitedTiles_ = this.getElementsByClassName('most-visited real');\par
    \},\par
\par
    /**\par
     * Create blank (filler) tiles.\par
     * @private\par
     */\par
    createTiles_: function() \{\par
      for (var i = 0; i < THUMBNAIL_COUNT; i++) \{\par
        this.appendTile(new MostVisited());\par
      \}\par
    \},\par
\par
    /**\par
     * Update the tiles after a change to |data_|.\par
     */\par
    updateTiles_: function() \{\par
      for (var i = 0; i < THUMBNAIL_COUNT; i++) \{\par
        var page = this.data_[i];\par
        var tile = this.mostVisitedTiles_[i];\par
\par
        if (i >= this.data_.length)\par
          tile.reset();\par
        else\par
          tile.updateForData(page);\par
      \}\par
    \},\par
\par
    /**\par
     * Array of most visited data objects.\par
     * @type \{Array\}\par
     */\par
    get data() \{\par
      return this.data_;\par
    \},\par
    set data(data) \{\par
      var startTime = Date.now();\par
\par
      // The first time data is set, create the tiles.\par
      if (!this.data_) \{\par
        this.createTiles_();\par
        this.data_ = data.slice(0, THUMBNAIL_COUNT);\par
      \} else \{\par
        this.data_ = refreshData(this.data_, data);\par
      \}\par
\par
      this.updateTiles_();\par
      logEvent('mostVisited.layout: ' + (Date.now() - startTime));\par
    \},\par
\par
    /** @inheritDoc */\par
    shouldAcceptDrag: function(e) \{\par
      return false;\par
    \},\par
\par
    /** @inheritDoc */\par
    heightForWidth: heightForWidth,\par
  \};\par
\par
  /**\par
   * We've gotten additional Most Visited data. Update our old data with the\par
   * new data. The ordering of the new data is not important, except when a\par
   * page is pinned. Thus we try to minimize re-ordering.\par
   * @param \{Object\} oldData The current Most Visited page list.\par
   * @param \{Object\} newData The new Most Visited page list.\par
   * @return The merged page list that should replace the current page list.\par
   */\par
  function refreshData(oldData, newData) \{\par
    oldData = oldData.slice(0, THUMBNAIL_COUNT);\par
    newData = newData.slice(0, THUMBNAIL_COUNT);\par
\par
    // Copy over pinned sites directly.\par
    for (var j = 0; j < newData.length; j++) \{\par
      if (newData[j].pinned) \{\par
        oldData[j] = newData[j];\par
        // Mark the entry as 'updated' so we don't try to update again.\par
        oldData[j].updated = true;\par
        // Mark the newData page as 'used' so we don't try to re-use it.\par
        newData[j].used = true;\par
      \}\par
    \}\par
\par
    // Look through old pages; if they exist in the newData list, keep them\par
    // where they are.\par
    for (var i = 0; i < oldData.length; i++) \{\par
      if (!oldData[i] || oldData[i].updated)\par
        continue;\par
\par
      for (var j = 0; j < newData.length; j++) \{\par
        if (newData[j].used)\par
          continue;\par
\par
        if (newData[j].url == oldData[i].url) \{\par
          // The background image and other data may have changed.\par
          oldData[i] = newData[j];\par
          oldData[i].updated = true;\par
          newData[j].used = true;\par
          break;\par
        \}\par
      \}\par
    \}\par
\par
    // Look through old pages that haven't been updated yet; replace them.\par
    for (var i = 0; i < oldData.length; i++) \{\par
      if (oldData[i] && oldData[i].updated)\par
        continue;\par
\par
      for (var j = 0; j < newData.length; j++) \{\par
        if (newData[j].used)\par
          continue;\par
\par
        oldData[i] = newData[j];\par
        oldData[i].updated = true;\par
        newData[j].used = true;\par
        break;\par
      \}\par
\par
      if (oldData[i] && !oldData[i].updated)\par
        oldData[i] = null;\par
    \}\par
\par
    // Clear 'updated' flags so this function will work next time it's called.\par
    for (var i = 0; i < THUMBNAIL_COUNT; i++) \{\par
      if (oldData[i])\par
        oldData[i].updated = false;\par
    \}\par
\par
    return oldData;\par
  \};\par
\par
  return \{\par
    MostVisitedPage: MostVisitedPage,\par
    refreshData: refreshData,\par
  \};\par
\});\par
</script>\par
<script>// Copyright (c) 2011 The Chromium Authors. All rights reserved.\par
// Use of this source code is governed by a BSD-style license that can be\par
// found in the LICENSE file.\par
\par
/**\par
 * @fileoverview Trash\par
 * This is the class for the trash can that appears when dragging an app.\par
 */\par
\par
cr.define('ntp4', function() \{\par
  'use strict';\par
\par
  function Trash(trash) \{\par
    trash.__proto__ = Trash.prototype;\par
    trash.initialize();\par
    return trash;\par
  \}\par
\par
  Trash.prototype = \{\par
    __proto__: HTMLDivElement.prototype,\par
\par
    initialize: function(element) \{\par
      this.dragWrapper_ = new cr.ui.DragWrapper(this, this);\par
    \},\par
\par
    /**\par
     * Determines whether we are interested in the drag data for |e|.\par
     * @param \{Event\} e The event from drag enter.\par
     * @return \{bool\}\par
     */\par
    shouldAcceptDrag: function(e) \{\par
      var tile = ntp4.getCurrentlyDraggingTile();\par
      if (!tile)\par
        return false;\par
\par
      return tile.firstChild.canBeRemoved();\par
    \},\par
\par
    /**\par
     * Drag over handler.\par
     * @param \{Event\} e The drag event.\par
     */\par
    doDragOver: function(e) \{\par
      ntp4.getCurrentlyDraggingTile().dragClone.classList.add(\par
          'hovering-on-trash');\par
      ntp4.setCurrentDropEffect(e.dataTransfer, 'move');\par
      e.preventDefault();\par
    \},\par
\par
    /**\par
     * Drag enter handler.\par
     * @param \{Event\} e The drag event.\par
     */\par
    doDragEnter: function(e) \{\par
      this.doDragOver(e);\par
    \},\par
\par
    /**\par
     * Drop handler.\par
     * @param \{Event\} e The drag event.\par
     */\par
    doDrop: function(e) \{\par
      e.preventDefault();\par
\par
      var tile = ntp4.getCurrentlyDraggingTile();\par
      tile.firstChild.removeFromChrome();\par
      tile.landedOnTrash = true;\par
    \},\par
\par
    /**\par
     * Drag leave handler.\par
     * @param \{Event\} e The drag event.\par
     */\par
    doDragLeave: function(e) \{\par
      ntp4.getCurrentlyDraggingTile().dragClone.classList.remove(\par
          'hovering-on-trash');\par
    \},\par
  \};\par
\par
  return \{\par
    Trash: Trash,\par
  \};\par
\});\par
</script>\par
<script>// Copyright (c) 2012 The Chromium Authors. All rights reserved.\par
// Use of this source code is governed by a BSD-style license that can be\par
// found in the LICENSE file.\par
\par
/**\par
 * @fileoverview PageListView implementation.\par
 * PageListView manages page list, dot list, switcher buttons and handles apps\par
 * pages callbacks from backend.\par
 *\par
 * Note that you need to have AppLauncherHandler in your WebUI to use this code.\par
 */\par
\par
cr.define('ntp4', function() \{\par
  'use strict';\par
\par
  /**\par
   * Object for accessing localized strings.\par
   * @type \{!LocalStrings\}\par
   */\par
  var localStrings = new LocalStrings;\par
\par
  /**\par
   * Creates a PageListView object.\par
   * @constructor\par
   * @extends \{Object\}\par
   */\par
  function PageListView() \{\par
  \}\par
\par
  PageListView.prototype = \{\par
    /**\par
     * The CardSlider object to use for changing app pages.\par
     * @type \{CardSlider|undefined\}\par
     */\par
    cardSlider: undefined,\par
\par
    /**\par
     * The frame div for this.cardSlider.\par
     * @type \{!Element|undefined\}\par
     */\par
    sliderFrame: undefined,\par
\par
    /**\par
     * The 'page-list' element.\par
     * @type \{!Element|undefined\}\par
     */\par
    pageList: undefined,\par
\par
    /**\par
     * A list of all 'tile-page' elements.\par
     * @type \{!NodeList|undefined\}\par
     */\par
    tilePages: undefined,\par
\par
    /**\par
     * A list of all 'apps-page' elements.\par
     * @type \{!NodeList|undefined\}\par
     */\par
    appsPages: undefined,\par
\par
    /**\par
     * The Most Visited page.\par
     * @type \{!Element|undefined\}\par
     */\par
    mostVisitedPage: undefined,\par
\par
    /**\par
     * The 'dots-list' element.\par
     * @type \{!Element|undefined\}\par
     */\par
    dotList: undefined,\par
\par
    /**\par
     * The left and right paging buttons.\par
     * @type \{!Element|undefined\}\par
     */\par
    pageSwitcherStart: undefined,\par
    pageSwitcherEnd: undefined,\par
\par
    /**\par
     * The 'trash' element.  Note that technically this is unnecessary,\par
     * JavaScript creates the object for us based on the id.  But I don't want\par
     * to rely on the ID being the same, and JSCompiler doesn't know about it.\par
     * @type \{!Element|undefined\}\par
     */\par
    trash: undefined,\par
\par
    /**\par
     * The type of page that is currently shown. The value is a numerical ID.\par
     * @type \{number\}\par
     */\par
    shownPage: 0,\par
\par
    /**\par
     * The index of the page that is currently shown, within the page type.\par
     * For example if the third Apps page is showing, this will be 2.\par
     * @type \{number\}\par
     */\par
    shownPageIndex: 0,\par
\par
    /**\par
     * EventTracker for managing event listeners for page events.\par
     * @type \{!EventTracker\}\par
     */\par
    eventTracker: new EventTracker,\par
\par
    /**\par
     * If non-null, this is the ID of the app to highlight to the user the next\par
     * time getAppsCallback runs. "Highlight" in this case means to switch to\par
     * the page and run the new tile animation.\par
     * @type \{String\}\par
     */\par
    highlightAppId: null,\par
\par
    /**\par
     * Initializes page list view.\par
     * @param \{!Element\} pageList A DIV element to host all pages.\par
     * @param \{!Element\} dotList An UL element to host nav dots. Each dot\par
     *     represents a page.\par
     * @param \{!Element\} cardSliderFrame The card slider frame that hosts\par
     *     pageList and switcher buttons.\par
     * @param \{!Element|undefined\} opt_trash Optional trash element.\par
     * @param \{!Element|undefined\} opt_pageSwitcherStart Optional start page\par
     *     switcher button.\par
     * @param \{!Element|undefined\} opt_pageSwitcherEnd Optional end page\par
     *     switcher button.\par
     */\par
    initialize: function(pageList, dotList, cardSliderFrame, opt_trash,\par
                         opt_pageSwitcherStart, opt_pageSwitcherEnd) \{\par
      this.pageList = pageList;\par
\par
      this.dotList = dotList;\par
      cr.ui.decorate(this.dotList, ntp4.DotList);\par
\par
      this.trash = opt_trash;\par
      if (this.trash)\par
        new ntp4.Trash(this.trash);\par
\par
      this.pageSwitcherStart = opt_pageSwitcherStart;\par
      if (this.pageSwitcherStart)\par
        ntp4.initializePageSwitcher(this.pageSwitcherStart);\par
\par
      this.pageSwitcherEnd = opt_pageSwitcherEnd;\par
      if (this.pageSwitcherEnd)\par
        ntp4.initializePageSwitcher(this.pageSwitcherEnd);\par
\par
      this.shownPage = templateData.shown_page_type;\par
      this.shownPageIndex = templateData.shown_page_index;\par
\par
      // Request data on the apps so we can fill them in.\par
      // Note that this is kicked off asynchronously.  'getAppsCallback' will be\par
      // invoked at some point after this function returns.\par
      chrome.send('getApps');\par
\par
      document.addEventListener('keydown', this.onDocKeyDown_.bind(this));\par
      // Prevent touch events from triggering any sort of native scrolling\par
      document.addEventListener('touchmove', function(e) \{\par
        e.preventDefault();\par
      \}, true);\par
\par
      this.tilePages = this.pageList.getElementsByClassName('tile-page');\par
      this.appsPages = this.pageList.getElementsByClassName('apps-page');\par
\par
      // Initialize the cardSlider without any cards at the moment\par
      this.sliderFrame = cardSliderFrame;\par
      this.cardSlider = new cr.ui.CardSlider(this.sliderFrame, this.pageList,\par
          this.sliderFrame.offsetWidth);\par
      this.cardSlider.initialize();\par
\par
      // Handle events from the card slider.\par
      this.pageList.addEventListener('cardSlider:card_changed',\par
                                     this.onCardChanged_.bind(this));\par
      this.pageList.addEventListener('cardSlider:card_added',\par
                                     this.onCardAdded_.bind(this));\par
      this.pageList.addEventListener('cardSlider:card_removed',\par
                                     this.onCardRemoved_.bind(this));\par
\par
      // Ensure the slider is resized appropriately with the window\par
      window.addEventListener('resize', this.onWindowResize_.bind(this));\par
\par
      // Update apps when online state changes.\par
      window.addEventListener('online',\par
          this.updateOfflineEnabledApps_.bind(this));\par
      window.addEventListener('offline',\par
          this.updateOfflineEnabledApps_.bind(this));\par
    \},\par
\par
    /**\par
     * Appends a tile page.\par
     *\par
     * @param \{TilePage\} page The page element.\par
     * @param \{string\} title The title of the tile page.\par
     * @param \{bool\} titleIsEditable If true, the title can be changed.\par
     * @param \{TilePage\} opt_refNode Optional reference node to insert in front\par
     *     of.\par
     * When opt_refNode is falsey, |page| will just be appended to the end of\par
     * the page list.\par
     */\par
    appendTilePage: function(page, title, titleIsEditable, opt_refNode) \{\par
      if (opt_refNode) \{\par
        var refIndex = this.getTilePageIndex(opt_refNode);\par
        this.cardSlider.insertCardAtIndex(page, refIndex);\par
      \} else \{\par
        this.cardSlider.appendCard(page);\par
      \}\par
\par
      // Remember special MostVisitedPage.\par
      if (typeof ntp4.MostVisitedPage != 'undefined' &&\par
          page instanceof ntp4.MostVisitedPage) \{\par
        assert(this.tilePages.length == 1,\par
               'MostVisitedPage should be added as first tile page');\par
        this.mostVisitedPage = page;\par
      \}\par
\par
      // If we're appending an AppsPage and it's a temporary page, animate it.\par
      var animate = page instanceof ntp4.AppsPage &&\par
                    page.classList.contains('temporary');\par
      // Make a deep copy of the dot template to add a new one.\par
      var newDot = new ntp4.NavDot(page, title, titleIsEditable, animate);\par
      page.navigationDot = newDot;\par
      this.dotList.insertBefore(newDot, opt_refNode ? opt_refNode.navigationDot\par
                                                    : null);\par
      // Set a tab index on the first dot.\par
      if (this.dotList.dots.length == 1)\par
        newDot.tabIndex = 3;\par
\par
      this.eventTracker.add(page, 'pagelayout', this.onPageLayout_.bind(this));\par
    \},\par
\par
    /**\par
     * Called by chrome when an existing app has been disabled or\par
     * removed/uninstalled from chrome.\par
     * @param \{Object\} appData A data structure full of relevant information for\par
     *     the app.\par
     * @param \{boolean\} isUninstall True if the app is being uninstalled;\par
     *     false if the app is being disabled.\par
     * @param \{boolean\} fromPage True if the removal was from the current page.\par
     */\par
    appRemoved: function(appData, isUninstall, fromPage) \{\par
      var app = $(appData.id);\par
      assert(app, 'trying to remove an app that doesn\\'t exist');\par
\par
      if (!isUninstall)\par
        app.replaceAppData(appData);\par
      else\par
        app.remove(!!fromPage);\par
    \},\par
\par
    /**\par
     * @return \{boolean\} If the page is still starting up.\par
     * @private\par
     */\par
    isStartingUp_: function() \{\par
      return document.documentElement.classList.contains('starting-up');\par
    \},\par
\par
    /**\par
     * Callback invoked by chrome with the apps available.\par
     *\par
     * Note that calls to this function can occur at any time, not just in\par
     * response to a getApps request. For example, when a user\par
     * installs/uninstalls an app on another synchronized devices.\par
     * @param \{Object\} data An object with all the data on available\par
     *        applications.\par
     */\par
    getAppsCallback: function(data) \{\par
      var startTime = Date.now();\par
\par
      // Remember this to select the correct card when done rebuilding.\par
      var prevCurrentCard = this.cardSlider.currentCard;\par
\par
      // Make removal of pages and dots as quick as possible with less DOM\par
      // operations, reflows, or repaints. We set currentCard = 0 and remove\par
      // from the end to not encounter any auto-magic card selections in the\par
      // process and we hide the card slider throughout.\par
      this.cardSlider.currentCard = 0;\par
\par
      // Clear any existing apps pages and dots.\par
      // TODO(rbyers): It might be nice to preserve animation of dots after an\par
      // uninstall. Could we re-use the existing page and dot elements?  It\par
      // seems unfortunate to have Chrome send us the entire apps list after an\par
      // uninstall.\par
      while (this.appsPages.length > 0)\par
        this.removeTilePageAndDot_(this.appsPages[this.appsPages.length - 1]);\par
\par
      // Get the array of apps and add any special synthesized entries\par
      var apps = data.apps;\par
\par
      // Get a list of page names\par
      var pageNames = data.appPageNames;\par
\par
      function stringListIsEmpty(list) \{\par
        for (var i = 0; i < list.length; i++) \{\par
          if (list[i])\par
            return false;\par
        \}\par
        return true;\par
      \}\par
\par
      // Sort by launch ordinal\par
      apps.sort(function(a, b) \{\par
        return a.app_launch_ordinal > b.app_launch_ordinal ? 1 :\par
          a.app_launch_ordinal < b.app_launch_ordinal ? -1 : 0;\par
      \});\par
\par
      // An app to animate (in case it was just installed).\par
      var highlightApp;\par
\par
      // Add the apps, creating pages as necessary\par
      for (var i = 0; i < apps.length; i++) \{\par
        var app = apps[i];\par
        var pageIndex = app.page_index || 0;\par
        while (pageIndex >= this.appsPages.length) \{\par
          var pageName = localStrings.getString('appDefaultPageName');\par
          if (this.appsPages.length < pageNames.length)\par
            pageName = pageNames[this.appsPages.length];\par
\par
          var origPageCount = this.appsPages.length;\par
          this.appendTilePage(new ntp4.AppsPage(), pageName, true);\par
          // Confirm that appsPages is a live object, updated when a new page is\par
          // added (otherwise we'd have an infinite loop)\par
          assert(this.appsPages.length == origPageCount + 1,\par
                 'expected new page');\par
        \}\par
\par
        if (app.id == this.highlightAppId)\par
          highlightApp = app;\par
        else\par
          this.appsPages[pageIndex].appendApp(app);\par
      \}\par
\par
      ntp4.AppsPage.setPromo(data.showPromo ? data : null);\par
\par
      this.cardSlider.currentCard = prevCurrentCard;\par
\par
      // Tell the slider about the pages.\par
      this.updateSliderCards();\par
\par
      if (highlightApp)\par
        this.appAdded(highlightApp, true);\par
\par
      // Mark the current page.\par
      this.cardSlider.currentCardValue.navigationDot.classList.add('selected');\par
      logEvent('apps.layout: ' + (Date.now() - startTime));\par
\par
      document.documentElement.classList.remove('starting-up');\par
    \},\par
\par
    /**\par
     * Called by chrome when a new app has been added to chrome or has been\par
     * enabled if previously disabled.\par
     * @param \{Object\} appData A data structure full of relevant information for\par
     *     the app.\par
     */\par
    appAdded: function(appData, opt_highlight) \{\par
      if (appData.id == this.highlightAppId) \{\par
        opt_highlight = true;\par
        this.highlightAppId = null;\par
      \}\par
\par
      var pageIndex = appData.page_index || 0;\par
\par
      if (pageIndex >= this.appsPages.length) \{\par
        while (pageIndex >= this.appsPages.length) \{\par
          this.appendTilePage(new ntp4.AppsPage(),\par
                              localStrings.getString('appDefaultPageName'),\par
                              true);\par
        \}\par
        this.updateSliderCards();\par
      \}\par
\par
      var page = this.appsPages[pageIndex];\par
      var app = $(appData.id);\par
      if (app)\par
        app.replaceAppData(appData);\par
      else\par
        page.appendApp(appData, opt_highlight);\par
    \},\par
\par
    /**\par
     * Callback invoked by chrome whenever an app preference changes.\par
     * @param \{Object\} data An object with all the data on available\par
     *     applications.\par
     */\par
    appsPrefChangedCallback: function(data) \{\par
      for (var i = 0; i < data.apps.length; ++i) \{\par
        $(data.apps[i].id).appData = data.apps[i];\par
      \}\par
\par
      // Set the App dot names. Skip the first dot (Most Visited).\par
      var dots = this.dotList.getElementsByClassName('dot');\par
      var start = this.mostVisitedPage ? 1 : 0;\par
      for (var i = start; i < dots.length; ++i) \{\par
        dots[i].displayTitle = data.appPageNames[i - start] || '';\par
      \}\par
    \},\par
\par
    /**\par
     * Invoked whenever the pages in apps-page-list have changed so that\par
     * the Slider knows about the new elements.\par
     */\par
    updateSliderCards: function() \{\par
      var pageNo = Math.max(0, Math.min(this.cardSlider.currentCard,\par
                                        this.tilePages.length - 1));\par
      this.cardSlider.setCards(Array.prototype.slice.call(this.tilePages),\par
                               pageNo);\par
      switch (this.shownPage) \{\par
        case templateData['apps_page_id']:\par
          this.cardSlider.selectCardByValue(\par
              this.appsPages[Math.min(this.shownPageIndex,\par
                                      this.appsPages.length - 1)]);\par
          break;\par
        case templateData['most_visited_page_id']:\par
          if (this.mostVisitedPage)\par
            this.cardSlider.selectCardByValue(this.mostVisitedPage);\par
          break;\par
      \}\par
    \},\par
\par
    /**\par
     * Called whenever tiles should be re-arranging themselves out of the way\par
     * of a moving or insert tile.\par
     */\par
    enterRearrangeMode: function() \{\par
      var tempPage = new ntp4.AppsPage();\par
      tempPage.classList.add('temporary');\par
      var pageName = localStrings.getString('appDefaultPageName');\par
      this.appendTilePage(tempPage, pageName, true);\par
\par
      if (ntp4.getCurrentlyDraggingTile().firstChild.canBeRemoved())\par
        $('footer').classList.add('showing-trash-mode');\par
    \},\par
\par
    /**\par
     * Invoked whenever some app is released\par
     */\par
    leaveRearrangeMode: function() \{\par
      var tempPage = document.querySelector('.tile-page.temporary');\par
      var dot = tempPage.navigationDot;\par
      if (!tempPage.tileCount && tempPage != this.cardSlider.currentCardValue) \{\par
        this.removeTilePageAndDot_(tempPage, true);\par
      \} else \{\par
        tempPage.classList.remove('temporary');\par
        this.saveAppPageName(tempPage,\par
                             localStrings.getString('appDefaultPageName'));\par
      \}\par
\par
      $('footer').classList.remove('showing-trash-mode');\par
    \},\par
\par
    /**\par
     * Callback for the 'pagelayout' event.\par
     * @param \{Event\} e The event.\par
     */\par
    onPageLayout_: function(e) \{\par
      if (Array.prototype.indexOf.call(this.tilePages, e.currentTarget) !=\par
          this.cardSlider.currentCard) \{\par
        return;\par
      \}\par
\par
      this.updatePageSwitchers();\par
    \},\par
\par
    /**\par
     * Adjusts the size and position of the page switchers according to the\par
     * layout of the current card.\par
     */\par
    updatePageSwitchers: function() \{\par
      if (!this.pageSwitcherStart || !this.pageSwitcherEnd)\par
        return;\par
\par
      var page = this.cardSlider.currentCardValue;\par
\par
      this.pageSwitcherStart.hidden = !page ||\par
          (this.cardSlider.currentCard == 0);\par
      this.pageSwitcherEnd.hidden = !page ||\par
          (this.cardSlider.currentCard == this.cardSlider.cardCount - 1);\par
\par
      if (!page)\par
        return;\par
\par
      var pageSwitcherLeft = isRTL() ? this.pageSwitcherEnd\par
                                     : this.pageSwitcherStart;\par
      var pageSwitcherRight = isRTL() ? this.pageSwitcherStart\par
                                      : this.pageSwitcherEnd;\par
      var scrollbarWidth = page.scrollbarWidth;\par
      pageSwitcherLeft.style.width =\par
          (page.sideMargin + 13) + 'px';\par
      pageSwitcherLeft.style.left = '0';\par
      pageSwitcherRight.style.width =\par
          (page.sideMargin - scrollbarWidth + 13) + 'px';\par
      pageSwitcherRight.style.right = scrollbarWidth + 'px';\par
\par
      var offsetTop = page.querySelector('.tile-page-content').offsetTop + 'px';\par
      pageSwitcherLeft.style.top = offsetTop;\par
      pageSwitcherRight.style.top = offsetTop;\par
      pageSwitcherLeft.style.paddingBottom = offsetTop;\par
      pageSwitcherRight.style.paddingBottom = offsetTop;\par
    \},\par
\par
    /**\par
     * Returns the index of the given apps page.\par
     * @param \{AppsPage\} page The AppsPage we wish to find.\par
     * @return \{number\} The index of |page| or -1 if it is not in the\par
     *    collection.\par
     */\par
    getAppsPageIndex: function(page) \{\par
      return Array.prototype.indexOf.call(this.appsPages, page);\par
    \},\par
\par
    /**\par
     * Handler for cardSlider:card_changed events from this.cardSlider.\par
     * @param \{Event\} e The cardSlider:card_changed event.\par
     * @private\par
     */\par
    onCardChanged_: function(e) \{\par
      var page = e.cardSlider.currentCardValue;\par
\par
      // Don't change shownPage until startup is done (and page changes actually\par
      // reflect user actions).\par
      if (!this.isStartingUp_()) \{\par
        if (page.classList.contains('apps-page')) \{\par
          this.shownPage = templateData.apps_page_id;\par
          this.shownPageIndex = this.getAppsPageIndex(page);\par
        \} else if (page.classList.contains('most-visited-page')) \{\par
          this.shownPage = templateData.most_visited_page_id;\par
          this.shownPageIndex = 0;\par
        \} else \{\par
          console.error('unknown page selected');\par
        \}\par
        chrome.send('pageSelected', [this.shownPage, this.shownPageIndex]);\par
      \}\par
\par
      // Update the active dot\par
      var curDot = this.dotList.getElementsByClassName('selected')[0];\par
      if (curDot)\par
        curDot.classList.remove('selected');\par
      page.navigationDot.classList.add('selected');\par
      this.updatePageSwitchers();\par
    \},\par
\par
    /**\par
     * Listen for card additions to update the page switchers or the current\par
     * card accordingly.\par
     * @param \{Event\} e A card removed or added event.\par
     */\par
    onCardAdded_: function(e) \{\par
      // When the second arg passed to insertBefore is falsey, it acts just like\par
      // appendChild.\par
      this.pageList.insertBefore(e.addedCard, this.tilePages[e.addedIndex]);\par
      if (!this.isStartingUp_())\par
        this.updatePageSwitchers();\par
    \},\par
\par
    /**\par
     * Listen for card removals to update the page switchers or the current card\par
     * accordingly.\par
     * @param \{Event\} e A card removed or added event.\par
     */\par
    onCardRemoved_: function(e) \{\par
      e.removedCard.parentNode.removeChild(e.removedCard);\par
      if (!this.isStartingUp_())\par
        this.updatePageSwitchers();\par
    \},\par
\par
    /**\par
     * Save the name of an apps page.\par
     * Store the apps page name into the preferences store.\par
     * @param \{AppsPage\} appsPage The app page for which we wish to save.\par
     * @param \{string\} name The name of the page.\par
     */\par
    saveAppPageName: function(appPage, name) \{\par
      var index = this.getAppsPageIndex(appPage);\par
      assert(index != -1);\par
      chrome.send('saveAppPageName', [name, index]);\par
    \},\par
\par
    /**\par
     * Window resize handler.\par
     * @private\par
     */\par
    onWindowResize_: function(e) \{\par
      this.cardSlider.resize(this.sliderFrame.offsetWidth);\par
      this.updatePageSwitchers();\par
    \},\par
\par
    /**\par
     * Listener for offline status change events. Updates apps that are\par
     * not offline-enabled to be grayscale if the browser is offline.\par
     * @private\par
     */\par
    updateOfflineEnabledApps_: function() \{\par
      var apps = document.querySelectorAll('.app');\par
      for (var i = 0; i < apps.length; ++i) \{\par
        if (apps[i].appData.enabled && !apps[i].appData.offline_enabled) \{\par
          apps[i].setIcon();\par
          apps[i].loadIcon();\par
        \}\par
      \}\par
    \},\par
\par
    /**\par
     * Handler for key events on the page. Ctrl-Arrow will switch the visible\par
     * page.\par
     * @param \{Event\} e The KeyboardEvent.\par
     * @private\par
     */\par
    onDocKeyDown_: function(e) \{\par
      if (!e.ctrlKey || e.altKey || e.metaKey || e.shiftKey)\par
        return;\par
\par
      var direction = 0;\par
      if (e.keyIdentifier == 'Left')\par
        direction = -1;\par
      else if (e.keyIdentifier == 'Right')\par
        direction = 1;\par
      else\par
        return;\par
\par
      var cardIndex =\par
          (this.cardSlider.currentCard + direction +\par
           this.cardSlider.cardCount) % this.cardSlider.cardCount;\par
      this.cardSlider.selectCard(cardIndex, true);\par
\par
      e.stopPropagation();\par
    \},\par
\par
    /**\par
     * Returns the index of a given tile page.\par
     * @param \{TilePage\} page The TilePage we wish to find.\par
     * @return \{number\} The index of |page| or -1 if it is not in the\par
     *    collection.\par
     */\par
    getTilePageIndex: function(page) \{\par
      return Array.prototype.indexOf.call(this.tilePages, page);\par
    \},\par
\par
    /**\par
     * Removes a page and navigation dot (if the navdot exists).\par
     * @param \{TilePage\} page The page to be removed.\par
     * @param \{boolean=\} opt_animate If the removal should be animated.\par
     */\par
    removeTilePageAndDot_: function(page, opt_animate) \{\par
      if (page.navigationDot)\par
        page.navigationDot.remove(opt_animate);\par
      this.cardSlider.removeCard(page);\par
    \},\par
  \};\par
\par
  return \{\par
    PageListView: PageListView\par
  \};\par
\});\par
</script>\par
<script>// Copyright (c) 2012 The Chromium Authors. All rights reserved.\par
// Use of this source code is governed by a BSD-style license that can be\par
// found in the LICENSE file.\par
\par
/**\par
 * @fileoverview Page switcher\par
 * This is the class for the left and right navigation arrows that switch\par
 * between pages.\par
 */\par
cr.define('ntp4', function() \{\par
\par
  function PageSwitcher() \{\par
  \}\par
\par
  PageSwitcher.template = \{\par
    __proto__: HTMLButtonElement.prototype,\par
\par
    decorate: function(el) \{\par
      el.__proto__ = PageSwitcher.template;\par
\par
      el.addEventListener('click', el.activate_);\par
      el.addEventListener('mousewheel', el.onMouseWheel_);\par
\par
      el.direction_ = el.id == 'page-switcher-start' ? -1 : 1;\par
\par
      el.dragWrapper_ = new cr.ui.DragWrapper(el, el);\par
    \},\par
\par
    /**\par
     * Activate the switcher (go to the next card).\par
     * @private\par
     */\par
    activate_: function() \{\par
      var cardSlider = ntp4.getCardSlider();\par
      var index = cardSlider.currentCard + this.direction_;\par
      var numCards = cardSlider.cardCount - 1;\par
      cardSlider.selectCard(Math.max(0, Math.min(index, numCards)), true);\par
    \},\par
\par
    /**\par
     * Handler for the mousewheel event on a pager. We pass through the scroll\par
     * to the page. This is necssary because the page is our sibling in the DOM\par
     * hierarchy, so the event won't naturally pass through to it.\par
     * @param \{Event\} e The mousewheel event.\par
     * @private\par
     */\par
    onMouseWheel_: function(e) \{\par
      var page = ntp4.getCardSlider().currentCardValue;\par
      page.handleMouseWheel(e);\par
    \},\par
\par
    shouldAcceptDrag: function(e) \{\par
      // We allow all drags to trigger the page switching effect.\par
      return true;\par
    \},\par
\par
    doDragEnter: function(e) \{\par
      this.scheduleDelayedSwitch_();\par
      this.doDragOver(e);\par
    \},\par
\par
    doDragLeave: function(e) \{\par
      this.cancelDelayedSwitch_();\par
    \},\par
\par
    doDragOver: function(e) \{\par
      e.preventDefault();\par
      var targetPage = ntp4.getCardSlider().currentCardValue;\par
      if (targetPage.shouldAcceptDrag(e))\par
        targetPage.setDropEffect(e.dataTransfer);\par
    \},\par
\par
    doDrop: function(e) \{\par
      e.stopPropagation();\par
      this.cancelDelayedSwitch_();\par
\par
      var tile = ntp4.getCurrentlyDraggingTile();\par
      if (!tile)\par
        return;\par
\par
      var sourcePage = tile.tilePage;\par
      var targetPage = ntp4.getCardSlider().currentCardValue;\par
      if (targetPage == sourcePage || !targetPage.shouldAcceptDrag(e))\par
        return;\par
\par
      targetPage.appendDraggingTile();\par
    \},\par
\par
    /**\par
     * Starts a timer to activate the switcher. The timer repeats until\par
     * cancelled by cancelDelayedSwitch_.\par
     * @private\par
     */\par
    scheduleDelayedSwitch_: function() \{\par
      var self = this;\par
      function navPageClearTimeout() \{\par
        self.activate_();\par
        self.dragNavTimeout_ = null;\par
        self.scheduleDelayedSwitch_();\par
      \}\par
      this.dragNavTimeout_ = window.setTimeout(navPageClearTimeout, 500);\par
    \},\par
\par
    /**\par
     * Cancels the timer that activates the switcher while dragging.\par
     * @private\par
     */\par
    cancelDelayedSwitch_: function() \{\par
      if (this.dragNavTimeout_) \{\par
        window.clearTimeout(this.dragNavTimeout_);\par
        this.dragNavTimeout_ = null;\par
      \}\par
    \},\par
\par
  \};\par
\par
  return \{\par
    initializePageSwitcher: PageSwitcher.template.decorate\par
  \}\par
\});\par
</script>\par
\par
<script>// Copyright (c) 2012 The Chromium Authors. All rights reserved.\par
// Use of this source code is governed by a BSD-style license that can be\par
// found in the LICENSE file.\par
\par
/**\par
 * @fileoverview Nav dot\par
 * This is the class for the navigation controls that appear along the bottom\par
 * of the NTP.\par
 */\par
\par
cr.define('ntp4', function() \{\par
  'use strict';\par
\par
  /**\par
   * Creates a new navigation dot.\par
   * @param \{TilePage\} page The associated TilePage.\par
   * @param \{string\} title The title of the navigation dot.\par
   * @param \{bool\} titleIsEditable If true, the title can be changed.\par
   * @param \{bool\} animate If true, animates into existence.\par
   * @constructor\par
   * @extends \{HTMLLIElement\}\par
   */\par
  function NavDot(page, title, titleIsEditable, animate) \{\par
    var dot = cr.doc.createElement('li');\par
    dot.__proto__ = NavDot.prototype;\par
    dot.initialize(page, title, titleIsEditable, animate);\par
\par
    return dot;\par
  \}\par
\par
  NavDot.prototype = \{\par
    __proto__: HTMLLIElement.prototype,\par
\par
    initialize: function(page, title, titleIsEditable, animate) \{\par
      this.className = 'dot';\par
      this.setAttribute('role', 'button');\par
\par
      this.page_ = page;\par
\par
      var selectionBar = this.ownerDocument.createElement('div');\par
      selectionBar.className = 'selection-bar';\par
      this.appendChild(selectionBar);\par
\par
      // TODO(estade): should there be some limit to the number of characters?\par
      this.input_ = this.ownerDocument.createElement('input');\par
      this.input_.setAttribute('spellcheck', false);\par
      this.input_.value = title;\par
      // Take the input out of the tab-traversal focus order.\par
      this.input_.disabled = true;\par
      this.appendChild(this.input_);\par
\par
      this.displayTitle = title;\par
      this.titleIsEditable_ = titleIsEditable;\par
\par
      this.addEventListener('keydown', this.onKeyDown_);\par
      this.addEventListener('click', this.onClick_);\par
      this.addEventListener('dblclick', this.onDoubleClick_);\par
      this.dragWrapper_ = new cr.ui.DragWrapper(this, this);\par
      this.addEventListener('webkitTransitionEnd', this.onTransitionEnd_);\par
\par
      this.input_.addEventListener('blur', this.onInputBlur_.bind(this));\par
      this.input_.addEventListener('mousedown',\par
                                   this.onInputMouseDown_.bind(this));\par
      this.input_.addEventListener('keydown', this.onInputKeyDown_.bind(this));\par
\par
      if (animate) \{\par
        this.classList.add('small');\par
        var self = this;\par
        window.setTimeout(function() \{\par
          self.classList.remove('small');\par
        \}, 0);\par
      \}\par
    \},\par
\par
    /**\par
     * Gets the associated TilePage.\par
     * @return \{TilePage\}\par
     */\par
    get page() \{\par
      return this.page_;\par
    \},\par
\par
    /**\par
     * Sets/gets the display title.\par
     * @type \{String\} title The display name for this nav dot.\par
     */\par
    get displayTitle() \{\par
      return this.title;\par
    \},\par
    set displayTitle(title) \{\par
      this.title = this.input_.value = title;\par
    \},\par
\par
    /**\par
     * Removes the dot from the page. If |opt_animate| is truthy, we first\par
     * transition the element to 0 width.\par
     * @param \{boolean=\} opt_animate Whether to animate the removal or not.\par
     */\par
    remove: function(opt_animate) \{\par
      if (opt_animate)\par
        this.classList.add('small');\par
      else\par
        this.parentNode.removeChild(this);\par
    \},\par
\par
    /**\par
     * Navigates the card slider to the page for this dot.\par
     */\par
    switchToPage: function() \{\par
      ntp4.getCardSlider().selectCardByValue(this.page_, true);\par
    \},\par
\par
    /**\par
     * Handler for keydown event on the dot.\par
     * @param \{Event\} e The KeyboardEvent.\par
     */\par
    onKeyDown_: function(e) \{\par
      if (e.keyIdentifier == 'Enter') \{\par
        this.onClick_(e);\par
        e.stopPropagation();\par
      \}\par
    \},\par
\par
    /**\par
     * Clicking causes the associated page to show.\par
     * @param \{Event\} e The click event.\par
     * @private\par
     */\par
    onClick_: function(e) \{\par
      this.switchToPage();\par
      // The explicit focus call is necessary because of overriding the default\par
      // handling in onInputMouseDown_.\par
      if (this.ownerDocument.activeElement != this.input_)\par
        this.focus();\par
\par
      chrome.send('introMessageDismissed');\par
      e.stopPropagation();\par
    \},\par
\par
    /**\par
     * Double clicks allow the user to edit the page title.\par
     * @param \{Event\} e The click event.\par
     * @private\par
     */\par
    onDoubleClick_: function(e) \{\par
      if (this.titleIsEditable_) \{\par
        this.input_.disabled = false;\par
        this.input_.focus();\par
        this.input_.select();\par
      \}\par
    \},\par
\par
    /**\par
     * Prevent mouse down on the input from selecting it.\par
     * @param \{Event\} e The click event.\par
     * @private\par
     */\par
    onInputMouseDown_: function(e) \{\par
      if (this.ownerDocument.activeElement != this.input_)\par
        e.preventDefault();\par
    \},\par
\par
    /**\par
     * Handle keypresses on the input.\par
     * @param \{Event\} e The click event.\par
     * @private\par
     */\par
    onInputKeyDown_: function(e) \{\par
      switch (e.keyIdentifier) \{\par
        case 'U+001B':  // Escape cancels edits.\par
          this.input_.value = this.displayTitle;\par
        case 'Enter':  // Fall through.\par
          this.input_.blur();\par
          break;\par
      \}\par
    \},\par
\par
    /**\par
     * When the input blurs, commit the edited changes.\par
     * @param \{Event\} e The blur event.\par
     * @private\par
     */\par
    onInputBlur_: function(e) \{\par
      window.getSelection().removeAllRanges();\par
      this.displayTitle = this.input_.value;\par
      ntp4.saveAppPageName(this.page_, this.displayTitle);\par
      this.input_.disabled = true;\par
    \},\par
\par
    shouldAcceptDrag: function(e) \{\par
      return this.page_.shouldAcceptDrag(e);\par
    \},\par
\par
    /**\par
     * A drag has entered the navigation dot. If the user hovers long enough,\par
     * we will navigate to the relevant page.\par
     * @param \{Event\} e The MouseOver event for the drag.\par
     * @private\par
     */\par
    doDragEnter: function(e) \{\par
      var self = this;\par
      function navPageClearTimeout() \{\par
        self.switchToPage();\par
        self.dragNavTimeout = null;\par
      \}\par
      this.dragNavTimeout = window.setTimeout(navPageClearTimeout, 500);\par
\par
      this.doDragOver(e);\par
    \},\par
\par
    /**\par
     * A dragged element has moved over the navigation dot. Show the correct\par
     * indicator and prevent default handling so the <input> won't act as a drag\par
     * target.\par
     * @param \{Event\} e The MouseOver event for the drag.\par
     * @private\par
     */\par
    doDragOver: function(e) \{\par
      e.preventDefault();\par
\par
      if (!this.dragWrapper_.isCurrentDragTarget)\par
        ntp4.setCurrentDropEffect(e.dataTransfer, 'none');\par
      else\par
        this.page_.setDropEffect(e.dataTransfer);\par
    \},\par
\par
    /**\par
     * A dragged element has been dropped on the navigation dot. Tell the page\par
     * to append it.\par
     * @param \{Event\} e The MouseOver event for the drag.\par
     * @private\par
     */\par
    doDrop: function(e) \{\par
      e.stopPropagation();\par
      var tile = ntp4.getCurrentlyDraggingTile();\par
      if (tile && tile.tilePage != this.page_)\par
        this.page_.appendDraggingTile();\par
      // TODO(estade): handle non-tile drags.\par
\par
      this.cancelDelayedSwitch_();\par
    \},\par
\par
    /**\par
     * The drag has left the navigation dot.\par
     * @param \{Event\} e The MouseOver event for the drag.\par
     * @private\par
     */\par
    doDragLeave: function(e) \{\par
      this.cancelDelayedSwitch_();\par
    \},\par
\par
    /**\par
     * Cancels the timer for page switching.\par
     * @private\par
     */\par
    cancelDelayedSwitch_: function() \{\par
      if (this.dragNavTimeout) \{\par
        window.clearTimeout(this.dragNavTimeout);\par
        this.dragNavTimeout = null;\par
      \}\par
    \},\par
\par
    /**\par
     * A transition has ended.\par
     * @param \{Event\} e The transition end event.\par
     * @private\par
     */\par
    onTransitionEnd_: function(e) \{\par
      if (e.propertyName === 'max-width' && this.classList.contains('small'))\par
        this.parentNode.removeChild(this);\par
    \},\par
  \};\par
\par
  return \{\par
    NavDot: NavDot,\par
  \};\par
\});\par
</script>\par
<script>// Copyright (c) 2012 The Chromium Authors. All rights reserved.\par
// Use of this source code is governed by a BSD-style license that can be\par
// found in the LICENSE file.\par
\par
/**\par
 * @fileoverview New tab page\par
 * This is the main code for the new tab page used by touch-enabled Chrome\par
 * browsers.  For now this is still a prototype.\par
 */\par
\par
// Use an anonymous function to enable strict mode just for this file (which\par
// will be concatenated with other files when embedded in Chrome\par
cr.define('ntp4', function() \{\par
  'use strict';\par
\par
  /**\par
   * NewTabView instance.\par
   * @type \{!Object|undefined\}\par
   */\par
  var newTabView;\par
\par
  /**\par
   * The 'notification-container' element.\par
   * @type \{!Element|undefined\}\par
   */\par
  var notificationContainer;\par
\par
  /**\par
   * Object for accessing localized strings.\par
   * @type \{!LocalStrings\}\par
   */\par
  var localStrings = new LocalStrings;\par
\par
  /**\par
   * If non-null, an info bubble for showing messages to the user. It points at\par
   * the Most Visited label, and is used to draw more attention to the\par
   * navigation dot UI.\par
   * @type \{!Element|undefined\}\par
   */\par
  var infoBubble;\par
\par
  /**\par
   * If non-null, an bubble confirming that the user has signed into sync. It\par
   * points at the login status at the top of the page.\par
   * @type \{!Element|undefined\}\par
   */\par
  var loginBubble;\par
\par
  /**\par
   * true if |loginBubble| should be shown.\par
   * @type \{Boolean\}\par
   */\par
  var shouldShowLoginBubble = false;\par
\par
  /**\par
   * The time in milliseconds for most transitions.  This should match what's\par
   * in new_tab.css.  Unfortunately there's no better way to try to time\par
   * something to occur until after a transition has completed.\par
   * @type \{number\}\par
   * @const\par
   */\par
  var DEFAULT_TRANSITION_TIME = 500;\par
\par
  /**\par
   * Creates a NewTabView object. NewTabView extends PageListView with\par
   * new tab UI specific logics.\par
   * @constructor\par
   * @extends \{PageListView\}\par
   */\par
  function NewTabView() \{\par
    this.initialize(getRequiredElement('page-list'),\par
                    getRequiredElement('dot-list'),\par
                    getRequiredElement('card-slider-frame'),\par
                    getRequiredElement('trash'),\par
                    getRequiredElement('page-switcher-start'),\par
                    getRequiredElement('page-switcher-end'));\par
  \}\par
\par
  NewTabView.prototype = \{\par
    __proto__: ntp4.PageListView.prototype,\par
\par
    /** @inheritDoc */\par
    appendTilePage: function(page, title, titleIsEditable, opt_refNode) \{\par
      ntp4.PageListView.prototype.appendTilePage.apply(this, arguments);\par
\par
      if (infoBubble)\par
        window.setTimeout(infoBubble.reposition.bind(infoBubble), 0);\par
    \}\par
  \};\par
\par
  /**\par
   * Invoked at startup once the DOM is available to initialize the app.\par
   */\par
  function onLoad() \{\par
    cr.enablePlatformSpecificCSSRules();\par
\par
    measureNavDots();\par
\par
    // Load the current theme colors.\par
    themeChanged();\par
\par
    newTabView = new NewTabView();\par
\par
    notificationContainer = getRequiredElement('notification-container');\par
    notificationContainer.addEventListener(\par
        'webkitTransitionEnd', onNotificationTransitionEnd);\par
\par
    cr.ui.decorate($('recently-closed-menu-button'), ntp4.RecentMenuButton);\par
    chrome.send('getRecentlyClosedTabs');\par
\par
    newTabView.appendTilePage(new ntp4.MostVisitedPage(),\par
                              localStrings.getString('mostvisited'),\par
                              false);\par
    chrome.send('getMostVisited');\par
\par
    if (templateData.isWebStoreExperimentEnabled) \{\par
      var webstoreLink = localStrings.getString('webStoreLink');\par
      var url = appendParam(webstoreLink, 'utm_source', 'chrome-ntp-launcher');\par
      $('chrome-web-store-href').href = url;\par
\par
      $('chrome-web-store-href').addEventListener('click',\par
          onChromeWebStoreButtonClick);\par
\par
      $('footer-content').classList.add('enable-cws-experiment');\par
    \}\par
\par
    if (localStrings.getString('login_status_message')) \{\par
      loginBubble = new cr.ui.Bubble;\par
      loginBubble.anchorNode = $('login-container');\par
      loginBubble.setArrowLocation(cr.ui.ArrowLocation.TOP_END);\par
      loginBubble.bubbleAlignment =\par
          cr.ui.BubbleAlignment.BUBBLE_EDGE_TO_ANCHOR_EDGE;\par
      loginBubble.deactivateToDismissDelay = 2000;\par
      loginBubble.setCloseButtonVisible(false);\par
\par
      $('login-status-learn-more').href =\par
          localStrings.getString('login_status_url');\par
      $('login-status-advanced').onclick = function() \{\par
        chrome.send('showAdvancedLoginUI');\par
      \}\par
      $('login-status-dismiss').onclick = loginBubble.hide.bind(loginBubble);\par
\par
      var bubbleContent = $('login-status-bubble-contents');\par
      loginBubble.content = bubbleContent;\par
\par
      // The anchor node won't be updated until updateLogin is called so don't\par
      // show the bubble yet.\par
      shouldShowLoginBubble = true;\par
    \} else if (localStrings.getString('ntp4_intro_message')) \{\par
      infoBubble = new cr.ui.Bubble;\par
      infoBubble.anchorNode = newTabView.mostVisitedPage.navigationDot;\par
      infoBubble.setArrowLocation(cr.ui.ArrowLocation.BOTTOM_START);\par
      infoBubble.handleCloseEvent = function() \{\par
        this.hide();\par
        chrome.send('introMessageDismissed');\par
      \}\par
\par
      var bubbleContent = $('ntp4-intro-bubble-contents');\par
      infoBubble.content = bubbleContent;\par
\par
      var learnMoreLink = infoBubble.querySelector('a');\par
      learnMoreLink.href = localStrings.getString('ntp4_intro_url');\par
      learnMoreLink.onclick = infoBubble.hide.bind(infoBubble);\par
\par
      infoBubble.show();\par
      chrome.send('introMessageSeen');\par
    \}\par
\par
    var serverpromo = localStrings.getString('serverpromo');\par
    if (serverpromo) \{\par
      showNotification(parseHtmlSubset(serverpromo), [], function() \{\par
        chrome.send('closeNotificationPromo');\par
      \}, 60000);\par
      chrome.send('notificationPromoViewed');\par
    \}\par
\par
    var loginContainer = getRequiredElement('login-container');\par
    loginContainer.addEventListener('click', function() \{\par
      var rect = loginContainer.getBoundingClientRect();\par
      chrome.send('showSyncLoginUI',\par
                  [rect.left, rect.top, rect.width, rect.height]);\par
    \});\par
    chrome.send('initializeSyncLogin');\par
  \}\par
\par
  /**\par
   * Launches the chrome web store app with the chrome-ntp-launcher\par
   * source.\par
   * @param \{Event\} e The click event.\par
   */\par
  function onChromeWebStoreButtonClick(e) \{\par
    chrome.send('recordAppLaunchByURL',\par
                [encodeURIComponent(this.href),\par
                 ntp4.APP_LAUNCH.NTP_WEBSTORE_FOOTER]);\par
  \}\par
\par
  /**\par
   * Fills in an invisible div with the 'Most Visited' string so that\par
   * its length may be measured and the nav dots sized accordingly.\par
   */\par
  function measureNavDots() \{\par
    var measuringDiv = $('fontMeasuringDiv');\par
    measuringDiv.textContent = localStrings.getString('mostvisited');\par
    var pxWidth = Math.max(measuringDiv.clientWidth * 1.15, 80);\par
\par
    var styleElement = document.createElement('style');\par
    styleElement.type = 'text/css';\par
    // max-width is used because if we run out of space, the nav dots will be\par
    // shrunk.\par
    styleElement.textContent = '.dot \{ max-width: ' + pxWidth + 'px; \}';\par
    document.querySelector('head').appendChild(styleElement);\par
  \}\par
\par
  // TODO(estade): rename newtab.css to new_tab_theme.css\par
  function themeChanged(hasAttribution) \{\par
    $('themecss').href = 'chrome://theme/css/newtab.css?' + Date.now();\par
    if (typeof hasAttribution != 'undefined')\par
      document.documentElement.setAttribute('hasattribution', hasAttribution);\par
    updateLogo();\par
    updateAttribution();\par
  \}\par
\par
  /**\par
   * Sets the proper image for the logo at the bottom left.\par
   */\par
  function updateLogo() \{\par
    var imageId = 'IDR_PRODUCT_LOGO';\par
    if (document.documentElement.getAttribute('customlogo') == 'true')\par
      imageId = 'IDR_CUSTOM_PRODUCT_LOGO';\par
\par
    $('logo-img').src = 'chrome://theme/' + imageId + '?' + Date.now();\par
  \}\par
\par
  /**\par
   * Attributes the attribution image at the bottom left.\par
   */\par
  function updateAttribution() \{\par
    var attribution = $('attribution');\par
    if (document.documentElement.getAttribute('hasattribution') == 'true') \{\par
      $('attribution-img').src =\par
          'chrome://theme/IDR_THEME_NTP_ATTRIBUTION?' + Date.now();\par
      attribution.hidden = false;\par
    \} else \{\par
      attribution.hidden = true;\par
    \}\par
  \}\par
\par
  /**\par
   * Timeout ID.\par
   * @type \{number\}\par
   */\par
  var notificationTimeout_ = 0;\par
\par
  /**\par
   * Shows the notification bubble.\par
   * @param \{string|Node\} message The notification message or node to use as\par
   *     message.\par
   * @param \{Array.<\{text: string, action: function()\}>\} links An array of\par
   *     records describing the links in the notification. Each record should\par
   *     have a 'text' attribute (the display string) and an 'action' attribute\par
   *     (a function to run when the link is activated).\par
   * @param \{Function\} opt_closeHandler The callback invoked if the user\par
   *     manually dismisses the notification.\par
   */\par
  function showNotification(message, links, opt_closeHandler, opt_timeout) \{\par
    window.clearTimeout(notificationTimeout_);\par
\par
    var span = document.querySelector('#notification > span');\par
    if (typeof message == 'string') \{\par
      span.textContent = message;\par
    \} else \{\par
      span.textContent = '';  // Remove all children.\par
      span.appendChild(message);\par
    \}\par
\par
    var linksBin = $('notificationLinks');\par
    linksBin.textContent = '';\par
    for (var i = 0; i < links.length; i++) \{\par
      var link = linksBin.ownerDocument.createElement('div');\par
      link.textContent = links[i].text;\par
      link.action = links[i].action;\par
      link.onclick = function() \{\par
        this.action();\par
        hideNotification();\par
      \}\par
      link.setAttribute('role', 'button');\par
      link.setAttribute('tabindex', 0);\par
      link.className = 'linkButton';\par
      linksBin.appendChild(link);\par
    \}\par
\par
    document.querySelector('#notification button').onclick = function(e) \{\par
      if (opt_closeHandler)\par
        opt_closeHandler();\par
      hideNotification();\par
    \};\par
\par
    var timeout = opt_timeout || 10000;\par
    notificationContainer.hidden = false;\par
    notificationContainer.classList.remove('inactive');\par
    notificationTimeout_ = window.setTimeout(hideNotification, timeout);\par
  \}\par
\par
  /**\par
   * Hide the notification bubble.\par
   */\par
  function hideNotification() \{\par
    notificationContainer.classList.add('inactive');\par
  \}\par
\par
  /**\par
   * When done fading out, set hidden to true so the notification can't be\par
   * tabbed to or clicked.\par
   */\par
  function onNotificationTransitionEnd(e) \{\par
    if (notificationContainer.classList.contains('inactive'));\par
      notificationContainer.hidden = true;\par
  \}\par
\par
  function setRecentlyClosedTabs(dataItems) \{\par
    $('recently-closed-menu-button').dataItems = dataItems;\par
  \}\par
\par
  function setMostVisitedPages(data, hasBlacklistedUrls) \{\par
    newTabView.mostVisitedPage.data = data;\par
  \}\par
\par
  /**\par
   * Set the dominant color for a node. This will be called in response to\par
   * getFaviconDominantColor. The node represented by |id| better have a setter\par
   * for stripeColor.\par
   * @param \{string\} id The ID of a node.\par
   * @param \{string\} color The color represented as a CSS string.\par
   */\par
  function setStripeColor(id, color) \{\par
    var node = $(id);\par
    if (node)\par
      node.stripeColor = color;\par
  \}\par
\par
  /**\par
   * Updates the text displayed in the login container. If there is no text then\par
   * the login container is hidden.\par
   * @param \{string\} loginHeader The first line of text.\par
   * @param \{string\} loginSubHeader The second line of text.\par
   * @param \{string\} iconURL The url for the login status icon. If this is null\par
        then the login status icon is hidden.\par
   */\par
  function updateLogin(loginHeader, loginSubHeader, iconURL) \{\par
    if (loginHeader || loginSubHeader) \{\par
      $('login-container').hidden = false;\par
      $('login-status-header').innerHTML = loginHeader;\par
      $('login-status-sub-header').innerHTML = loginSubHeader;\par
      $('card-slider-frame').classList.add('showing-login-area');\par
\par
      if (iconURL) \{\par
        $('login-status-header-container').style.backgroundImage = url(iconURL);\par
        $('login-status-header-container').classList.add('login-status-icon');\par
      \} else \{\par
        $('login-status-header-container').style.backgroundImage = 'none';\par
        $('login-status-header-container').classList.remove(\par
            'login-status-icon');\par
      \}\par
    \} else \{\par
      $('login-container').hidden = true;\par
      $('card-slider-frame').classList.remove('showing-login-area');\par
    \}\par
    if (shouldShowLoginBubble) \{\par
      window.setTimeout(loginBubble.show.bind(loginBubble), 0);\par
      chrome.send('loginMessageSeen');\par
      shouldShowLoginBubble = false;\par
    \} else if (loginBubble) \{\par
      loginBubble.reposition();\par
    \}\par
  \}\par
\par
  /**\par
   * Wrappers to forward the callback to corresponding PageListView member.\par
   */\par
  function appAdded() \{\par
    return newTabView.appAdded.apply(newTabView, arguments);\par
  \}\par
\par
  function appRemoved() \{\par
    return newTabView.appRemoved.apply(newTabView, arguments);\par
  \}\par
\par
  function appsPrefChangeCallback() \{\par
    return newTabView.appsPrefChangedCallback.apply(newTabView, arguments);\par
  \}\par
\par
  function appsReordered() \{\par
    return newTabView.appsReordered.apply(newTabView, arguments);\par
  \}\par
\par
  function enterRearrangeMode() \{\par
    return newTabView.enterRearrangeMode.apply(newTabView, arguments);\par
  \}\par
\par
  function getAppsCallback() \{\par
    return newTabView.getAppsCallback.apply(newTabView, arguments);\par
  \}\par
\par
  function getAppsPageIndex() \{\par
    return newTabView.getAppsPageIndex.apply(newTabView, arguments);\par
  \}\par
\par
  function getCardSlider() \{\par
    return newTabView.cardSlider;\par
  \}\par
\par
  function leaveRearrangeMode() \{\par
    return newTabView.leaveRearrangeMode.apply(newTabView, arguments);\par
  \}\par
\par
  function saveAppPageName() \{\par
    return newTabView.saveAppPageName.apply(newTabView, arguments);\par
  \}\par
\par
  function setAppToBeHighlighted(appId) \{\par
    newTabView.highlightAppId = appId;\par
  \}\par
\par
  // Return an object with all the exports\par
  return \{\par
    appAdded: appAdded,\par
    appRemoved: appRemoved,\par
    appsPrefChangeCallback: appsPrefChangeCallback,\par
    enterRearrangeMode: enterRearrangeMode,\par
    getAppsCallback: getAppsCallback,\par
    getAppsPageIndex: getAppsPageIndex,\par
    getCardSlider: getCardSlider,\par
    onLoad: onLoad,\par
    leaveRearrangeMode: leaveRearrangeMode,\par
    saveAppPageName: saveAppPageName,\par
    setAppToBeHighlighted: setAppToBeHighlighted,\par
    setMostVisitedPages: setMostVisitedPages,\par
    setRecentlyClosedTabs: setRecentlyClosedTabs,\par
    setStripeColor: setStripeColor,\par
    showNotification: showNotification,\par
    themeChanged: themeChanged,\par
    updateLogin: updateLogin\par
  \};\par
\});\par
\par
// publish ntp globals\par
// TODO(estade): update the content handlers to use ntp namespace instead of\par
// making these global.\par
var getAppsCallback = ntp4.getAppsCallback;\par
var appsPrefChangeCallback = ntp4.appsPrefChangeCallback;\par
var themeChanged = ntp4.themeChanged;\par
var recentlyClosedTabs = ntp4.setRecentlyClosedTabs;\par
var setMostVisitedPages = ntp4.setMostVisitedPages;\par
var updateLogin = ntp4.updateLogin;\par
\par
document.addEventListener('DOMContentLoaded', ntp4.onLoad);\par
</script>\par
<script>// Copyright (c) 2011 The Chromium Authors. All rights reserved.\par
// Use of this source code is governed by a BSD-style license that can be\par
// found in the LICENSE file.\par
\par
/**\par
 * @fileoverview The recently closed menu: button, model data, and menu.\par
 */\par
\par
cr.define('ntp4', function() \{\par
  'use strict';\par
\par
  var localStrings = new LocalStrings();\par
\par
  /**\par
   * Returns the text used for a recently closed window.\par
   * @param \{number\} numTabs Number of tabs in the window.\par
   * @return \{string\} The text to use.\par
   */\par
  function formatTabsText(numTabs) \{\par
    if (numTabs == 1)\par
      return localStrings.getString('closedwindowsingle');\par
    return localStrings.getStringF('closedwindowmultiple', numTabs);\par
  \}\par
\par
  var Menu = cr.ui.Menu;\par
  var MenuItem = cr.ui.MenuItem;\par
  var MenuButton = cr.ui.MenuButton;\par
  var RecentMenuButton = cr.ui.define('button');\par
\par
  RecentMenuButton.prototype = \{\par
    __proto__: MenuButton.prototype,\par
\par
    decorate: function() \{\par
      MenuButton.prototype.decorate.call(this);\par
      this.menu = new Menu;\par
      cr.ui.decorate(this.menu, Menu);\par
      this.menu.classList.add('recent-menu');\par
      document.body.appendChild(this.menu);\par
\par
      this.needsRebuild_ = true;\par
      this.classList.add('invisible');\par
      this.anchorType = cr.ui.AnchorType.ABOVE;\par
      this.invertLeftRight = true;\par
    \},\par
\par
    /**\par
     * Shows the menu, first rebuilding it if necessary.\par
     * TODO(estade): the right of the menu should align with the right of the\par
     * button.\par
     * @override\par
     */\par
    showMenu: function() \{\par
      if (this.needsRebuild_) \{\par
        this.menu.textContent = '';\par
        this.dataItems_.forEach(this.addItem_, this);\par
        this.needsRebuild_ = false;\par
      \}\par
\par
      MenuButton.prototype.showMenu.call(this);\par
    \},\par
\par
    /**\par
     * Sets the menu model data.\par
     * @param \{Array\} dataItems Array of objects that describe the apps.\par
     */\par
    set dataItems(dataItems) \{\par
      this.dataItems_ = dataItems;\par
      this.needsRebuild_ = true;\par
      if (dataItems.length)\par
        this.classList.remove('invisible');\par
      else\par
        this.classList.add('invisible');\par
    \},\par
\par
    /**\par
     * Adds an app to the menu.\par
     * @param \{Object\} data An object encapsulating all data about the app.\par
     * @private\par
     */\par
    addItem_: function(data) \{\par
      var isWindow = data.type == 'window';\par
      var a = this.ownerDocument.createElement('a');\par
      a.className = 'recent-menu-item';\par
      if (isWindow) \{\par
        a.href = '';\par
        a.classList.add('recent-window');\par
        a.textContent = formatTabsText(data.tabs.length);\par
      \} else \{\par
        a.href = data.url;\par
        a.style.backgroundImage = 'url(chrome://favicon/' + data.url + ')';\par
        a.textContent = data.title;\par
      \}\par
\par
      function onClick(e) \{\par
        chrome.send('recordAppLaunchByURL',\par
                    [encodeURIComponent(data.url),\par
                     ntp4.APP_LAUNCH.NTP_RECENTLY_CLOSED]);\par
        var index = Array.prototype.indexOf.call(a.parentNode.children, a);\par
        chrome.send('reopenTab', [data.sessionId, index,\par
            e.button, e.altKey, e.ctrlKey, e.metaKey, e.shiftKey]);\par
        // We are likely deleted by this point!\par
\par
        e.preventDefault();\par
      \}\par
      a.addEventListener('click', onClick);\par
\par
      this.menu.appendChild(a);\par
      cr.ui.decorate(a, MenuItem);\par
    \},\par
  \};\par
\par
  return \{\par
    RecentMenuButton: RecentMenuButton,\par
  \};\par
\});\par
</script>\par
<style type="text/css">.dot \{ max-width: 80px; \}</style><style type="text/css"></style></head>\par
\par
<body>\par
  <button id="login-container" class="custom-appearance" hidden="">\par
    <div id="login-status-header-container" class="login-status-row">\par
      <div id="login-status-header"></div>\par
    </div>\par
    <div id="login-status-sub-header"></div>\par
  </button>\par
\par
  <div id="notification-container" class="inactive" hidden="">\par
    <div id="notification">\par
      <span></span>\par
      <div id="notificationLinks"></div>\par
      <button class="close-button custom-appearance">\par
      </button>\par
    </div>\par
  </div>\par
\par
  <div id="card-slider-frame">\par
    <button id="page-switcher-start" class="page-switcher custom-appearance" tabindex="2" style="width: 32.5px; left: 0px; top: 0px; padding-bottom: 0px; ">\f1\'8b\par
    </button>\par
    <div id="page-list" style="-webkit-transform: translate3d(-485px, 0px, 0px); "><div class="tile-page most-visited-page animating-tile-page" style="width: 485px; " tabindex="-1"><div class="tile-page-scrollbar" style="top: 0px; height: 0px; "></div><div class="tile-page-content"><div class="top-margin" style="margin-bottom: 0px; margin-top: 0px; "></div><div class="tile-grid" style="min-width: 259.25px; min-height: 3px; height: 491.8679245283019px; "><div class="tile real" style="left: 128.25px; right: 128.25px; top: 0px; "><a class="most-visited real focusable" tabindex="-1" title="Welcome to Google Chrome" style="width: 122px; height: 107.71698113207547px; left: -108.375px; right: -108.375px; top: 0px; " id="most-visited-tile-122" href="http://www.google.com/chrome/intl/en/welcome.html"><span class="thumbnail-wrapper fills-parent"><div class="close-button" title="Don't show on this page"></div><span class="thumbnail fills-parent" style="background-image: url(chrome://thumb/http://www.google.com/chrome/intl/en/welcome.html); "><div class="thumbnail-shield fills-parent"></div></span><span class="favicon" style="background-image: url(chrome://favicon/size/16/http://www.google.com/chrome/intl/en/welcome.html); "></span></span><div class="color-stripe" style="background-color: rgb(0, 147, 60); "></div><span class="title" dir="ltr">Welcome to Google Chrome</span></a></div><div class="tile real" style="left: 265.5px; right: 265.5px; top: 0px; "><a class="most-visited real focusable" tabindex="-1" title="Chrome Web Store" style="width: 122px; height: 107.71698113207547px; left: -108.375px; right: -108.375px; top: 0px; " id="most-visited-tile-123" href="https://chrome.google.com/webstore?hl=en"><span class="thumbnail-wrapper fills-parent"><div class="close-button" title="Don't show on this page"></div><span class="thumbnail fills-parent" style="background-image: url(chrome://thumb/https://chrome.google.com/webstore?hl=en); "><div class="thumbnail-shield fills-parent"></div></span><span class="favicon" style="background-image: url(chrome://favicon/size/16/https://chrome.google.com/webstore?hl=en); "></span></span><div class="color-stripe" style="background-color: rgb(63, 132, 197); "></div><span class="title" dir="ltr">Chrome Web Store</span></a></div><div class="tile real" style="left: 128.25px; right: 128.25px; top: 122.96698113207547px; "><a class="most-visited filler real" tabindex="-1" title="" style="width: 122px; height: 107.71698113207547px; left: -108.375px; right: -108.375px; top: 0px; "><span class="thumbnail-wrapper fills-parent"><div class="close-button" title="Don't show on this page"></div><span class="thumbnail fills-parent"><div class="thumbnail-shield fills-parent"></div></span><span class="favicon"></span></span><div class="color-stripe"></div><span class="title"></span></a></div><div class="tile real" style="left: 265.5px; right: 265.5px; top: 122.96698113207547px; "><a class="most-visited filler real" tabindex="-1" title="" style="width: 122px; height: 107.71698113207547px; left: -108.375px; right: -108.375px; top: 0px; "><span class="thumbnail-wrapper fills-parent"><div class="close-button" title="Don't show on this page"></div><span class="thumbnail fills-parent"><div class="thumbnail-shield fills-parent"></div></span><span class="favicon"></span></span><div class="color-stripe"></div><span class="title"></span></a></div><div class="tile real" style="left: 128.25px; right: 128.25px; top: 245.93396226415095px; "><a class="most-visited filler real" tabindex="-1" title="" style="width: 122px; height: 107.71698113207547px; left: -108.375px; right: -108.375px; top: 0px; "><span class="thumbnail-wrapper fills-parent"><div class="close-button" title="Don't show on this page"></div><span class="thumbnail fills-parent"><div class="thumbnail-shield fills-parent"></div></span><span class="favicon"></span></span><div class="color-stripe"></div><span class="title"></span></a></div><div class="tile real" style="left: 265.5px; right: 265.5px; top: 245.93396226415095px; "><a class="most-visited filler real" tabindex="-1" title="" style="width: 122px; height: 107.71698113207547px; left: -108.375px; right: -108.375px; top: 0px; "><span class="thumbnail-wrapper fills-parent"><div class="close-button" title="Don't show on this page"></div><span class="thumbnail fills-parent"><div class="thumbnail-shield fills-parent"></div></span><span class="favicon"></span></span><div class="color-stripe"></div><span class="title"></span></a></div><div class="tile real" style="left: 128.25px; right: 128.25px; top: 368.9009433962264px; "><a class="most-visited filler real" tabindex="-1" title="" style="width: 122px; height: 107.71698113207547px; left: -108.375px; right: -108.375px; top: 0px; "><span class="thumbnail-wrapper fills-parent"><div class="close-button" title="Don't show on this page"></div><span class="thumbnail fills-parent"><div class="thumbnail-shield fills-parent"></div></span><span class="favicon"></span></span><div class="color-stripe"></div><span class="title"></span></a></div><div class="tile real" style="left: 265.5px; right: 265.5px; top: 368.9009433962264px; "><a class="most-visited filler real" tabindex="-1" title="" style="width: 122px; height: 107.71698113207547px; left: -108.375px; right: -108.375px; top: 0px; "><span class="thumbnail-wrapper fills-parent"><div class="close-button" title="Don't show on this page"></div><span class="thumbnail fills-parent"><div class="thumbnail-shield fills-parent"></div></span><span class="favicon"></span></span><div class="color-stripe"></div><span class="title"></span></a></div></div></div></div><div class="tile-page apps-page selected-card animating-tile-page" style="width: 485px; " tabindex="1"><div class="tile-page-scrollbar" style="top: 0px; height: 0px; "></div><div class="tile-page-content"><div class="top-margin" style="margin-bottom: 4.603773584905667px; margin-top: -4.603773584905667px; "></div><div class="tile-grid" style="min-width: 260px; min-height: 3px; height: 180px; "><div class="tile real" style="left: 126px; right: 126px; top: 0px; "><div id="ahfgeienlihckogmohjhadlkjgocpleb" class="app focusable webstore" style="height: 80px; width: 80px; left: -106.5px; right: -106.5px; top: 0px; "><div id="" class="app-contents">\par
  <div class="app-img-container launch-click-target" title="Chrome Web Store" style="height: 64px; width: 64px; ">\par
    <img class="" src="chrome://extension-icon/ahfgeienlihckogmohjhadlkjgocpleb/128/0">\par
  <img class="apps-promo-logo"></div>\par
  <span class="title launch-click-target" title="Chrome Web Store">Chrome Web Store</span>\par
</div><div id="" class="apps-promo-extras">\par
  <h3 class="apps-promo-heading"></h3>\par
  <a class="apps-promo-link g-button-basic"></a>\par
</div></div></div><div class="tile real" style="left: 216px; right: 216px; top: 0px; "><div id="blpcfgokakmgnkcojhhkbfbldkacnbeo" class="app focusable" style="height: 80px; width: 80px; left: -106.5px; right: -106.5px; top: 0px; "><div id="" class="app-contents">\par
  <div class="app-img-container launch-click-target" title="YouTube" style="height: 64px; width: 64px; ">\par
    <img class="" src="chrome://extension-icon/blpcfgokakmgnkcojhhkbfbldkacnbeo/128/0">\par
  </div>\par
  <span class="title launch-click-target" title="YouTube">YouTube</span>\par
</div></div></div><div class="tile real" style="left: 306px; right: 306px; top: 0px; "><div id="coobgpohoikkiipiblmjeljniedjpjpf" class="app focusable" style="height: 80px; width: 80px; left: -106.5px; right: -106.5px; top: 0px; "><div id="" class="app-contents">\par
  <div class="app-img-container launch-click-target" title="Google Search" style="height: 64px; width: 64px; ">\par
    <img class="" src="chrome://extension-icon/coobgpohoikkiipiblmjeljniedjpjpf/128/0">\par
  </div>\par
  <span class="title launch-click-target" title="Google Search">Google Search</span>\par
</div></div></div><div class="tile real" style="left: 126px; right: 126px; top: 90px; "><div id="pjkljhegncpnkpknbcohdijeoejaedia" class="app focusable" style="height: 80px; width: 80px; left: -106.5px; right: -106.5px; top: 0px; "><div id="" class="app-contents">\par
  <div class="app-img-container launch-click-target" title="Gmail" style="height: 64px; width: 64px; ">\par
    <img class="" src="chrome://extension-icon/pjkljhegncpnkpknbcohdijeoejaedia/128/0">\par
  </div>\par
  <span class="title launch-click-target" title="Gmail">Gmail</span>\par
</div></div></div></div></div></div></div>\par
    <button id="page-switcher-end" class="page-switcher custom-appearance" tabindex="2" style="width: 19.5px; right: 13px; top: 0px; padding-bottom: 0px; " hidden="">\'9b\par
    </button>\par
    <div id="attribution" hidden="">\par
      <span i18n-content="attributionintro">Theme created by</span>\par
      <img id="attribution-img">\par
    </div>\par
  </div>\par
\par
  <div id="footer">\par
    <div id="footer-border"></div>\par
    <div id="footer-content">\par
      <img id="logo-img" src="chrome://theme/IDR_PRODUCT_LOGO?1455578975328">\par
\par
      <ul id="dot-list">\par
      <li class="dot" role="button" title="Most visited" tabindex="3"><div class="selection-bar"></div><input spellcheck="false" disabled=""></li><li class="dot selected" role="button" title="Apps"><div class="selection-bar"></div><input spellcheck="false" disabled=""></li></ul>\par
\par
      <button id="recently-closed-menu-button" class="custom-appearance">\par
        <span i18n-content="recentlyclosed">Recently closed</span>\par
        <div class="disclosure-triangle"></div>\par
        <div id="vertical-separator"></div>\par
      </button>\par
\par
      <a id="chrome-web-store-href">\par
        <span id="chrome-web-store-title" i18n-content="webStoreTitle">Chrome Web Store</span>\par
      </a>\par
\par
      <div id="trash" class="trash">\par
        <span class="lid"></span>\par
        <span class="can"></span>\par
        <span class="trash-text" i18n-content="appuninstall">Remove from Chrome</span>\par
      </div>\par
    </div>\par
  </div>\par
\par
\par
<!-- A div to hold all the templates, and in the darkness bind them. -->\par
<div hidden="">\par
\par
<!-- NTP4 intro bubble -->\par
<div id="ntp4-intro-bubble-contents">\par
  <div i18n-content="ntp4_intro_message">undefined</div>\par
  <a i18n-content="learn_more" target="_blank">undefined</a>\par
</div>\par
\par
<!-- Login status bubble -->\par
<div id="login-status-bubble-contents">\par
  <div id="login-status-message-container">\par
    <span i18n-content="login_status_message">undefined</span>\par
    <a id="login-status-learn-more" i18n-content="login_status_learn_more" target="_blank">undefined</a>\par
  </div>\par
  <div class="login-status-row">\par
    <div id="login-status-advanced-container">\par
      <a id="login-status-advanced" i18n-content="login_status_advanced" href="#">undefined</a>\par
    </div>\par
    <button id="login-status-dismiss" i18n-content="login_status_dismiss">undefined</button>\par
  </div>\par
</div>\par
\par
<!-- Apps promo. -->\par
<div id="apps-promo-extras-template" class="apps-promo-extras">\par
  <h3 class="apps-promo-heading"></h3>\par
  <a class="apps-promo-link g-button-basic"></a>\par
</div>\par
\par
<!-- App Contents w/ Large Icon -->\par
<div id="app-large-icon-template" class="app-contents">\par
  <div class="app-img-container">\par
    <img class="invisible">\par
  </div>\par
  <span class="title"></span>\par
</div>\par
\par
<!-- App Contents w/ Small Icon -->\par
<div id="app-small-icon-template" class="app-contents">\par
  <div class="app-icon-div">\par
    <div class="app-img-container">\par
      <img class="invisible">\par
    </div>\par
    <div class="color-stripe"></div>\par
  </div>\par
  <span class="title"></span>\par
</div>\par
\par
</div>\par
\par
<!-- This is used to measure text in the current locale. It is not visible. -->\par
<div id="fontMeasuringDiv">Most visited</div>\par
\par
\par
<script>var templateData = \{"anim":"true","appDefaultPageName":"Apps","appcreateshortcut":"Create shortcut","appdisablenotifications":"Disable notifications","applaunchtypefullscreen":"Open full screen","applaunchtypepinned":"Open as pinned tab","applaunchtyperegular":"Open as regular tab","applaunchtypewindow":"Open as window","appoptions":"Options","apps_page_id":2048,"appuninstall":"Remove from Chrome","attributionintro":"Theme created by","bookmarkbarattached":"false","closedwindowmultiple":"$1 Tabs","closedwindowsingle":"1 Tab","customlogo":"false","fontfamily":"Arial, sans-serif","fontsize":"84%","hasattribution":"false","isWebStoreExperimentEnabled":false,"most_visited_page_id":1024,"mostvisited":"Most visited","recentlyclosed":"Recently closed","removethumbnailtooltip":"Don't show on this page","restoreThumbnailsShort":"Restore all","shown_page_index":0,"shown_page_type":2048,"syncLinkText":"Advanced settings","syncispresent":"true","syncpromotext":"Sign in to $1","textdirection":"ltr","themegravity":"","thumbnailremovednotification":"Thumbnail removed.","title":"New Tab","undothumbnailremove":"Undo","webStoreLink":"https://chrome.google.com/webstore?hl=en-US","webStoreTitle":"Chrome Web Store"\};</script><script>// Copyright (c) 2010 The Chromium Authors. All rights reserved.\par
// Use of this source code is governed by a BSD-style license that can be\par
// found in the LICENSE file.\par
\par
/**\par
 * @fileoverview This is a simple template engine inspired by JsTemplates\par
 * optimized for i18n.\par
 *\par
 * It currently supports two handlers:\par
 *\par
 *   * i18n-content which sets the textContent of the element\par
 *\par
 *     <span i18n-content="myContent"></span>\par
 *     i18nTemplate.process(element, \{'myContent': 'Content'\});\par
 *\par
 *   * i18n-values is a list of attribute-value or property-value pairs.\par
 *     Properties are prefixed with a '.' and can contain nested properties.\par
 *\par
 *     <span i18n-values="title:myTitle;.style.fontSize:fontSize"></span>\par
 *     i18nTemplate.process(element, \{\par
 *       'myTitle': 'Title',\par
 *       'fontSize': '13px'\par
 *     \});\par
 */\par
\par
var i18nTemplate = (function() \{\par
  /**\par
   * This provides the handlers for the templating engine. The key is used as\par
   * the attribute name and the value is the function that gets called for every\par
   * single node that has this attribute.\par
   * @type \{Object\}\par
   */\par
  var handlers = \{\par
    /**\par
     * This handler sets the textContent of the element.\par
     */\par
    'i18n-content': function(element, attributeValue, obj) \{\par
      element.textContent = obj[attributeValue];\par
    \},\par
\par
    /**\par
     * This handler adds options to a select element.\par
     */\par
    'i18n-options': function(element, attributeValue, obj) \{\par
      var options = obj[attributeValue];\par
      options.forEach(function(values) \{\par
        var option = typeof values == 'string' ? new Option(values) :\par
            new Option(values[1], values[0]);\par
        element.appendChild(option);\par
      \});\par
    \},\par
\par
    /**\par
     * This is used to set HTML attributes and DOM properties,. The syntax is:\par
     *   attributename:key;\par
     *   .domProperty:key;\par
     *   .nested.dom.property:key\par
     */\par
    'i18n-values': function(element, attributeValue, obj) \{\par
      var parts = attributeValue.replace(/\\s/g, '').split(/;/);\par
      for (var j = 0; j < parts.length; j++) \{\par
        var a = parts[j].match(/^([^:]+):(.+)$/);\par
        if (a) \{\par
          var propName = a[1];\par
          var propExpr = a[2];\par
\par
          // Ignore missing properties\par
          if (propExpr in obj) \{\par
            var value = obj[propExpr];\par
            if (propName.charAt(0) == '.') \{\par
              var path = propName.slice(1).split('.');\par
              var object = element;\par
              while (object && path.length > 1) \{\par
                object = object[path.shift()];\par
              \}\par
              if (object) \{\par
                object[path] = value;\par
                // In case we set innerHTML (ignoring others) we need to\par
                // recursively check the content\par
                if (path == 'innerHTML') \{\par
                  process(element, obj);\par
                \}\par
              \}\par
            \} else \{\par
              element.setAttribute(propName, value);\par
            \}\par
          \} else \{\par
            console.warn('i18n-values: Missing value for "' + propExpr + '"');\par
          \}\par
        \}\par
      \}\par
    \}\par
  \};\par
\par
  var attributeNames = [];\par
  for (var key in handlers) \{\par
    attributeNames.push(key);\par
  \}\par
  var selector = '[' + attributeNames.join('],[') + ']';\par
\par
  /**\par
   * Processes a DOM tree with the \{@code obj\} map.\par
   */\par
  function process(node, obj) \{\par
    var elements = node.querySelectorAll(selector);\par
    for (var element, i = 0; element = elements[i]; i++) \{\par
      for (var j = 0; j < attributeNames.length; j++) \{\par
        var name = attributeNames[j];\par
        var att = element.getAttribute(name);\par
        if (att != null) \{\par
          handlers[name](element, att, obj);\par
        \}\par
      \}\par
    \}\par
  \}\par
\par
  return \{\par
    process: process\par
  \};\par
\})();\par
</script><script>// Copyright (c) 2010 The Chromium Authors. All rights reserved.\par
// Use of this source code is governed by a BSD-style license that can be\par
// found in the LICENSE file.\par
\par
// Invoke the template engine previously loaded from i18n_template.js\par
i18nTemplate.process(document, templateData);\par
</script><menu class="recent-menu" style="top: auto; left: auto; bottom: 49px; right: 0px; display: none; "><a class="recent-menu-item custom-appearance" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAkAAAAJCAYAAADgkQYQAAAAJUlEQVQYV2NgoDuYSQSGK/RB0+yDrACbQqwKkBUW41OArJB0AAACXws0ERupuAAAAABJRU5ErkJggg==" style="background-image: url(chrome://favicon/data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAkAAAAJCAYAAADgkQYQAAAAJUlEQVQYV2NgoDuYSQSGK/RB0+yDrACbQqwKkBUW41OArJB0AAACXws0ERupuAAAAABJRU5ErkJggg==); ">png (9\f0\'d79)</a><a class="recent-menu-item custom-appearance" href="chrome://theme/IDR_THEME_NTP_BACKGROUND?" style="background-image: url(chrome://favicon/chrome://theme/IDR_THEME_NTP_BACKGROUND?); ">IDR_THEME_NTP_BACKGROUND (42\'d742)</a><a class="recent-menu-item custom-appearance" href="chrome://theme/IDR_PRODUCT_LOGO?1455578975328" style="background-image: url(chrome://favicon/chrome://theme/IDR_PRODUCT_LOGO?1455578975328); ">IDR_PRODUCT_LOGO (171\'d732)</a><a class="recent-menu-item custom-appearance" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAQAAAC1+jfqAAAAiElEQVR42r2RsQrDMAxEBRdl8SDcX8lQPGg1GBI6lvz/h7QyRRXV0qUULwfvwZ1tenw5PxToRPWMC52eA9+WDnlh3HFQ/xBQl86NFYJqeGflkiogrOvVlIFhqURFVho3x1moGAa3deMs+LS30CAhBN5nNxeT5hbJ1zwmji2k+aF6NENIPf/hs54f0sZFUVAMigAAAABJRU5ErkJggg==" style="background-image: url(chrome://favicon/data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAQAAAC1+jfqAAAAiElEQVR42r2RsQrDMAxEBRdl8SDcX8lQPGg1GBI6lvz/h7QyRRXV0qUULwfvwZ1tenw5PxToRPWMC52eA9+WDnlh3HFQ/xBQl86NFYJqeGflkiogrOvVlIFhqURFVho3x1moGAa3deMs+LS30CAhBN5nNxeT5hbJ1zwmji2k+aF6NENIPf/hs54f0sZFUVAMigAAAABJRU5ErkJggg==); ">png (16\'d716)</a><a class="recent-menu-item custom-appearance" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAkAAAAJCAYAAADgkQYQAAAAJUlEQVQYV2NgoDuYSQSGK/RB0+yDrACbQqwKkBUW41OArJB0AAACXws0ERupuAAAAABJRU5ErkJggg==" style="background-image: url(chrome://favicon/data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAkAAAAJCAYAAADgkQYQAAAAJUlEQVQYV2NgoDuYSQSGK/RB0+yDrACbQqwKkBUW41OArJB0AAACXws0ERupuAAAAABJRU5ErkJggg==); ">png (9\'d79)</a><a class="recent-menu-item custom-appearance" href="chrome://theme/IDR_PRODUCT_LOGO?1455578975328" style="background-image: url(chrome://favicon/chrome://theme/IDR_PRODUCT_LOGO?1455578975328); ">IDR_PRODUCT_LOGO (171\'d732)</a><a class="recent-menu-item custom-appearance" href="chrome://extension-icon/blpcfgokakmgnkcojhhkbfbldkacnbeo/128/0" style="background-image: url(chrome://favicon/chrome://extension-icon/blpcfgokakmgnkcojhhkbfbldkacnbeo/128/0); ">0 (128\'d7128)</a><a class="recent-menu-item custom-appearance" href="chrome://theme/IDR_PRODUCT_LOGO?1455578975328" style="background-image: url(chrome://favicon/chrome://theme/IDR_PRODUCT_LOGO?1455578975328); ">IDR_PRODUCT_LOGO (171\'d732)</a><a class="recent-menu-item custom-appearance" href="https://www.google.co.th/?source=search_app&amp;gws_rd=cr,ssl&amp;ei=PV_CVr6ECtKUuATeqJngCA" style="background-image: url(chrome://favicon/https://www.google.co.th/?source=search_app&amp;gws_rd=cr,ssl&amp;ei=PV_CVr6ECtKUuATeqJngCA); ">Google</a></menu></body></html>\par
\par
}
 